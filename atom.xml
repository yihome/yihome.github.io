<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>yihome</title>
  <icon>https://www.gravatar.com/avatar/1dbd1d499c3a70d9e39ff8ab1bc714a3</icon>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://haojen.github.io/"/>
  <updated>2018-07-12T09:11:48.963Z</updated>
  <id>http://haojen.github.io/</id>
  
  <author>
    <name>houyi</name>
    <email>yihome926@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android权限管理</title>
    <link href="http://haojen.github.io/2018/07/11/Android%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/"/>
    <id>http://haojen.github.io/2018/07/11/Android权限管理/</id>
    <published>2018-07-11T06:26:22.000Z</published>
    <updated>2018-07-12T09:11:48.963Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Android动态权限"><a href="#Android动态权限" class="headerlink" title="Android动态权限"></a>Android动态权限</h2><p>Android6.0（API23）开始，系统权限出现了很大的变化，此前在权限的检查和获取只发生在app安装时，同时获取后可以一直享有权限。在6.0以后，一些敏感的权限需要动态的获取，同时每次用户可以随时关闭权限，因此需要在每次使用前进行权限检查和获取。</p><h2 id="权限等级"><a href="#权限等级" class="headerlink" title="权限等级"></a>权限等级</h2><p>6.0以后也不是所有权限的获取都需要动态的申请，权限被分成了几个等级，权限的等级主要有四种，分别是Normal、Signature、Dangerous和SignatureOrSystem。</p><ul><li>Normal等级：任何应用都可以申请，直接在manifest声明，安装时提示用户，之后会自动获取此类权限。</li><li>Dangerous等级：任何应用都可以申请，需要在manifest中声明，同时在使用时需要动态的获取权限。</li><li>Signature等级：只有与声明权限的apk使用相同的签名私钥才能申请权限。</li><li>SignatureOrSystem:只有与声明权限的apk使用相同的签名私钥或者在/system/app目录下的应用才能申请权限。</li></ul><p>这四种权限都是在manifest中声明权限时指定的，在普通的应用开发中我们一般需要关注的只有Normal和Dangerous两种，其中需要动态申请权限的只有Dangerous权限。</p><h2 id="Dangerous权限"><a href="#Dangerous权限" class="headerlink" title="Dangerous权限"></a>Dangerous权限</h2><p>Android下所有的Dangerous权限都被分成权限组，在动态申请权限时，申请的时提示给用户的信息都以组为单位的，比如如果app申请<code>READ_CONTACTS</code>权限,那么系统仅仅提示用户申请联系人权限，如果用户允许，在8.0以下的版本中同组的<code>WRITE_CONTACTS</code>也会一并被获取到，而在8.0及以上<code>WRITE_CONTACTS</code>权限还需要我们去动态的申请，但是系统会立即授予该权限而不会提示用户。</p><p>Dangerous权限分组</p><table><thead><tr><th>权限组</th><th>权限</th></tr></thead><tbody><tr><td>CALENDAR</td><td>READ_CALENDAR<br>WRITE_CALENDAR</td></tr><tr><td>CAMERA</td><td>CAMERA</td></tr><tr><td>CONTACTS</td><td>READ_CONTACTS<br>WRITE_CONTACTS<br>GET_ACCOUNTS</td></tr><tr><td>LOCATION</td><td>ACCESS_FINE_LOCATION<br>ACCESS_COARSE_LOCATION</td></tr><tr><td>MICROPHONE</td><td>RECORD_AUDIO</td></tr><tr><td>PHONE</td><td>READ_PHONE_STATE<br>READ_PHONE_NUMBERS<br>CALL_PHONE<br>ANSWER_PHONE_CALLS<br>READ_CALL_LOG<br>WRITE_CALL_LOG<br>ADD_VOICEMAIL<br>USE_SIP<br>PROCESS_OUTGOING_CALLS</td></tr><tr><td>SENSORS</td><td>BODY_SENSORS</td></tr><tr><td>SMS</td><td>SEND_SMS<br>RECEIVE_SMS<br>READ_SMS<br>RECEIVE_WAP_PUSH<br>RECEIVE_MMS</td></tr><tr><td>STORAGE</td><td>READ_EXTERNAL_STORAGE<br>WRITE_EXTERNAL_STORAGE</td></tr></tbody></table><h2 id="动态权限申请"><a href="#动态权限申请" class="headerlink" title="动态权限申请"></a>动态权限申请</h2><h3 id="申明权限"><a href="#申明权限" class="headerlink" title="申明权限"></a>申明权限</h3><p>对于Dangerous的权限，我们首先也需要在manifest中申请，这里以联系人权限为例</p><pre><code>&lt;uses-permission android:name=&quot;android.permission.READ_CONTACTS&quot;/&gt;&lt;uses-permission android:name=&quot;android.permission.WRITE_CONTACTS&quot;/&gt;</code></pre><h3 id="权限检查"><a href="#权限检查" class="headerlink" title="权限检查"></a>权限检查</h3><p>在使用试图操作联系人前需要首先确认有没有这个权限</p><pre><code>if(ContextCompat.checkSelfPermission(this, Manifest.permission.READ_CONTACTS)            != PackageManager.PERMISSION_GRANTED){    //申请权限    }else{      //读取联系人}</code></pre><p><code>ContextCompat.checkSelfPermission(Context context,  String permission)</code>方法用于检查App是否拥有参数指定的权限，方法的返回值为int，可能的取值如下</p><ul><li><p><code>PERMISSION_GRANTED</code> 已经获取权限</p></li><li><p><code>PERMISSION_DENIED</code> 还没有获取权限</p></li></ul><h3 id="权限申请"><a href="#权限申请" class="headerlink" title="权限申请"></a>权限申请</h3><p>如果尚未获取权限则在使用之前需要先申请权限</p><pre><code>ActivityCompat.requestPermissions(this,                new String[]{Manifest.permission.READ_CONTACTS},CODE_REQUEST_CONTACTS);</code></pre><p>一般情况下，<code>ActivityCompat.requestPermissions</code>方法会使用一个标准的对话框提示用户，但是有些机型则会跳转到一个新的页面做这件事（会导致Activity声明周期变化，甚至重启）。</p><p>申请之后则需要等待用户选择，如果如果你的<code>Activity</code>不是继承自<code>AppCompatActivity</code>，则需要实现<code>OnRequestPermissionsResultCallback</code>用于接收权限请求的结果回掉。</p><pre><code>public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {    super.onRequestPermissionsResult(requestCode, permissions, grantResults);    if(requestCode==CODE_REQUEST_CONTACTS){        if(grantResults[0]==PackageManager.PERMISSION_GRANTED){            //读取联系人        }else{            //权限获取失败        }    }}</code></pre><h3 id="合理的权限申请"><a href="#合理的权限申请" class="headerlink" title="合理的权限申请"></a>合理的权限申请</h3><p>用户首次拒绝授予权限之后，当第二次进行权限请求时，会出现“不再提示”的选项，如果用户勾选，则后续对此权限的申请将不再提示用户，直接失败。因此我们需要在合适的时机解释获取权限的原因，我们可以使用<code>ActivityCompat.shouldShowRequestPermissionRationale</code>方法来确定是否需要告知用户，这个方法默认情况下返回false，当用户拒绝过授予此权限后，这个返回值为true（用户勾选不再提示后返回值为false）。</p><pre><code>if (ContextCompat.checkSelfPermission(this, Manifest.permission.READ_CONTACTS)            != PackageManager.PERMISSION_GRANTED) {    if (ActivityCompat.shouldShowRequestPermissionRationale(this,                Manifest.permission.READ_CONTACTS)) {        //提示用户后申请权限    } else {        //申请权限        ActivityCompat.requestPermissions(this,                new String[]{Manifest.permission.READ_CONTACTS}, CODE_REQUEST_CONTACTS);    }} else {    //读取联系人}</code></pre><h3 id="权限被拒绝"><a href="#权限被拒绝" class="headerlink" title="权限被拒绝"></a>权限被拒绝</h3><p>权限被拒绝后，再次申请会继续弹出，但是当用户勾选“不再提示”后，下次权限申请系统将不再提示用户，而是直接拒绝，这种情况下，我们只能引导用户到设置里自己打开权限，我们可以在<code>onRequestPermissionsResult</code>中通过<code>ActivityCompat.shouldShowRequestPermissionRationale</code>来判断用户是否选择了不再提示。</p><pre><code>public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {    if (requestCode == CODE_REQUEST_CONTACTS) {        if (grantResults[0] == PackageManager.PERMISSION_GRANTED) {            //读取联系人        } else {            if(!ActivityCompat.shouldShowRequestPermissionRationale(this,                    Manifest.permission.READ_CONTACTS)){               //引导用户到设置页面开启权限            }        }    }}//跳转到设置页面相关代码Intent intent = new Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS);Uri uri = Uri.fromParts(&quot;package&quot;,getApplicationContext().getPackageName(), null);intent.setData(uri);startActivity(intent);</code></pre><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://blog.csdn.net/u013553529/article/details/53167072" target="_blank" rel="noopener">Android 权限的一些细节</a> </li><li><a href="https://blog.csdn.net/jltxgcy/article/details/48288467" target="_blank" rel="noopener">Android中的权限管理</a></li><li><a href="https://blog.csdn.net/lmj623565791/article/details/50709663" target="_blank" rel="noopener">Android 6.0 运行时权限处理完全解析</a></li><li><a href="https://www.jianshu.com/p/a51593817825" target="_blank" rel="noopener">Android6.0动态权限申请步骤以及需要注意的一些坑</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Android动态权限&quot;&gt;&lt;a href=&quot;#Android动态权限&quot; class=&quot;headerlink&quot; title=&quot;Android动态权限&quot;&gt;&lt;/a&gt;Android动态权限&lt;/h2&gt;&lt;p&gt;Android6.0（API23）开始，系统权限出现了很大的变化，此
      
    
    </summary>
    
    
      <category term="Android" scheme="http://haojen.github.io/tags/Android/"/>
    
      <category term="permission" scheme="http://haojen.github.io/tags/permission/"/>
    
  </entry>
  
  <entry>
    <title>AndrodUI测试入门</title>
    <link href="http://haojen.github.io/2018/03/05/AndrodUI%E6%B5%8B%E8%AF%95%E5%85%A5%E9%97%A8/"/>
    <id>http://haojen.github.io/2018/03/05/AndrodUI测试入门/</id>
    <published>2018-03-05T09:11:28.000Z</published>
    <updated>2018-03-05T09:12:30.176Z</updated>
    
    <content type="html"><![CDATA[<h2 id="UI测试"><a href="#UI测试" class="headerlink" title="UI测试"></a>UI测试</h2><p>UI 测试是为了确保对于用户的UI动作，app能返回正确的UI输出。根据实际实现方案大体可以分为两种：</p><ul><li>End-To-End（E2E）UI测试，直接通过客户端和后台服务器的交互测试整个系统，普通操作UI，通过网络获取数据，验证UI数据。实现简单，但是存在测试速度缓慢，可能因为网络导致测试用例不通过的问题。</li><li>封闭UI测试，测试方法使得测试不需要外部依赖和网络请求，使用Mock Server或者其他方式替代真实的网络请求，只验证UI输出的正确性。</li></ul><h2 id="UI测试框架"><a href="#UI测试框架" class="headerlink" title="UI测试框架"></a>UI测试框架</h2><p>Android之前比较流行的UI测试框架有<a href="https://github.com/RobotiumTech/robotium" target="_blank" rel="noopener">robotium</a>、<a href="http://appium.io/?yyue=a21bo.50862.201879" target="_blank" rel="noopener">Appium</a>、<a href="">uiautomator</a>、<a href="http://calaba.sh/?yyue=a21bo.50862.201879" target="_blank" rel="noopener">Calabash</a>、<a href="https://developer.android.com/training/testing/espresso/index.html" target="_blank" rel="noopener">Espresso</a>,但是其中Espresso作为Google官方开源的UI测试框架，以其官方的身份、完整的使用文档以及简单的使用方法，快速成为UI测试框架中的主流，本文就是以Espresso框架为主要测试框架。</p><h2 id="Espresso"><a href="#Espresso" class="headerlink" title="Espresso"></a>Espresso</h2><h3 id="介绍及集成"><a href="#介绍及集成" class="headerlink" title="介绍及集成"></a>介绍及集成</h3><p>Espresso 测试框架提供了一组 API 来构建 UI 测试，用于测试应用中的用户流。利用这些 API，您可以编写简洁、运行可靠的自动化 UI 测试。Espresso 非常适合编写白盒自动化测试，其中测试代码将利用所测试应用的实现代码详情。<br>目前Espresso最新的版本已经出道3.0.1，使用AS创建的工程，默认已经集成了2.2.2版本的Espresso，但是如果要集成最新版本的Espresso库，需要在仓库配置中添加对应仓库地址：</p><pre><code>allprojects {    repositories {        jcenter()        maven {            url &quot;https://maven.google.com&quot;            //Espresso3.0.1所在仓库地址        }    }}</code></pre><p>默认集成的Espresso包espresso-core及其相关依赖包，足以完成一般性的UI测试，除此之外Espresso还有一些扩展包，用于完成一些特殊的测试场景:</p><ul><li>espresso-web 提供了对WebView测试的相关支持</li><li>espresso-contrib 提供了对DatePicker, RecyclerView 和 Drawer等控件的特有动作、无障碍以及CountingIdlingResource的支持</li><li>espresso-intents 用于校验多app测试中intent的正确性</li><li>espresso-idling-resource（已经包含在core的依赖中）用于处理异步线程同步问题</li></ul><p>如果测试过程中不需要上述的扩展功能，则只需要添加core的依赖</p><pre><code>dependencies {    androidTestCompile(&apos;com.android.support.test.espresso:espresso-core:3.0.1&apos;, {        exclude group: &apos;com.android.support&apos;, module: &apos;support-annotations&apos;        //不导入依赖中的support-annotations，避免出现依赖冲突，会使用用户自己导入的包    })}</code></pre><p>其余诸如runner，rules包都被core依赖，会自动导入，没有必要手动导入，以免导入版本不正确引起其他问题，除了上面描述的相关库，Espresso还依赖了JUnit和Hamcrest等其他测试辅助框架。</p><h3 id="EspressoUI测试的重要对象"><a href="#EspressoUI测试的重要对象" class="headerlink" title="EspressoUI测试的重要对象"></a>EspressoUI测试的重要对象</h3><ul><li><strong><a href="https://developer.android.com/reference/android/support/test/espresso/Espresso.html" target="_blank" rel="noopener"><code>Espresso</code></a></strong> Espresso框架的入口类，提供了一些静态方法，便于开始整个测试代码，它提供了类似onView和onData这种方法获取一个可交互的对象ViewInteraction，或者直接进行一个例如页面返回的顶层操作。</li><li><strong><a href="https://developer.android.com/reference/android/support/test/espresso/matcher/ViewMatchers.html" target="_blank" rel="noopener"><code>ViewMatchers</code></a></strong> 定义了一系列静态方法用于根据不同条件返回Matcher&lt;? super View&gt;对象，作为参数传递给onView()。</li><li><strong><a href="https://developer.android.com/reference/android/support/test/espresso/action/ViewActions.html" target="_blank" rel="noopener"><code>ViewActions</code></a></strong> view的操作行为例如click()，最为ViewInteraction.perform()的参数用于对指定View的进行对应操作。</li><li><strong><a href="https://developer.android.com/reference/android/support/test/espresso/assertion/ViewAssertions.html" target="_blank" rel="noopener"><code>ViewAssertions</code></a></strong> 作为ViewInteraction.check()的参数，判断view的输出是否正确</li><li><strong><a href="https://developer.android.com/reference/android/support/test/rule/ActivityTestRule.html" target="_blank" rel="noopener"><code>ActivityTestRule</code></a></strong> 提供了测试单个Activity的功能，当它的launchActivity设置为true时，它会在每个使用<code>@Test</code>注释的方法前和所有注释者<code>@Before</code>的方法前启动。同时可以通过ActivityTestRule对象获取对应Activity的对象。</li></ul><p>一个简单的代码示例如下：</p><pre><code>@RunWith(AndroidJUnit4.class)public class LoginTest {    @Rule    public ActivityTestRule&lt;LoginActivity&gt; mActivityRule =            new ActivityTestRule(LoginActivity.class);    @Test    public void login() throws Exception {        onView(withId(R.id.et_login_number)).perform(click(),replaceText(&quot;17720380994&quot;),closeSoftKeyboard());        onView(withId(R.id.btn_login_next)).perform(click());        onView(withId(R.id.et_password)).perform(click(),replaceText(&quot;aa123456&quot;),closeSoftKeyboard());        onView(withId(R.id.btn_login)).perform(click());        onView(withId(R.id.toolbar)).check(matches(isDisplayed()));        onView(allOf(instanceOf(ImageButton.class),withParent(withId(R.id.toolbar)),isDisplayed())).perform(click());        onView(withId(R.id.tv_phone_number)).check(matches(withText(&quot;17720380994&quot;)));        onView(IsInstanceOf.&lt;View&gt;instanceOf(ScrollView.class)).perform(swipeUp());        onView(withId(R.id.tv_exit)).perform(click());        onView(withText(R.string.exit_login_confirm)).check(matches(isDisplayed()));        onView(withId(R.id.tv_ok)).perform(click());        onView(withId(R.id.et_login_number)).check(matches(isDisplayed()));    }}</code></pre><p>总体来说UI测试的过程就是：<strong>找到某个元素，做一些操作，检查结果</strong>。</p><h3 id="寻找View"><a href="#寻找View" class="headerlink" title="寻找View"></a>寻找View</h3><p>Espresso中定位View主要有两种，通过页面显示的View特征（onView）和通过数据内容（onData），其中onView用于普通场景，onData用于adapterView这种可能没有渲染的view，但是两者都是基于hamcrest的matcher来进行，本质是相同的不同的是匹配规则</p><h4 id="ViewMathcer"><a href="#ViewMathcer" class="headerlink" title="ViewMathcer"></a>ViewMathcer</h4><p><code>ViewMathcer</code>实质上提供了很多Matcher对象，主要用于配合OnView匹配控件，这些Matcher同时可以配合hamcrest中的matcher一起使用，效果更好。常用的Matcher如下</p><ul><li><code>withId()</code> <code>onView(withId(R.id.tv_ok))</code><br>直接通过id定位指定的的View，简单粗暴，但是非常实用。</li><li><code>isAssignableFrom()</code> <code>onView(isAssignableFrom(ScrollView.class))</code>通过对象类型判断</li><li><code>isDisplayed()</code>  <code>onView(allOf(isDisplayed(),isAssignableFrom(ScrollView.class)))</code> 通过是否显示判断，通常和其他matcher配合(<code>allOf</code>是hamcrest库重的方法，用于匹配多个matcher，类似的还有<code>anyOf</code>)</li><li><code>isEnabled()</code></li><li><code>isFocusable()</code><br>……</li></ul><p><code>ViewMathcer</code>中几乎把所有的View属性都定义了对应的matcher，需要的可以自行查阅源码或文档。</p><h4 id="DataInteraction"><a href="#DataInteraction" class="headerlink" title="DataInteraction"></a>DataInteraction</h4><p><code>DataInteraction</code> 是onData方法的返回值，因为onData方法匹配出的不直接就是View，它匹配的是一个数据集合，只有我们想要进行具体的View操作时，Espresso才会把它转化为View。<br>​<br>     onData(instanceOf(Account.class))<br>Espresso没有为<code>onData</code>定义Matcher，基本都是使用hamcrest中定义的matcher或者自定义matcher</p><h5 id="自定义Matcher"><a href="#自定义Matcher" class="headerlink" title="自定义Matcher"></a>自定义Matcher</h5><p>一般自定义Matcher都继承<code>TypeSafeMatcher</code>，需要实现的方法如下</p><pre><code>public class CallInfoMatcher extends TypeSafeMatcher&lt;CallInfo&gt; {    @Override    public void describeTo(Description description) {        //匹配失败时的描述，用于描述具体的匹配失败信息    }    @Override    protected boolean matchesSafely(CallInfo item) {        //具体的匹配过程        return false;    }}</code></pre><h3 id="对View的操作"><a href="#对View的操作" class="headerlink" title="对View的操作"></a>对View的操作</h3><p>View的操作都是在<code>ViewInteraction</code>上进行的。<code>ViewInteraction</code>也就是<code>onView</code>的返回值对象，用于对于具体的View进行操作（<code>DataInteraction</code>的操作也是转换为ViewInteraction后进行的），<code>ViewInteraction</code>提供了如下方法来对相应的元素做操作：</p><pre><code>public ViewInteraction perform(final ViewAction... viewActions) {}</code></pre><p>具体的操作通过<code>ViewAction</code>定义，连续操作可以链式调用或者作为参数顺序排列。</p><h4 id="ViewAction"><a href="#ViewAction" class="headerlink" title="ViewAction"></a>ViewAction</h4><p><code>ViewAction</code>是espresso中定义的针对View操作的接口类型。<code>ViewAction</code>中实现主要在ViewActions类中通过静态方法提供。常见的action如下</p><ul><li><code>click()</code></li><li><code>closeSoftKeyboard()</code></li><li><code>replaceText()</code><br>……</li></ul><p>除去ViewActions提供的较为通用的操作方法，Espresso还提供了很多ViewAction的子类用于完成不同View的特定操作。     </p><blockquote><p>ViewAction是在View匹配成功的基础上进行的匹配失败或者匹配不唯一都会导致测试不通过，同时Action与View类型不匹配也会失败</p></blockquote><h3 id="校验结果"><a href="#校验结果" class="headerlink" title="校验结果"></a>校验结果</h3><p>测试最重要的一步就是校验结果的正确性，<code>ViewInteraction</code>提供了<code>check()</code>方法用于校验正确性</p><pre><code>public ViewInteraction check(final ViewAssertion viewAssert) {    ......}</code></pre><p>和<code>perform()</code>方法类似，<code>check()</code>也是可以链式调用多次校验。</p><h4 id="ViewAssertion"><a href="#ViewAssertion" class="headerlink" title="ViewAssertion"></a>ViewAssertion</h4><p><code>ViewAssertion</code>是espresso中定义的用于校验View状态的接口类型，同样<code>ViewAssertion</code>也主要由<code>ViewAssertions</code>中的静态方法提供。其中主要使用的就是<code>matches()</code>方法</p><pre><code>public static ViewAssertion matches(final Matcher&lt;? super View&gt; viewMatcher) {    return new MatchesViewAssertion(checkNotNull(viewMatcher));}</code></pre><p>其中参数viewMatcher就是前面用于匹配View的<code>ViewMatcher</code>。</p><h3 id="异步问题"><a href="#异步问题" class="headerlink" title="异步问题"></a>异步问题</h3><p>Espresso提供了大量的同步机制，这些机制主要针对于主线层的MQ，但是Espresso对于其他的异步操作是无感知的，如果View的显示依赖于网络数据，很有可能就会导致测试用例不通过，因此需要使用前面使用的<code>espresso-idling-resource</code>来保证Espresso在异步线程的可靠性。</p><p><code>espresso-idling-resource</code>依赖添加如下</p><pre><code>compile(&quot;com.android.support.test.espresso:espresso-idling-resource:3.0.1&quot;) {    exclude module: &apos;support-annotations&apos;}androidTestCompile(&quot;com.android.support.test.espresso:espresso-idling-resource:3.0.1&quot;) {    exclude module: &apos;support-annotations&apos;}//由于Espresso对与异步线程无感知，我们需要在代码中主动使用IdlingResource，因此需要使用compile依赖。</code></pre><h3 id="IdlingResource"><a href="#IdlingResource" class="headerlink" title="IdlingResource"></a>IdlingResource</h3><p>Espresso主要通过<code>IdlingResource</code>这个接口类型完成对异步资源的感知，主要方法如下</p><pre><code>public interface IdlingResource {    //用于标识对于的异步资源    public String getName();    //返回目前资源是否可用(闲置)，    public boolean isIdleNow();    //Espresso会注册此回掉，需要判断资源可用时主动调用    public void registerIdleTransitionCallback(ResourceCallback callback);    public interface ResourceCallback {        public void onTransitionToIdle();    }}</code></pre><p>Espresso提供了几个<code>IdlingResource</code>的实现类，可以直接使用：</p><ul><li><a href="https://developer.android.com/reference/android/support/test/espresso/idling/CountingIdlingResource.html" target="_blank" rel="noopener">CountingIdlingResource</a> 为资源提供了一个简单的使用计数，当count为0时资源为闲置状态。</li><li><a href="https://developer.android.com/reference/android/support/test/espresso/idling/net/UriIdlingResource.html" target="_blank" rel="noopener">UriIdlingResource</a> 类似<code>CountingIdlingResource</code>,但是count为0时资源不会立即为闲置状态。</li><li><a href="https://developer.android.com/reference/android/support/test/espresso/idling/concurrent/IdlingThreadPoolExecutor.html" target="_blank" rel="noopener">IdlingThreadPoolExecutor</a>  一个有<code>IdlingResource</code>功能的<code>ThreadPoolExecutor</code>。</li><li><a href="https://developer.android.com/reference/android/support/test/espresso/idling/concurrent/IdlingScheduledThreadPoolExecutor.html" target="_blank" rel="noopener">IdlingScheduledThreadPoolExecutor</a> em.. 同上</li></ul><p>我们借<code>CountingIdlingResource</code>来了解下<code>IdlingResource</code>的主要用法，<code>CountingIdlingResource</code>主要提供的两个共有方法供我们使用</p><ul><li><code>increment()</code>计数加一</li><li><code>decrement()</code>计数减一，为0时调用<code>onTransitionToIdle()</code></li></ul><p>例如使用网络请求的场景，发起请求时<code>increment()</code>表示资源被占用，请求结束时<code>decrement()</code>，表示资源被释放。同时还需要在测试代码中注册对应资源</p><pre><code>IdlingRegistry.getInstance().register(idlingResource);</code></pre><p><code>IdlingResource</code>解决了异步代码的问题，但是依旧存在问题，我们在业务逻辑代码中创建<code>IdlingResource</code>对象，同时在需要的地方去改变它的状态，然后在测试代码中使用。这无疑是为了测试而给正常的业务代码增加了不必要的逻辑。</p><p>未完待续～</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;UI测试&quot;&gt;&lt;a href=&quot;#UI测试&quot; class=&quot;headerlink&quot; title=&quot;UI测试&quot;&gt;&lt;/a&gt;UI测试&lt;/h2&gt;&lt;p&gt;UI 测试是为了确保对于用户的UI动作，app能返回正确的UI输出。根据实际实现方案大体可以分为两种：&lt;/p&gt;
&lt;ul&gt;
&lt;
      
    
    </summary>
    
    
      <category term="Android，Test" scheme="http://haojen.github.io/tags/Android%EF%BC%8CTest/"/>
    
  </entry>
  
</feed>
