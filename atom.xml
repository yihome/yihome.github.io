<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>yihome</title>
  <icon>https://www.gravatar.com/avatar/1dbd1d499c3a70d9e39ff8ab1bc714a3</icon>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://haojen.github.io/"/>
  <updated>2019-11-11T06:34:07.383Z</updated>
  <id>http://haojen.github.io/</id>
  
  <author>
    <name>houyi</name>
    <email>yihome926@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>记一次网络请求全过程</title>
    <link href="http://haojen.github.io/2019/10/27/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E5%85%A8%E8%BF%87%E7%A8%8B/"/>
    <id>http://haojen.github.io/2019/10/27/记一次网络请求全过程/</id>
    <published>2019-10-27T09:11:28.000Z</published>
    <updated>2019-11-11T06:34:07.383Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一次网络请求"><a href="#一次网络请求" class="headerlink" title="一次网络请求"></a>一次网络请求</h2><p>目前我们的网络框架采用RxJava+Retrofit+OkHttp，使用起来非常简单，只需要简单几行代码便能完成整个网络请求</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">retrofit.create(serviceClass)</span><br><span class="line">  .getNoticeInfo(CommonConstant.COURSE_TYPE_FACE)</span><br><span class="line">.subscribeOn(Schedulers.io())</span><br><span class="line">    .unsubscribeOn(Schedulers.io())</span><br><span class="line">    .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">  .subscribe(<span class="keyword">new</span> BJYNetObserver&lt;JsonObject&gt;() &#123;</span><br><span class="line">          ......</span><br><span class="line">     &#125;);</span><br></pre></td></tr></table></figure><p>这些高度封装的第三方库内部却不是这么简单，我们就跟随一条简单的网络一起探索一下这个全过程。</p><h2 id="Retrofit"><a href="#Retrofit" class="headerlink" title="Retrofit"></a>Retrofit</h2><p>网络请求的开始从Retrofit开始，Retrofit的核心是动态代理，通过注解和返回值来创建Restful的网络请求。所以Retrofit的核心代码不算太多，从我们通过create创建了网络请求的代理类开始</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">create</span><span class="params">(<span class="keyword">final</span> Class&lt;T&gt; service)</span> </span>&#123;</span><br><span class="line">   Utils.validateServiceInterface(service);</span><br><span class="line">   <span class="keyword">if</span> (validateEagerly) &#123;</span><br><span class="line">     eagerlyValidateMethods(service);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//创建接口的代理对象</span></span><br><span class="line">   <span class="keyword">return</span> (T) Proxy.newProxyInstance(service.getClassLoader(), <span class="keyword">new</span> Class&lt;?&gt;[] &#123; service &#125;,</span><br><span class="line">       <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">         <span class="keyword">private</span> <span class="keyword">final</span> Platform platform = Platform.get();</span><br><span class="line">         <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object... args)</span></span></span><br><span class="line"><span class="function">             <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">           ......</span><br><span class="line">           <span class="comment">//解析接口方法，根据方法参数、返回值和注解生成需要的参数</span></span><br><span class="line">           ServiceMethod serviceMethod = loadServiceMethod(method);</span><br><span class="line">           OkHttpCall okHttpCall = <span class="keyword">new</span> OkHttpCall&lt;&gt;(serviceMethod, args);</span><br><span class="line">           <span class="keyword">return</span> serviceMethod.callAdapter.adapt(okHttpCall);</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>在loadServiceMethod中有大量逻辑都是处理Retrofit的注解生成相应网络请求Request的过程（这个不是本文的重点），同时还会获得两个比较重要的对象 <code>CallAdapter</code> 和 <code>Converter</code> ,这两个对象都是用于在请求过程中对于网络请求的结果进行转换，但是两者的作用不同</p><ul><li><p><code>Converter</code> 主要用于值转换，可以自定义将原始的ResponseBody转换成String或者其他对象，一般用于Gson解析</p></li><li><p><code>CallAdapter</code> 用于将Call转换成其他对象，Call对象本身是一个接口，Retrofit的主要实现类是OkHttpCall，这个是OkHttp中RealCall的封装类</p></li></ul><p>这个两个对象在实际流程中的关系如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ResponseBody -&gt; Converter -&gt; T</span><br><span class="line">Call&lt;T&gt; -&gt; CallAdapter -&gt; Other</span><br></pre></td></tr></table></figure><p><code>ResponseBody</code> 经过 <code>Converter</code> 转换后的类型回作为Call对象范型类型，然后通过 <code>CallAdapter</code> 转换成其他类型。</p><p>这两个对象都是通过抽象工厂模式来创建，我们可以添加抽象工厂来自定义这两个对象，<code>Converter</code> 和<code>CallAdapter</code> 中具体工厂都是根据他们的返回值类型来确定的，首先确定是 <code>CallAdapter</code> 的工厂，然后根据 <code>CallAdapter.adapt</code>  方法的入参Call的范型类型确定 <code>Converter</code></p><p>##OkHttp</p><p><code>OkHttpClient</code> 的创建和<code>RealCall</code> 的创建过程就不多做介绍了，我们从RealCall的<code>execute</code> 和 <code>enqueue</code> 两个方法开始。</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  ......</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      client.dispatcher().executed(<span class="keyword">this</span>);<span class="comment">//1</span></span><br><span class="line">      Response result = getResponseWithInterceptorChain();<span class="comment">//2</span></span><br><span class="line">      <span class="keyword">if</span> (result == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>);</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      client.dispatcher().finished(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Callback responseCallback)</span> </span>&#123;</span><br><span class="line">  ......</span><br><span class="line">  client.dispatcher().enqueue(<span class="keyword">new</span> AsyncCall(responseCallback));<span class="comment">//3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这两个方法一个是同步请求，一个是异步请求，但是在1和3处都使用到了 <code>Dispatcher</code> 这个对象，同时同步请求回在2处直接调用 <code>getResponseWithInterceptorChain</code> 执行请求，我们先看一下 <code>Dispatcher</code> 这个对象的几个重要成员。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** Executes calls. Created lazily. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="meta">@Nullable</span> ExecutorService executorService;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Ready async calls in the order they'll be run. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;AsyncCall&gt; readyAsyncCalls = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Running asynchronous calls. Includes canceled calls that haven't finished yet. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;AsyncCall&gt; runningAsyncCalls = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Running synchronous calls. Includes canceled calls that haven't finished yet. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;RealCall&gt; runningSyncCalls = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br></pre></td></tr></table></figure><p>可以看到 <code>Dispatcher</code> 中有三个队列以及一个 <code>Executor</code> ，而这个 <code>Executor</code> 事实上是一个线程池,从变量命名上看 <code>Dispatcher</code> 的实现已经很明显了</p><ul><li>一个异步请求的等待队列</li><li>一个异步请求的执行队列</li><li>一个同步请求的执行队列</li><li>一个异步请求的线程池</li></ul><p>在前面的代码中我看到在执行异步请求时会把 <code>RealCall</code> 封装在 <code>AsyncCall</code> 内，我们看一下 <code>AsyncCall</code> 的execute方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">boolean</span> signalledCallback = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    Response response = getResponseWithInterceptorChain();</span><br><span class="line">    <span class="keyword">if</span> (retryAndFollowUpInterceptor.isCanceled()) &#123;</span><br><span class="line">      signalledCallback = <span class="keyword">true</span>;</span><br><span class="line">      responseCallback.onFailure(RealCall.<span class="keyword">this</span>, <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      signalledCallback = <span class="keyword">true</span>;</span><br><span class="line">      responseCallback.onResponse(RealCall.<span class="keyword">this</span>, response);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    ......</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    client.dispatcher().finished(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到异步请求最终也是调用了 <code>getResponseWithInterceptorChain</code> 方法来执行最终的请求，OkHttp可以分为两段，而这个方法是下半段的开始，也是OkHttp请求的核心。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Response <span class="title">getResponseWithInterceptorChain</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">   <span class="comment">// Build a full stack of interceptors.</span></span><br><span class="line">   List&lt;Interceptor&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">   interceptors.addAll(client.interceptors());</span><br><span class="line">   interceptors.add(retryAndFollowUpInterceptor);</span><br><span class="line">   interceptors.add(<span class="keyword">new</span> BridgeInterceptor(client.cookieJar()));</span><br><span class="line">   interceptors.add(<span class="keyword">new</span> CacheInterceptor(client.internalCache()));</span><br><span class="line">   interceptors.add(<span class="keyword">new</span> ConnectInterceptor(client));</span><br><span class="line">   <span class="keyword">if</span> (!forWebSocket) &#123;</span><br><span class="line">     interceptors.addAll(client.networkInterceptors());</span><br><span class="line">   &#125;</span><br><span class="line">   interceptors.add(<span class="keyword">new</span> CallServerInterceptor(forWebSocket));</span><br><span class="line"></span><br><span class="line">   Interceptor.Chain chain = <span class="keyword">new</span> RealInterceptorChain(</span><br><span class="line">       interceptors, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">0</span>, originalRequest);</span><br><span class="line">   <span class="keyword">return</span> chain.proceed(originalRequest);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>在OkHttp中使用拦截器链来进行网络请求，且内置了五个拦截器，在查看这五个拦截器之前，我们先看一下拦截器链的结构</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//RealInterceptorChain.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">proceed</span><span class="params">(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec, RealConnection connection)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= interceptors.size()) <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</span><br><span class="line"></span><br><span class="line">    calls++;</span><br><span class="line">......</span><br><span class="line">    <span class="comment">// Call the next interceptor in the chain.</span></span><br><span class="line">    RealInterceptorChain next = <span class="keyword">new</span> RealInterceptorChain(</span><br><span class="line">        interceptors, streamAllocation, httpCodec, connection, index + <span class="number">1</span>, request);</span><br><span class="line">    Interceptor interceptor = interceptors.get(index);</span><br><span class="line">    Response response = interceptor.intercept(next);</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>可以看到 <code>RealInterceptorChain</code> 每执行一个拦截器都会创建一个新的 <code>RealInterceptorChain</code> 对象，同时通过index控制目前使用的拦截器，并调用拦截器的 <code>intercept</code> 方法。</p><h3 id="RetryAndFollowUpInterceptor"><a href="#RetryAndFollowUpInterceptor" class="headerlink" title="RetryAndFollowUpInterceptor"></a>RetryAndFollowUpInterceptor</h3><p>在这个拦截器内主要做了两件事</p><ul><li>创建了StreamAllocation对象，这个对象在后面再详细介绍</li><li>根据网络请求的相应错误码比如301、408，进行重试</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Request request = chain.request();</span><br><span class="line"></span><br><span class="line"> .....</span><br><span class="line">    <span class="keyword">int</span> followUpCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">      .....</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        response = ((RealInterceptorChain) chain).proceed(request, streamAllocation, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        releaseConnection = <span class="keyword">false</span>;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (RouteException e) &#123; </span><br><span class="line">        ......</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        ......</span><br><span class="line">      &#125;</span><br><span class="line">      ......</span><br><span class="line">      <span class="comment">//根据相应码获取下一次请求的Request</span></span><br><span class="line">      Request followUp = followUpRequest(response);</span><br><span class="line">      <span class="keyword">if</span> (followUp == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!forWebSocket) &#123;</span><br><span class="line">          streamAllocation.release();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">      &#125;</span><br><span class="line">      closeQuietly(response.body());</span><br><span class="line">      <span class="keyword">if</span> (++followUpCount &gt; MAX_FOLLOW_UPS) &#123;</span><br><span class="line">        streamAllocation.release();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ProtocolException(<span class="string">"Too many follow-up requests: "</span> + followUpCount);</span><br><span class="line">      &#125;</span><br><span class="line">      ......</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="BridgeInterceptor"><a href="#BridgeInterceptor" class="headerlink" title="BridgeInterceptor"></a>BridgeInterceptor</h3><p>主要是对请求头和响应头的处理，比如添加一些<code>Content-Length</code>,<code>Content-Type</code> 等通用的请求头，同时cookie、请求体和响应体gzip压缩和解压的处理也是在这个拦截器</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//添加必要的请求头</span></span><br><span class="line">  .......</span><br><span class="line">    List&lt;Cookie&gt; cookies = cookieJar.loadForRequest(userRequest.url());</span><br><span class="line">    <span class="keyword">if</span> (!cookies.isEmpty()) &#123;</span><br><span class="line">      requestBuilder.header(<span class="string">"Cookie"</span>, cookieHeader(cookies));</span><br><span class="line">    &#125;</span><br><span class="line">  .......</span><br><span class="line">    Response networkResponse = chain.proceed(requestBuilder.build());</span><br><span class="line"></span><br><span class="line">    HttpHeaders.receiveHeaders(cookieJar, userRequest.url(), networkResponse.headers());</span><br><span class="line"></span><br><span class="line">    Response.Builder responseBuilder = networkResponse.newBuilder()</span><br><span class="line">        .request(userRequest);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (transparentGzip</span><br><span class="line">        &amp;&amp; <span class="string">"gzip"</span>.equalsIgnoreCase(networkResponse.header(<span class="string">"Content-Encoding"</span>))</span><br><span class="line">        &amp;&amp; HttpHeaders.hasBody(networkResponse)) &#123;</span><br><span class="line">      GzipSource responseBody = <span class="keyword">new</span> GzipSource(networkResponse.body().source());</span><br><span class="line">      Headers strippedHeaders = networkResponse.headers().newBuilder()</span><br><span class="line">          .removeAll(<span class="string">"Content-Encoding"</span>)</span><br><span class="line">          .removeAll(<span class="string">"Content-Length"</span>)</span><br><span class="line">          .build();</span><br><span class="line">      responseBuilder.headers(strippedHeaders);</span><br><span class="line">      String contentType = networkResponse.header(<span class="string">"Content-Type"</span>);</span><br><span class="line">      responseBuilder.body(<span class="keyword">new</span> RealResponseBody(contentType, -<span class="number">1L</span>, Okio.buffer(responseBody)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> responseBuilder.build();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这个地方第一次出现了Source，这个是OkIo中定义的对象，是IO流的封装类，后面详细介绍</p><h3 id="CacheInterceptor"><a href="#CacheInterceptor" class="headerlink" title="CacheInterceptor"></a>CacheInterceptor</h3><p><code>CacheInterceptor</code> 的意义从名称上来看来已经很明显了，但是这个Okhttp的实现可能和我们想象中的不一 样，<code>CacheInterceptor</code> 主要针对的是<code>304 HTTP_NOT_MODIFIED</code> 响应码，一般正常的网络请求都会正常进行，但是会在后台返回304时，使用本地缓存</p><p><code>CacheInterceptor</code> 主要关注什么样的请求响应需要被缓存和缓存的时常（这往往取决于Http的头部信息），具体的缓存使用 <code>DiskLruCache</code>  来实现，但是OkHttp对于 <code>DiskLruCache</code> 底层IO使用OkIO重写了，有兴趣的可以自行研究</p><p>Okhttp中前三个拦截器都是相对比较容易理解的，但是从第四个拦截器开始，负责度就开始提升了，这个原因主要有两个</p><ul><li>从第四个拦截器开始，OkIO的相关代码开始大量出现，提高了代码复杂度</li><li>OkHttp实现了Http2.0协议，从这里开始有很多Http2.0的实现代码（这个也是OkHttp相较于早期其他比如HttpClient和HttpUrlConnection网络请求框架一个巨大的提升，不过目前HttpUrlConnection底层已经替换为OkHttp了）</li></ul><h3 id="Okio"><a href="#Okio" class="headerlink" title="Okio"></a>Okio</h3><p><code>Okio</code> 是对于JavaIO的一次封装，主要整合了家族庞大的JavaIO，使用统一的Sink(相当于OutputStream)和Source(相当于InputStream)来处理各种不同类型的输入和输出，同时提供Buffer缓存机制。</p><blockquote><p>这个为了OkHttp整体流程的连贯性，作为OkHttp的一节，但是OkIO是一个独立的框架，我们完全可以使用把它用于各种的IO场景中。</p></blockquote><h4 id="Buffer缓存机制"><a href="#Buffer缓存机制" class="headerlink" title="Buffer缓存机制"></a>Buffer缓存机制</h4><p>整个Buffer缓存机制主要有三个对象组成</p><ul><li>Segment Buffer缓存的最小单位</li><li>Buffer 由Segment组成的双向链表，使用链表结构可以大量避免 <code>System.arraycopy</code></li><li>SegmentPool  Segment缓存池，回收复用Segment内存，避免内存分配的消耗</li></ul><h5 id="Segment"><a href="#Segment" class="headerlink" title="Segment"></a>Segment</h5><p><code>Segment</code> 本质上就是一个定长的字节数组，包括一个指向数据头部的指针，一个指向数据尾部的指针，同时定义了一些在这个结构上的方法，比如<code>split</code> 、 <code>compact</code> 、<code>writeTo</code> </p><h5 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h5><p><code>Buffer</code> 同时实现了<code>BufferedSink</code> 和 <code>BufferedSource</code> ，也就是说<code>Buffer</code> 既可以作为输入流从中获取数据，也可以作为输出流向外输出数据，本质上它就是一个缓冲区，同时它内部使用<code>Segment</code> 的双向链表来存储数量，使得在 <code>Buffer</code> 间传递数据时可以直接通过修改<code>Segment</code> 的链表指针来完成，大量减少了 <code>System.arraycopy</code> 的消耗，我们可以通过几个代表性的方法来了解一下 <code>Buffer</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">将Buffer写入到输出流</span><br><span class="line"><span class="function"><span class="keyword">public</span> Buffer <span class="title">writeTo</span><span class="params">(OutputStream out, <span class="keyword">long</span> byteCount)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (out == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"out == null"</span>);</span><br><span class="line">  checkOffsetAndCount(size, <span class="number">0</span>, byteCount);</span><br><span class="line"></span><br><span class="line">  Segment s = head;</span><br><span class="line">  <span class="keyword">while</span> (byteCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> toCopy = (<span class="keyword">int</span>) Math.min(byteCount, s.limit - s.pos);</span><br><span class="line">    out.write(s.data, s.pos, toCopy);</span><br><span class="line"></span><br><span class="line">    s.pos += toCopy;</span><br><span class="line">    size -= toCopy;</span><br><span class="line">    byteCount -= toCopy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s.pos == s.limit) &#123;</span><br><span class="line">      Segment toRecycle = s;</span><br><span class="line">      head = s = toRecycle.pop();</span><br><span class="line">      SegmentPool.recycle(toRecycle);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到将 <code>Buffer</code> 写入到<code>OutputStream</code> 时，事实上就是将每一个 <code>Segment</code> 的内容写入到 <code>OutputStream</code> 中，同理将其他数据写入 <code>Buffer</code> 时也是类似的，就是将数据写入到 <code>Segment</code> 中。</p><p>在 <code>Buffer</code> 中提供了很多中不同的读和写的方法，同时还提供了内置的加密方式。</p><h5 id="SegmentPool"><a href="#SegmentPool" class="headerlink" title="SegmentPool"></a>SegmentPool</h5><p>由 <code>Segment</code> 组成的单链表缓存区，对外提供两个静态方法<code>take</code> ，<code>recycle</code> 用于回收和获取 <code>Segment</code> 。</p><h4 id="Okio的家族体系"><a href="#Okio的家族体系" class="headerlink" title="Okio的家族体系"></a>Okio的家族体系</h4><p><img src="./记一次网络请求全过程/okio.png" alt="OkIO家族" style="zoom:50%;" align="left"></p><p><code>Okio</code> 中的主要对象只有上面几个，其中的缓存都以Buffer为核心，除了上述几个对象外还有很多其他是以内部类的形式存在的 <code>Sink</code> 和 <code>Buffer</code> ，例如在 <code>Okio</code> 这个入口类中提供了很多 <code>sink</code> 和 <code>Buffer</code> 的方法用于将<code>Okio</code> 对接到传统IO上，这个实现也是通过创建 <code>Sink</code> 和 <code>Buffer</code> 的内部类来完成的</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Source <span class="title">source</span><span class="params">(<span class="keyword">final</span> InputStream in, <span class="keyword">final</span> Timeout timeout)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (in == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"in == null"</span>);</span><br><span class="line">  <span class="keyword">if</span> (timeout == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"timeout == null"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Source() &#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">read</span><span class="params">(Buffer sink, <span class="keyword">long</span> byteCount)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (byteCount &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"byteCount &lt; 0: "</span> + byteCount);</span><br><span class="line">      <span class="keyword">if</span> (byteCount == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        timeout.throwIfReached();</span><br><span class="line">        Segment tail = sink.writableSegment(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> maxToCopy = (<span class="keyword">int</span>) Math.min(byteCount, Segment.SIZE - tail.limit);</span><br><span class="line">        <span class="keyword">int</span> bytesRead = in.read(tail.data, tail.limit, maxToCopy);</span><br><span class="line">        <span class="keyword">if</span> (bytesRead == -<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        tail.limit += bytesRead;</span><br><span class="line">        sink.size += bytesRead;</span><br><span class="line">        <span class="keyword">return</span> bytesRead;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (AssertionError e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isAndroidGetsocknameError(e)) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(e);</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      in.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Timeout <span class="title">timeout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> timeout;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"source("</span> + in + <span class="string">")"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Http2-0"><a href="#Http2-0" class="headerlink" title="Http2.0"></a>Http2.0</h3><p>http2.0协议标准于2015年5月以<a href="https://tools.ietf.org/html/rfc7540" target="_blank" rel="noopener">RFC 7540</a>正式发表, 在介绍http2.0之前我们先看下http协议的发展的几个阶段</p><ul><li>http/1.x 一次只允许在一个TCP连接上发起一个请求，单向，只能由客户端发起，数据未压缩</li><li>SPDY 支持多路复用（Tcp连接复用），header压缩，强制使用https加密传输，服务端推送</li><li>http/2.0 支持明文和加密传输，优化了header压缩算法，支持SDPY现有功能</li><li>Quic 基于UDP的稳定传输协议</li></ul><h4 id="Http2-0连接过程"><a href="#Http2-0连接过程" class="headerlink" title="Http2.0连接过程"></a>Http2.0连接过程</h4><p>HTTP/2协议在TCP连接之初进行协商通信，只有协商成功，才会涉及到后续的请求-响应等具体的业务型数据交换。</p><p>Http2.0明文连接的主要过程如下:</p><ol><li><p>客户端发起请求，只有请求报头，携带<code>Upgrade</code> 相关头部信息，用于试探服务器是否支持Http2.0</p><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">GET / HTTP/1. 1</span><br><span class="line"><span class="attribute">Host</span>: server. example. com</span><br><span class="line"><span class="attribute">Connection</span>: Upgrade, HTTP2-Settings</span><br><span class="line"><span class="attribute">Upgrade</span>: h2c</span><br><span class="line"><span class="attribute">HTTP2-Settings</span>: &lt;base64url encoding of HTTP/2 SETTINGS payload&gt;</span><br></pre></td></tr></table></figure></li><li><p>服务器支持HTTP/2，则通知客户端切换到HTTP/2</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">HTTP/1. 1 <span class="number">101</span> Switching Protocols</span><br><span class="line"><span class="attribute">Connection</span>: Upgrade</span><br><span class="line"><span class="attribute">Upgrade</span>: h2c</span><br><span class="line"></span><br><span class="line">[ HTTP/2 connection . . .</span><br></pre></td></tr></table></figure></li><li><p>101响应空行之后，服务器必须发送的第一个帧为SETTINGS帧（其负载可能为空）作为连接序言</p></li><li><p>客户端接收到101响应后，也必须发送一个序言作为响应，其逻辑结构如下</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n // 纯字符串表示，翻译成字节数为24个字节</span><br><span class="line">SETTINGS帧                       // 其负载可能为空</span><br></pre></td></tr></table></figure><p>服务器端和客户端所发送的连接序言有所不同。</p></li><li><p>客户端可以马上发送请求帧或其它帧过去，不用等待来自服务器端的SETTINGS帧</p></li><li><p>任一端接收到SETTINGS帧之后，都需要返回一个包含确认标志位SETTIGN作为确认</p></li><li><p>其它帧的正常传输</p></li></ol><p>其他连接建立过程大家可以自行查阅。</p><h4 id="HTTP-2-帧"><a href="#HTTP-2-帧" class="headerlink" title="HTTP/2 帧"></a>HTTP/2 帧</h4><p>HTTP/2下终端之间使用帧的数据形式进行数据交换，一个标准的帧的格式如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+-----------------------------------------------+</span><br><span class="line">|                 Length (24)                   |</span><br><span class="line">+---------------+---------------+---------------+</span><br><span class="line">|   Type (8)    |   Flags (8)   |</span><br><span class="line">+-+-------------+---------------+-------------------------------+</span><br><span class="line">|R|                 Stream Identifier (31)                      |</span><br><span class="line">+=+=============================================================+</span><br><span class="line">|                   Frame Payload (0...)                      ...</span><br><span class="line">+---------------------------------------------------------------+</span><br></pre></td></tr></table></figure><p>HTTP/2下有多种类型的帧，帧的类型由Type指定，具体类型下的一些标志位由Flags指定，我们上文提到的SETTINGS帧则是HTTP/2所支持的帧的一种。对HTTP/2有兴趣的可以查阅<a href="https://tools.ietf.org/html/rfc7540" target="_blank" rel="noopener">RFC 7540</a> 以及相关技术文档</p><h3 id="ConnectInterceptor"><a href="#ConnectInterceptor" class="headerlink" title="ConnectInterceptor"></a>ConnectInterceptor</h3><p><code>ConnectInterceptor</code> 主要用于创建和复用TCP连接，拦截器中的主要代码就一行</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HttpCodec httpCodec = streamAllocation.newStream(client, chain, doExtensiveHealthChecks);</span><br></pre></td></tr></table></figure><p>最终的核心代码在 <code>StreamAllocation</code> 中</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> RealConnection <span class="title">findConnection</span><span class="params">(<span class="keyword">int</span> connectTimeout, <span class="keyword">int</span> readTimeout, <span class="keyword">int</span> writeTimeout,</span></span></span><br><span class="line"><span class="function"><span class="params">     <span class="keyword">int</span> pingIntervalMillis, <span class="keyword">boolean</span> connectionRetryEnabled)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="keyword">boolean</span> foundPooledConnection = <span class="keyword">false</span>;</span><br><span class="line"> ......</span><br><span class="line">  <span class="keyword">synchronized</span> (connectionPool) &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// Attempt to get a connection from the pool.</span></span><br><span class="line">      Internal.instance.get(connectionPool, address, <span class="keyword">this</span>, <span class="keyword">null</span>);<span class="comment">//1</span></span><br><span class="line">      <span class="keyword">if</span> (connection != <span class="keyword">null</span>) &#123;</span><br><span class="line">        foundPooledConnection = <span class="keyword">true</span>;</span><br><span class="line">        result = connection;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        selectedRoute = route;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ......</span><br><span class="line">  <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// If we found an already-allocated or pooled connection, we're done.</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If we need a route selection, make one. This is a blocking operation.</span></span><br><span class="line">  <span class="keyword">boolean</span> newRouteSelection = <span class="keyword">false</span>;</span><br><span class="line">   <span class="keyword">if</span> (selectedRoute == <span class="keyword">null</span> &amp;&amp; (routeSelection == <span class="keyword">null</span> || !routeSelection.hasNext())) &#123;</span><br><span class="line">     newRouteSelection = <span class="keyword">true</span>;</span><br><span class="line">     routeSelection = routeSelector.next();<span class="comment">//2</span></span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">synchronized</span> (connectionPool) &#123;</span><br><span class="line">    <span class="keyword">if</span> (canceled) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (newRouteSelection) &#123;</span><br><span class="line">      <span class="comment">// Now that we have a set of IP addresses, make another attempt at getting a connection from</span></span><br><span class="line">      <span class="comment">// the pool. This could match due to connection coalescing.</span></span><br><span class="line">      List&lt;Route&gt; routes = routeSelection.getAll();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = routes.size(); i &lt; size; i++) &#123;</span><br><span class="line">        Route route = routes.get(i);</span><br><span class="line">        Internal.instance.get(connectionPool, address, <span class="keyword">this</span>, route);<span class="comment">//3</span></span><br><span class="line">        <span class="keyword">if</span> (connection != <span class="keyword">null</span>) &#123;</span><br><span class="line">          foundPooledConnection = <span class="keyword">true</span>;</span><br><span class="line">          result = connection;</span><br><span class="line">          <span class="keyword">this</span>.route = route;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!foundPooledConnection) &#123;</span><br><span class="line">      <span class="keyword">if</span> (selectedRoute == <span class="keyword">null</span>) &#123;</span><br><span class="line">        selectedRoute = routeSelection.next();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Create a connection and assign it to this allocation immediately. This makes it possible</span></span><br><span class="line">      <span class="comment">// for an asynchronous cancel() to interrupt the handshake we're about to do.</span></span><br><span class="line">      route = selectedRoute;</span><br><span class="line">      refusedStreamCount = <span class="number">0</span>;</span><br><span class="line">      result = <span class="keyword">new</span> RealConnection(connectionPool, selectedRoute);<span class="comment">//4</span></span><br><span class="line">      acquire(result, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If we found a pooled connection on the 2nd time around, we're done.</span></span><br><span class="line">  <span class="keyword">if</span> (foundPooledConnection) &#123;</span><br><span class="line">    eventListener.connectionAcquired(call, result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Do TCP + TLS handshakes. This is a blocking operation.</span></span><br><span class="line">  result.connect(connectTimeout, readTimeout, writeTimeout, pingIntervalMillis,</span><br><span class="line">                 connectionRetryEnabled, call, eventListener);<span class="comment">//5</span></span><br><span class="line">  routeDatabase().connected(result.route());</span><br><span class="line">  ......</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取TCP连接的部分比较复杂，核心代码有5处，1和3都是尝试从 <code>ConnectionPool</code> 连接池中获取连接，4是在没有可复用的连接情况下创建了一个新的 <code>RealConnection</code> 对象，5是使用 <code>RealConnection</code> 进行网络连接，我们先看一下1和3到底有什么区别，他们最大的区别就在于第一次没有Route参数，第二次遍历了一个Route列表，传入Route参数。</p><h4 id="Route"><a href="#Route" class="headerlink" title="Route"></a>Route</h4><p><code>Route</code> 从命名上看起来很像IP层中的路由，其实不然，它可能代表了代理或者一个IP。</p><p>通常我们都是通过域名访问网络，但是事实上我们无法直接通过域名访问到服务器，首先需要通过DNS将域名解析到IP之后我们通过IP来访问资源，在 <code>OkHttp</code> 中这个过程通过DNS这个类来完成</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Dns SYSTEM = <span class="keyword">new</span> Dns() &#123;</span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> List&lt;InetAddress&gt; <span class="title">lookup</span><span class="params">(String hostname)</span> <span class="keyword">throws</span> UnknownHostException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (hostname == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> UnknownHostException(<span class="string">"hostname == null"</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> Arrays.asList(InetAddress.getAllByName(hostname));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NullPointerException e) &#123;</span><br><span class="line">      UnknownHostException unknownHostException =</span><br><span class="line">        <span class="keyword">new</span> UnknownHostException(<span class="string">"Broken system behaviour for dns lookup of "</span> + hostname);</span><br><span class="line">      unknownHostException.initCause(e);</span><br><span class="line">      <span class="keyword">throw</span> unknownHostException;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>OkHttp</code> 默认使用 <code>InetAddress</code> 来完成域名解析，这个类是java网络包下用于完成DNS解析的类，具体DNS解析过程大家有兴趣可以自行查阅。域名通过DNS解析之后会返回一个列表，因为可能域名对应了多个ip，随后这些ip会被封装成一个个<code>Route</code> 对象，这个过程由上节2处的 <code>routeSelector.next</code> 触发。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> Selection <span class="title">next</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">   ......</span><br><span class="line">   <span class="comment">// Compute the next set of routes to attempt.</span></span><br><span class="line">   List&lt;Route&gt; routes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">   <span class="keyword">while</span> (hasNextProxy()) &#123;</span><br><span class="line">     Proxy proxy = nextProxy();</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = inetSocketAddresses.size(); i &lt; size; i++) &#123;</span><br><span class="line">       Route route = <span class="keyword">new</span> Route(address, proxy, inetSocketAddresses.get(i));</span><br><span class="line">       <span class="keyword">if</span> (routeDatabase.shouldPostpone(route)) &#123;</span><br><span class="line">         postponedRoutes.add(route);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         routes.add(route);</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> .......</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> Selection(routes);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resetNextInetSocketAddress</span><span class="params">(Proxy proxy)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">   <span class="comment">// Clear the addresses. Necessary if getAllByName() below throws!</span></span><br><span class="line">   inetSocketAddresses = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"> ......</span><br><span class="line">   <span class="keyword">if</span> (proxy.type() == Proxy.Type.SOCKS) &#123;</span><br><span class="line">     inetSocketAddresses.add(InetSocketAddress.createUnresolved(socketHost, socketPort));</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="comment">// Try each address for best behavior in mixed IPv4/IPv6 environments.</span></span><br><span class="line">     List&lt;InetAddress&gt; addresses = address.dns().lookup(socketHost);</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = addresses.size(); i &lt; size; i++) &#123;</span><br><span class="line">       InetAddress inetAddress = addresses.get(i);</span><br><span class="line">       inetSocketAddresses.add(<span class="keyword">new</span> InetSocketAddress(inetAddress, socketPort));</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   nextInetSocketAddressIndex = <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>了解完Route的概念我们再回头来看  <code>ConnectionPool</code> 的get方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Nullable</span> <span class="function">RealConnection <span class="title">get</span><span class="params">(Address address, StreamAllocation streamAllocation, Route route)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">assert</span> (Thread.holdsLock(<span class="keyword">this</span>));</span><br><span class="line">  <span class="keyword">for</span> (RealConnection connection : connections) &#123;</span><br><span class="line">    <span class="keyword">if</span> (connection.isEligible(address, route)) &#123;</span><br><span class="line">      streamAllocation.acquire(connection);</span><br><span class="line">      <span class="keyword">return</span> connection;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法会遍历所有空闲的 <code>RealConnection</code> ，通过 <code>isEligible</code> 判断连接可用之后则会复用连接。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEligible</span><span class="params">(Address address, @Nullable Route route)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// If this connection is not accepting new streams, we're done.</span></span><br><span class="line">  <span class="keyword">if</span> (allocations.size() &gt;= allocationLimit || noNewStreams) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If the non-host fields of the address don't overlap, we're done.</span></span><br><span class="line">  <span class="keyword">if</span> (!Internal.instance.equalsNonHost(<span class="keyword">this</span>.route.address(), address)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If the host exactly matches, we're done: this connection can carry the address.</span></span><br><span class="line">  <span class="keyword">if</span> (address.url().host().equals(<span class="keyword">this</span>.route().address().url().host())) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">// This connection is a perfect match.</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// At this point we don't have a hostname match. But we still be able to carry the request if</span></span><br><span class="line">  <span class="comment">// our connection coalescing requirements are met. See also:</span></span><br><span class="line">  <span class="comment">// https://hpbn.co/optimizing-application-delivery/#eliminate-domain-sharding</span></span><br><span class="line">  <span class="comment">// https://daniel.haxx.se/blog/2016/08/18/http2-connection-coalescing/</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1. This connection must be HTTP/2.</span></span><br><span class="line">  <span class="keyword">if</span> (http2Connection == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. The routes must share an IP address. This requires us to have a DNS address for both</span></span><br><span class="line">  <span class="comment">// hosts, which only happens after route planning. We can't coalesce connections that use a</span></span><br><span class="line">  <span class="comment">// proxy, since proxies don't tell us the origin server's IP address.</span></span><br><span class="line">  <span class="keyword">if</span> (route == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (route.proxy().type() != Proxy.Type.DIRECT) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.route.proxy().type() != Proxy.Type.DIRECT) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>.route.socketAddress().equals(route.socketAddress())) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. This connection's server certificate's must cover the new host.</span></span><br><span class="line">  <span class="keyword">if</span> (route.address().hostnameVerifier() != OkHostnameVerifier.INSTANCE) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (!supportsUrl(address.url())) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4. Certificate pinning must match the host.</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    address.certificatePinner().check(address.url().host(), handshake().peerCertificates());</span><br><span class="line">  &#125; <span class="keyword">catch</span> (SSLPeerUnverifiedException e) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">// The caller's address can be carried by this connection.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复用连接的条件在注释写的很清楚了</p><ol><li>当前连接承载已经到了上限或者<code>noNewStreams</code> ，则无法复用</li><li>当Address中除了域名外其他信息比如协议、端口等相关信息有不相同的则无法复用</li><li>通过上述条件后，域名相同可以直接复用</li><li>域名不同情况，需要满足如下条件才能复用<ul><li>当前连接和要创建的连接代理类型均为直接连接</li><li>ip地址相同</li><li>当前连接的ssl证书必须包括新的ip</li><li><a href="https://nabla-c0d3.github.io/blog/2016/02/21/ssl-kill-switch-twitter/" target="_blank" rel="noopener">ssl-Pinner</a>验证要通过</li></ul></li></ol><p>连接复用的部分到此结束。</p><h4 id="连接过程"><a href="#连接过程" class="headerlink" title="连接过程"></a>连接过程</h4><p>当无法复用连接时，会创建新的 <code>RealConnection</code> 并开始连接过程</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> connectTimeout, <span class="keyword">int</span> readTimeout, <span class="keyword">int</span> writeTimeout,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">int</span> pingIntervalMillis, <span class="keyword">boolean</span> connectionRetryEnabled, Call call,</span></span></span><br><span class="line"><span class="function"><span class="params">                    EventListener eventListener)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//SSLFactory和传输协议的校验</span></span><br><span class="line">  .....</span><br><span class="line">  <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (route.requiresTunnel()) &#123;</span><br><span class="line">        <span class="comment">//使用ssl加密传输，但是使用了HTTP代理，需要使用隧道</span></span><br><span class="line">        ......</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        connectSocket(connectTimeout, readTimeout, call, eventListener);<span class="comment">//1</span></span><br><span class="line">      &#125;</span><br><span class="line">      establishProtocol(connectionSpecSelector, pingIntervalMillis, call, eventListener);<span class="comment">//2</span></span><br><span class="line">      eventListener.connectEnd(call, route.socketAddress(), route.proxy(), protocol);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      ......</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//根据服务器返回的settins帧确定连接最大承载量</span></span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心代码主要有两处：</p><ol><li><p>建立socket连接</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">connectSocket</span><span class="params">(<span class="keyword">int</span> connectTimeout, <span class="keyword">int</span> readTimeout, Call call,</span></span></span><br><span class="line"><span class="function"><span class="params">                           EventListener eventListener)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  Proxy proxy = route.proxy();</span><br><span class="line">  Address address = route.address();</span><br><span class="line">  rawSocket = proxy.type() == Proxy.Type.DIRECT || proxy.type() == Proxy.Type.HTTP</span><br><span class="line">    ? address.socketFactory().createSocket()</span><br><span class="line">    : <span class="keyword">new</span> Socket(proxy);</span><br><span class="line">  eventListener.connectStart(call, route.socketAddress(), proxy);</span><br><span class="line">  <span class="comment">//设置连接超时长</span></span><br><span class="line">  rawSocket.setSoTimeout(readTimeout);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//连接socket</span></span><br><span class="line">    Platform.get().connectSocket(rawSocket, route.socketAddress(), connectTimeout);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (ConnectException e) &#123;</span><br><span class="line">    ConnectException ce = <span class="keyword">new</span> ConnectException(<span class="string">"Failed to connect to "</span> + route.socketAddress());</span><br><span class="line">    ce.initCause(e);</span><br><span class="line">    <span class="keyword">throw</span> ce;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//获取输入输出流，使用Okio进行封装</span></span><br><span class="line">    source = Okio.buffer(Okio.source(rawSocket));</span><br><span class="line">    sink = Okio.buffer(Okio.sink(rawSocket));</span><br><span class="line">  &#125; <span class="keyword">catch</span> (NullPointerException npe) &#123;</span><br><span class="line">    <span class="keyword">if</span> (NPE_THROW_WITH_NULL.equals(npe.getMessage())) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IOException(npe);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>确定传输协议（HTTP/1.1或者HTTP/2）</p><p><code>establishProtocol</code> 这里会确认传输协议，具体有三种情况</p><ul><li>HTTP/1.1协议</li><li>HTTP/2明文传输(h2c)</li><li>HTTP/2加密传输(h2)</li></ul><p>如果是HTTP/1.1协议则连接建立完成，如果是HTTP/2协议，则会开始HTTP/2 的连接建立过程，如果是HTTP/2加密传输还会先开始TLS握手过程</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">connectTls</span><span class="params">(ConnectionSpecSelector connectionSpecSelector)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  Address address = route.address();</span><br><span class="line">  SSLSocketFactory sslSocketFactory = address.sslSocketFactory();</span><br><span class="line">  <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line">  SSLSocket sslSocket = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// Create the wrapper over the connected socket.</span></span><br><span class="line">    sslSocket = (SSLSocket) sslSocketFactory.createSocket(</span><br><span class="line">      rawSocket, address.url().host(), address.url().port(), <span class="keyword">true</span> <span class="comment">/* autoClose */</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Configure the socket's ciphers, TLS versions, and extensions.</span></span><br><span class="line">    ConnectionSpec connectionSpec = connectionSpecSelector.configureSecureSocket(sslSocket);</span><br><span class="line">    <span class="keyword">if</span> (connectionSpec.supportsTlsExtensions()) &#123;</span><br><span class="line">      Platform.get().configureTlsExtensions(</span><br><span class="line">        sslSocket, address.url().host(), address.protocols());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Force handshake. This can throw!</span></span><br><span class="line">    sslSocket.startHandshake();</span><br><span class="line">    <span class="comment">// block for session establishment</span></span><br><span class="line">    SSLSession sslSocketSession = sslSocket.getSession();</span><br><span class="line">    Handshake unverifiedHandshake = Handshake.get(sslSocketSession);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Verify that the socket's certificates are acceptable for the target host.</span></span><br><span class="line">    <span class="keyword">if</span> (!address.hostnameVerifier().verify(address.url().host(), sslSocketSession)) &#123;</span><br><span class="line">      X509Certificate cert = (X509Certificate) unverifiedHandshake.peerCertificates().get(<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> SSLPeerUnverifiedException(<span class="string">"Hostname "</span> + address.url().host() + <span class="string">" not verified:"</span></span><br><span class="line">             + <span class="string">"\n    certificate: "</span> + CertificatePinner.pin(cert)</span><br><span class="line">             + <span class="string">"\n    DN: "</span> + cert.getSubjectDN().getName()</span><br><span class="line">             + <span class="string">"\n    subjectAltNames: "</span> + OkHostnameVerifier.allSubjectAltNames(cert));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check that the certificate pinner is satisfied by the certificates presented.</span></span><br><span class="line">    address.certificatePinner().check(address.url().host(),</span><br><span class="line">                                      unverifiedHandshake.peerCertificates());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Success! Save the handshake and the ALPN protocol.</span></span><br><span class="line">    String maybeProtocol = connectionSpec.supportsTlsExtensions()</span><br><span class="line">      ? Platform.get().getSelectedProtocol(sslSocket)</span><br><span class="line">      : <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//ssl验证通过，使用sslSocket替代当前socket</span></span><br><span class="line">    ......</span><br><span class="line">  &#125; <span class="keyword">catch</span> (AssertionError e) &#123;</span><br><span class="line">    ......</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个握手过程可以分为如下几个步骤</p><ul><li>通过sslSocketFactory获取sslSocket，这个是使用TLS加密层封装过的socket</li><li>设置参数TSL参数</li><li>TSL握手和hostnameVerifier校验，这个是标准的TLS验证过程</li><li>ssl-pinner校验</li></ul><blockquote><p>TLS和SSL其实是两种协议，但是TLS建立在SSL3.0之上，是SSL3.0的后续版本，甚至TLS1.0在某种意义上都可以为称为SSL3.1，目前SSL协议已经基本被废弃，转而使用TLS，但是习惯上会使用TLS/SSL协议</p></blockquote><p>之后便正式开始HTTP/2的连接过程,此时会创建一个 <code>Http2Connection</code> 对象，并调用它的start方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">(<span class="keyword">boolean</span> sendConnectionPreface)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (sendConnectionPreface) &#123;</span><br><span class="line">    writer.connectionPreface();</span><br><span class="line">    writer.settings(okHttpSettings);</span><br><span class="line">    <span class="keyword">int</span> windowSize = okHttpSettings.getInitialWindowSize();</span><br><span class="line">    <span class="keyword">if</span> (windowSize != Settings.DEFAULT_INITIAL_WINDOW_SIZE) &#123;</span><br><span class="line">      writer.windowUpdate(<span class="number">0</span>, windowSize - Settings.DEFAULT_INITIAL_WINDOW_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">new</span> Thread(readerRunnable).start(); <span class="comment">// Not a daemon thread.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面在介绍HTTP/2协议在开始会发送 <code>Upgrade</code> 试探服务器是否支持HTTP/2，但上述代码中其实没有这个步骤，这个是因为此时已经确定使用 HTTP/2协议，所以省略了这个步骤，直接开始发送连接序言，而后发送SETTINS帧，同时会开启线程接受服务端的连接序言以及后续帧。</p></li></ol><h3 id="CallServerInterceptor"><a href="#CallServerInterceptor" class="headerlink" title="CallServerInterceptor"></a>CallServerInterceptor</h3><p>在理解HTTP/2和OKIO的前提下，<code>CallServerInterceptor</code> 的内容其实已经不难理解了，首先在 <code>CallServerInterceptor</code> 时，HTTP/2的连接已经完成，开始正式的数据交换</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  ......</span><br><span class="line">  <span class="comment">//写入头部信息</span></span><br><span class="line">  httpCodec.writeRequestHeaders(request);</span><br><span class="line">  realChain.eventListener().requestHeadersEnd(realChain.call(), request);</span><br><span class="line"></span><br><span class="line">  Response.Builder responseBuilder = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (HttpMethod.permitsRequestBody(request.method()) &amp;&amp; request.body() != <span class="keyword">null</span>) &#123;</span><br><span class="line">  <span class="comment">//100-continue 头部的处理，</span></span><br><span class="line">......</span><br><span class="line">    <span class="keyword">if</span> (responseBuilder == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// Write the request body if the "Expect: 100-continue" expectation was met.</span></span><br><span class="line">      realChain.eventListener().requestBodyStart(realChain.call());</span><br><span class="line">      <span class="keyword">long</span> contentLength = request.body().contentLength();</span><br><span class="line">      CountingSink requestBodyOut =</span><br><span class="line">        <span class="keyword">new</span> CountingSink(httpCodec.createRequestBody(request, contentLength));</span><br><span class="line">      BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut);</span><br><span class="line"></span><br><span class="line">      request.body().writeTo(bufferedRequestBody);</span><br><span class="line">      bufferedRequestBody.close();</span><br><span class="line">      realChain.eventListener()</span><br><span class="line">        .requestBodyEnd(realChain.call(), requestBodyOut.successfulCount);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!connection.isMultiplexed()) &#123;</span><br><span class="line">      <span class="comment">// If the "Expect: 100-continue" expectation wasn't met, prevent the HTTP/1 connection</span></span><br><span class="line">      <span class="comment">// from being reused. Otherwise we're still obligated to transmit the request body to</span></span><br><span class="line">      <span class="comment">// leave the connection in a consistent state.</span></span><br><span class="line">      streamAllocation.noNewStreams();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  httpCodec.finishRequest();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (responseBuilder == <span class="keyword">null</span>) &#123;</span><br><span class="line">    realChain.eventListener().responseHeadersStart(realChain.call());</span><br><span class="line">    responseBuilder = httpCodec.readResponseHeaders(<span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Response response = responseBuilder</span><br><span class="line">    .request(request)</span><br><span class="line">    .handshake(streamAllocation.connection().handshake())</span><br><span class="line">    .sentRequestAtMillis(sentRequestMillis)</span><br><span class="line">    .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> code = response.code();</span><br><span class="line">  <span class="comment">//非200其他错误码的处理</span></span><br><span class="line"> ......</span><br><span class="line">  <span class="keyword">if</span> (<span class="string">"close"</span>.equalsIgnoreCase(response.request().header(<span class="string">"Connection"</span>))</span><br><span class="line">      || <span class="string">"close"</span>.equalsIgnoreCase(response.header(<span class="string">"Connection"</span>))) &#123;</span><br><span class="line">    streamAllocation.noNewStreams();</span><br><span class="line">  &#125;</span><br><span class="line">  ......</span><br><span class="line">  <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个过程可以分为几个部分</p><ul><li>请求头发送</li><li>请求体的发送</li><li>响应头的读取</li><li>响应体的读取</li></ul><h4 id="Header的封装和传输"><a href="#Header的封装和传输" class="headerlink" title="Header的封装和传输"></a>Header的封装和传输</h4><p>头部的传输从 <code>httpCodec.writeRequestHeaders</code> 开始，这里针对HTTP/1.1和HTTP/2有一定的区分，HTTP/1.1会直接将头部信息写入<code>Sink</code> ，也就是Okio的输出流中，对于HTTP/2中这个行为将有所不同，在HTTP/2会调用 <code>Http2Connection.newStream</code> 方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Http2Stream <span class="title">newStream</span><span class="params">(List&lt;Header&gt; requestHeaders, <span class="keyword">boolean</span> out)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> newStream(<span class="number">0</span>, requestHeaders, out);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> Http2Stream <span class="title">newStream</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">int</span> associatedStreamId, List&lt;Header&gt; requestHeaders, <span class="keyword">boolean</span> out)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="keyword">boolean</span> outFinished = !out;</span><br><span class="line">  <span class="keyword">boolean</span> inFinished = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">boolean</span> flushHeaders;</span><br><span class="line">  Http2Stream stream;</span><br><span class="line">  <span class="keyword">int</span> streamId;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">synchronized</span> (writer) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (nextStreamId &gt; Integer.MAX_VALUE / <span class="number">2</span>) &#123;</span><br><span class="line">        shutdown(REFUSED_STREAM);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (shutdown) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConnectionShutdownException();</span><br><span class="line">      &#125;</span><br><span class="line">      streamId = nextStreamId;</span><br><span class="line">      nextStreamId += <span class="number">2</span>;</span><br><span class="line">      stream = <span class="keyword">new</span> Http2Stream(streamId, <span class="keyword">this</span>, outFinished, inFinished, requestHeaders);</span><br><span class="line">      flushHeaders = !out || bytesLeftInWriteWindow == <span class="number">0L</span> || stream.bytesLeftInWriteWindow == <span class="number">0L</span>;</span><br><span class="line">      <span class="keyword">if</span> (stream.isOpen()) &#123;</span><br><span class="line">        streams.put(streamId, stream);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (associatedStreamId == <span class="number">0</span>) &#123;</span><br><span class="line">      writer.synStream(outFinished, streamId, associatedStreamId, requestHeaders);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (client) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"client streams shouldn't have associated stream IDs"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// HTTP/2 has a PUSH_PROMISE frame.</span></span><br><span class="line">      writer.pushPromise(associatedStreamId, streamId, requestHeaders);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (flushHeaders) &#123;</span><br><span class="line">    writer.flush();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> stream;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里会创建一个 <code>Http2Stream</code> ，这个其实是一个抽象的概念，内部封装了HTTP/2请求中双向流的概念，同时会调用 <code>writer.synStream</code> ，最终会调用 <code>Http2Writer.headers</code> 方法，</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">headers</span><span class="params">(<span class="keyword">boolean</span> outFinished, <span class="keyword">int</span> streamId, List&lt;Header&gt; headerBlock)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (closed) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"closed"</span>);</span><br><span class="line">   hpackWriter.writeHeaders(headerBlock);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">long</span> byteCount = hpackBuffer.size();</span><br><span class="line">   <span class="keyword">int</span> length = (<span class="keyword">int</span>) Math.min(maxFrameSize, byteCount);</span><br><span class="line">   <span class="keyword">byte</span> type = TYPE_HEADERS;</span><br><span class="line">   <span class="keyword">byte</span> flags = byteCount == length ? FLAG_END_HEADERS : <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">if</span> (outFinished) flags |= FLAG_END_STREAM;</span><br><span class="line">   frameHeader(streamId, length, type, flags);</span><br><span class="line">   sink.write(hpackBuffer, length);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (byteCount &gt; length) writeContinuationFrames(streamId, byteCount - length);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>这里有两个关键的点</p><ul><li>HTTP/2头部压缩，hpackWriter所在Hpack类就是HTTP用于头部压缩的类</li><li>HTTP帧的概念，这个也在前面有提过，这里开始真正应用了</li></ul><h4 id="Hpack"><a href="#Hpack" class="headerlink" title="Hpack"></a>Hpack</h4><p>Hpack就是HTTP/2引入的新的头部压缩方案，在此之前主要的头部压缩算法是<a href="http://www.freeoa.net/scheme/manual/data-compression-algorithm-deflate_1997.html" target="_blank" rel="noopener">deflate算法</a>（一种主要基于哈夫曼编码和 LZ77压缩的算法），主要做的还是单纯的字符串压缩，Hpack压缩主要有三种压缩方法</p><ul><li>静态字典：一个有着 61 个通用头部字段，并且部分字段是有预定义值的<a href="https://http2.github.io/http2-spec/compression.html#static.table.definition" target="_blank" rel="noopener">预定义字典</a>。</li><li>动态字典：在连接中，一系列实际的头部会被添加进去。因为字典有限制大小，所以当新项被增加，旧项会被去除。</li><li>Huffman 编码： 一种可以被用来对任何字符串：键或者值（译者注：下文 name 对应键，value 对应值），进行编码的<a href="https://http2.github.io/http2-spec/compression.html#huffman.code" target="_blank" rel="noopener">静态 Huffman 编码</a>。这种编码方式是专门为 HTTP 响应或者响应头部设计的——ASCII 里的数字和小写字母可以编码地更短，最短可以编码为 5 个比特（bits）。因此最高压缩比可以达到 8:5 (也就是最多可以降低 37.5%)。</li></ul><p>OkHttp中的Hpack类就是这个算法的实现类，最终压缩之后的头部会写入到一个Buffer缓冲区中，然后通过 <code>frameHeader</code> 方法来为Header信息添加帧的头部信息，同时确定Header的长度是否需要分帧，因为在HTTP/2中帧的大小是有限制的，这个限制由服务端的SETTINGS帧和默认的帧大小（如果还没有收到SETTINGS帧）来确定。</p><p>到此 为止 <code>CallServerInterceptor</code> 也没有太多陌生的东西的，剩余的基本就是对 <code>Source</code> 和 <code>Sink</code>  的封装以及各种IO操作了。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Title:网络连接过程</span><br><span class="line">StreamAllocation-&gt;StreamAllocation:newStream</span><br><span class="line">StreamAllocation-&gt;StreamAllocation:findHealthyConnection</span><br><span class="line">StreamAllocation-&gt;StreamAllocation:findConnection</span><br><span class="line">StreamAllocation-&gt;ConnectionPool:get：尝试复用连接</span><br><span class="line">Note left of ConnectionPool:复用成功</span><br><span class="line">ConnectionPool-&gt;StreamAllocation:RealConnection</span><br><span class="line">Note right of StreamAllocation:复用不成功</span><br><span class="line">StreamAllocation-&gt;RealConnection:创建新连接 </span><br><span class="line">RealConnection-&gt;RealConnection:connect</span><br><span class="line">RealConnection-&gt;RealConnection:connectSocket</span><br><span class="line">RealConnection-&gt;RealConnection:establishProtocol</span><br><span class="line">RealConnection-&gt;Http2Connection:创建Http2连接</span><br><span class="line">Http2Connection-&gt;Http2Connection:start：开始连接</span><br><span class="line">Http2Connection-&gt;RealConnection:</span><br><span class="line">RealConnection-&gt;RealConnection:通过socket获取Sink和Source</span><br><span class="line">RealConnection-&gt;StreamAllocation:</span><br><span class="line">StreamAllocation-&gt;RealConnection:newCodec</span><br><span class="line">RealConnection-&gt;Http2Codec:创建Codec</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Title:网络请求过程</span><br><span class="line">Http2Codec-&gt;Http2Codec:writeRequestHeaders</span><br><span class="line">Http2Codec-&gt;Http2Connection:newStream</span><br></pre></td></tr></table></figure><h2 id="RxJava"><a href="#RxJava" class="headerlink" title="RxJava"></a>RxJava</h2><p>rxjava在网络请求的过程中主要两个地方：</p><ul><li>前面说到过的Retrofit 中的 <code>CallAdapter</code> ，这里我们有一个Rxjava专用的 <code>CallAdapter</code></li><li>Rxjava强大现场转换功能</li></ul><p>我们关注的也仅限于这两点，其他操作符，大家可以自行研究</p><h3 id="RxJava2CallAdapterFactory"><a href="#RxJava2CallAdapterFactory" class="headerlink" title="RxJava2CallAdapterFactory"></a>RxJava2CallAdapterFactory</h3><p>前面说到 <code>CallAdapter</code> 是通过抽象工厂模式创建的，<code>RxJava2CallAdapterFactory</code>  就是一个<code>CallAdapter</code> 的具体工厂。</p><p>在开始之前我们先了解反射的相关知识，此处对于 <code>Class</code> 对象以及相关操作就不多做介绍，这里主要针对有泛型的情况。</p><h4 id="泛型擦除与反射"><a href="#泛型擦除与反射" class="headerlink" title="泛型擦除与反射"></a>泛型擦除与反射</h4><p>我们知道Java有泛型擦除的机制，但是编译之后真的就没有泛型的概念了吗？考虑如下代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">addItems</span><span class="params">(List&lt;String&gt; list)</span></span>&#123;</span><br><span class="line">  List&lt;String&gt; newList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  newList.addAll(list);</span><br><span class="line">    <span class="keyword">return</span> newList;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码经过编译和反编译还会保留什么信息？下面是编译完再反编译之后的代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">String</span>&gt; <span class="keyword">extends</span> <span class="title">Object</span> </span>&#123;</span><br><span class="line">  List&lt;String&gt; list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">addItems</span><span class="params">(List&lt;String&gt; paramList)</span> </span>&#123;</span><br><span class="line">    ArrayList arrayList = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    arrayList.addAll(paramList);</span><br><span class="line">    <span class="keyword">return</span> arrayList;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到部分泛型确实以及被擦除了，但是定义在类上，成员变量以及方法上的泛型都保留了，我们回头看一下 <code>Class</code> 类的定义</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Class</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>,</span></span><br><span class="line"><span class="class">                              <span class="title">GenericDeclaration</span>,</span></span><br><span class="line"><span class="class">                              <span class="title">Type</span>,</span></span><br><span class="line"><span class="class">                              <span class="title">AnnotatedElement</span></span></span><br></pre></td></tr></table></figure><p>可以看到 <code>Class</code> 实现了<code>Type</code> 接口，反射包下的 <code>Type</code> 接口就是类型的抽象，除了 <code>Class</code>  他还有几个其他的实现</p><ul><li><strong>ParameterizedType</strong> 带参数的类型，即泛型，如：<code>List&lt;T&gt;、Map&lt;Integer, String&gt;</code></li><li><strong>GenericArrayType</strong> (泛型)数组类型,比如 <code>List&lt;T&gt;[]，T[]</code> 这种</li><li><strong>WildcardType</strong> 代表通配符表达式，或泛型表达式，比如 <code>?, ? super T</code></li><li><strong>TypeVariable</strong> 类型变量，描述类型，表示泛指任意或相关一类类型，比如 <code>K、V、E</code> 等</li></ul><h4 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h4><p><code>CallAdapter.Factory</code> 作为 <code>CallAdapter</code> 工厂的抽象类，它定义获取创建 <code>CallAdapter</code> 的抽象方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> CallAdapter&lt;?&gt; get(Type returnType, Annotation[] annotations,</span><br><span class="line">        Retrofit retrofit);</span><br></pre></td></tr></table></figure><p>可以看到第一个入参就是我们上节提到的 <code>Type</code> 类型，这个对象通过 <code>Method.getGenericReturnType</code> 返回，这个是一个携带范型信息的类型。</p><p><code>RxJava2CallAdapterFactory</code> 实现的get方法如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> CallAdapter&lt;?&gt; get(Type returnType, Annotation[] annotations, Retrofit retrofit) &#123;</span><br><span class="line">   Class&lt;?&gt; rawType = getRawType(returnType);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (rawType == Completable.class) &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> RxJava2CallAdapter(Void.class, scheduler, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">boolean</span> isFlowable = rawType == Flowable.class;</span><br><span class="line">   <span class="keyword">boolean</span> isSingle = rawType == Single.class;</span><br><span class="line">   <span class="keyword">boolean</span> isMaybe = rawType == Maybe.class;</span><br><span class="line">   <span class="keyword">if</span> (rawType != Observable.class &amp;&amp; !isFlowable &amp;&amp; !isSingle &amp;&amp; !isMaybe) &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">boolean</span> isResult = <span class="keyword">false</span>;</span><br><span class="line">   <span class="keyword">boolean</span> isBody = <span class="keyword">false</span>;</span><br><span class="line">   Type responseType;</span><br><span class="line">   <span class="keyword">if</span> (!(returnType <span class="keyword">instanceof</span> ParameterizedType)) &#123;</span><br><span class="line">     String name = isFlowable ? <span class="string">"Flowable"</span> : isSingle ? <span class="string">"Single"</span> : <span class="string">"Observable"</span>;</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(name + <span class="string">" return type must be parameterized"</span></span><br><span class="line">                                     + <span class="string">" as "</span> + name + <span class="string">"&lt;Foo&gt; or "</span> + name + <span class="string">"&lt;? extends Foo&gt;"</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   Type observableType = getParameterUpperBound(<span class="number">0</span>, (ParameterizedType) returnType);</span><br><span class="line">   Class&lt;?&gt; rawObservableType = getRawType(observableType);</span><br><span class="line">   <span class="keyword">if</span> (rawObservableType == Response.class) &#123;</span><br><span class="line">     <span class="keyword">if</span> (!(observableType <span class="keyword">instanceof</span> ParameterizedType)) &#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Response must be parameterized"</span></span><br><span class="line">                                       + <span class="string">" as Response&lt;Foo&gt; or Response&lt;? extends Foo&gt;"</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     responseType = getParameterUpperBound(<span class="number">0</span>, (ParameterizedType) observableType);</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rawObservableType == Result.class) &#123;</span><br><span class="line">     <span class="keyword">if</span> (!(observableType <span class="keyword">instanceof</span> ParameterizedType)) &#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Result must be parameterized"</span></span><br><span class="line">                                       + <span class="string">" as Result&lt;Foo&gt; or Result&lt;? extends Foo&gt;"</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     responseType = getParameterUpperBound(<span class="number">0</span>, (ParameterizedType) observableType);</span><br><span class="line">     isResult = <span class="keyword">true</span>;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     responseType = observableType;</span><br><span class="line">     isBody = <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> RxJava2CallAdapter(responseType, scheduler, isResult, isBody, isFlowable,</span><br><span class="line">                                 isSingle, isMaybe, <span class="keyword">false</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>整段代码逻辑基本上可以分为2个部分</p><ul><li>获取原始类型，过滤掉非RxJava支持的原始类型</li><li>获取范型类型，过滤掉没有上界的范型类型</li></ul><p><code>RxJava2CallAdapter</code> 的实现相对就比较简单了，就是将 <code>Call</code> 封装成 <code>Observable</code> ，这里根据上面范型类型的不同会有三种 <code>Observable</code> ，但是没有本质的区别，只是对结果的不同封装，有兴趣可以自行了解。</p><h3 id="线程变换"><a href="#线程变换" class="headerlink" title="线程变换"></a>线程变换</h3><h4 id="Scheduler调度器"><a href="#Scheduler调度器" class="headerlink" title="Scheduler调度器"></a>Scheduler调度器</h4><p>在Rxjava的线程变换中 <code>Scheduler</code> 占据的很大分量，在Rxjava中的几个线程变换的方法也是基于<code>Scheduler</code>来完成的，我们首先来看下 <code>Scheduler</code> 的定义。</p><p><img src="./记一次网络请求全过程/Scheduler.png" style="zoom:67%;" align="left"></p><p>可以看到 <code>Scheduler</code> 下的方法不多，还有一个内部类，这些方法基本可以分为三类</p><ul><li><p>工具方法，没有太多逻辑，这里不多做介绍</p></li><li><p>模版方法，入参都以<code>Runnable</code> 为主</p><ul><li><p><code>scheduleDirect</code> 直接在<code>Scheduler</code>指定的线程在对<code>Runnable</code>调度</p></li><li><p><code>schedulePeriodicallyDirect</code> 在 <code>Scheduler</code> 所指定线程周期性的执行<code>Runnable</code></p></li></ul></li><li><p>需要子类实现的方法</p><ul><li><code>createWorker</code> 用于创建 <code>Worker</code> ， <code>Worker</code> 继承自 <code>Disposable</code> ，熟悉RxJava的同学应该知道，这个用于表示一次性用品，当<code>dispose</code>调用后<code>Disposable</code> 的工作就终止了 ，而<code>Worker</code> 主要是<code>Runnable</code>的执行体</li><li><code>start</code> 一般用于以线程池实现的<code>Scheduler</code> , 用于开始线程池</li><li><code>shutdown</code> 一般用于结束线程池</li></ul></li></ul><p>首先我们先看下 <code>Scheduler</code> 下的主要模版方法 <code>scheduleDirect</code> </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Disposable <span class="title">scheduleDirect</span><span class="params">(Runnable run, <span class="keyword">long</span> delay, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Worker w = createWorker();</span><br><span class="line">  <span class="comment">//RxJavaPlugins算是RxJava中一个全局的配置类，配置一些关键的代理点，也就是Hook点，</span></span><br><span class="line">  <span class="comment">//我们可以通过它的参数实现全局的配置</span></span><br><span class="line">  <span class="comment">//此处没有配置的情况下decoratedRun还是run本身</span></span><br><span class="line">  <span class="keyword">final</span> Runnable decoratedRun = RxJavaPlugins.onSchedule(run);</span><br><span class="line">  w.schedule(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        decoratedRun.run();</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        w.dispose();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, delay, unit);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> w;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到<code>scheduleDirect</code> 的主要工作是通过 <code>Worker</code> 来完成的，而 <code>Worker</code> 的实现主要又依赖于它的实现类。接下来我们以<code>IoScheduler</code> 为例，来了解 <code>Scheduler</code> 实现。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">  <span class="comment">//NONE为一个空的</span></span><br><span class="line">  NONE = <span class="keyword">new</span> CachedWorkerPool(<span class="number">0</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//CachedWorkerPool是一个WorkerPool</span></span><br><span class="line">  CachedWorkerPool update = <span class="keyword">new</span> CachedWorkerPool(KEEP_ALIVE_TIME, KEEP_ALIVE_UNIT, threadFactory);</span><br><span class="line">  <span class="comment">//pool为AtomicReferencel类，compareAndSet可以用于实现原子操作</span></span><br><span class="line">  <span class="keyword">if</span> (!pool.compareAndSet(NONE, update)) &#123;</span><br><span class="line">    update.shutdown();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    CachedWorkerPool curr = pool.get();</span><br><span class="line">    <span class="keyword">if</span> (curr == NONE) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pool.compareAndSet(curr, NONE)) &#123;</span><br><span class="line">      curr.shutdown();</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Worker <span class="title">createWorker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> EventLoopWorker(pool.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到<code>IoScheduler</code>类中本身也没有太多的逻辑，核心的逻辑主要还是由 <code>EventLoopWorker</code> 这个 <code>Worker</code> 的实现类来完成的，在开始之前我们需要先了解一下 <code>IoScheduler</code> 的特点，它主要为 <code>IO</code> 密集型设计，<code>IO</code> 密集型的特点就是大量时间在等待磁盘，一定范围内，任务越多，性能越好。</p><p><code>EventLoopWorker</code> 在构造函数中会从 <code>CachedWorkerPool</code> 中获取 <code>Worker</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">ThreadWorker <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (allWorkers.isDisposed()) &#123;</span><br><span class="line">    <span class="keyword">return</span> SHUTDOWN_THREAD_WORKER;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (!expiringWorkerQueue.isEmpty()) &#123;</span><br><span class="line">    ThreadWorker threadWorker = expiringWorkerQueue.poll();</span><br><span class="line">    <span class="keyword">if</span> (threadWorker != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> threadWorker;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// No cached worker found, so create a new one.</span></span><br><span class="line">  ThreadWorker w = <span class="keyword">new</span> ThreadWorker(threadFactory);</span><br><span class="line">  allWorkers.add(w);</span><br><span class="line">  <span class="keyword">return</span> w;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到<code>CachedWorkerPool</code> 其实就是一个 <code>Worker</code> 池，他会回收和复用 <code>Worker</code> ，<code>ThreadWorker</code> 继承自<code>NewThreadWorker</code> ，主要扩展了超时的概念，实际的逻辑在父类中实现</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NewThreadWorker</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">  executor = SchedulerPoolFactory.create(threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>NewThreadWorker</code> 的构造函数会创建一个线程池，创建的线程池是<code>ScheduledThreadPoolExecutor</code> ，这个是一个线程数量无限制，且可以执行延迟任务和周期任务的线程池，具体实现大家自行查阅，<code>NewThreadWorker</code> 的 <code>schedule</code> 主要也是依赖这个线程池</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Disposable <span class="title">scheduleDirect</span><span class="params">(<span class="keyword">final</span> Runnable run, <span class="keyword">long</span> delayTime, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">  ScheduledDirectTask task = <span class="keyword">new</span> ScheduledDirectTask(RxJavaPlugins.onSchedule(run));</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    Future&lt;?&gt; f;</span><br><span class="line">    <span class="keyword">if</span> (delayTime &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">      f = executor.submit(task);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      f = executor.schedule(task, delayTime, unit);</span><br><span class="line">    &#125;</span><br><span class="line">    task.setFuture(f);</span><br><span class="line">    <span class="keyword">return</span> task;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (RejectedExecutionException ex) &#123;</span><br><span class="line">    RxJavaPlugins.onError(ex);</span><br><span class="line">    <span class="keyword">return</span> EmptyDisposable.INSTANCE;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="线程变换方法"><a href="#线程变换方法" class="headerlink" title="线程变换方法"></a>线程变换方法</h4><p>我们首先以 <code>subscribeOn</code> 为例来了解这个过程</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;T&gt; <span class="title">subscribeOn</span><span class="params">(Scheduler scheduler)</span> </span>&#123;</span><br><span class="line">        ObjectHelper.requireNonNull(scheduler, <span class="string">"scheduler is null"</span>);</span><br><span class="line">  <span class="keyword">return</span> RxJavaPlugins.onAssembly(<span class="keyword">new</span> ObservableSubscribeOn&lt;T&gt;(<span class="keyword">this</span>, scheduler));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>subscribeOn</code> 主要是创建了一个新的<code>Observable</code> ，我们主要来看一下它的<code>subscribeActual</code> ，这个是我们订阅时最终调用的方法。也就是当<code>subscribeOn</code> 生成的<code>Observable</code> 方法的<code>subscribe</code> 被调用时调用的方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribeActual</span><span class="params">(<span class="keyword">final</span> Observer&lt;? <span class="keyword">super</span> T&gt; observer)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//创建了一个Observer，其实大部分RxJava的操作符都会创建一个Observable和一个Observer</span></span><br><span class="line">  <span class="keyword">final</span> SubscribeOnObserver&lt;T&gt; parent = <span class="keyword">new</span> SubscribeOnObserver&lt;T&gt;(observer);</span><br><span class="line">  <span class="comment">//onSubscribe回调</span></span><br><span class="line">  observer.onSubscribe(parent);</span><br><span class="line">  <span class="comment">//调度任务</span></span><br><span class="line">  parent.setDisposable(scheduler.scheduleDirect(<span class="keyword">new</span> SubscribeTask(parent)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到核心代码在最后一行我们使用<code>Scheduler</code>去调度一个<code>Runnable</code> ,以<code>IOScheduler</code> 为例，他会使用一个<code>ScheduledThreadPoolExecutor</code>的线程池来执行这个<code>Runnable</code>，也就是这个<code>Runable</code>  最终是在一个线程池中运行的。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SubscribeTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> SubscribeOnObserver&lt;T&gt; parent;</span><br><span class="line"></span><br><span class="line">  SubscribeTask(SubscribeOnObserver&lt;T&gt; parent) &#123;</span><br><span class="line">    <span class="keyword">this</span>.parent = parent;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    source.subscribe(parent);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个 <code>Runnable</code>  的实现也非常简单，但是也是 <code>Rxjava</code>  操作符的核心，链式操作。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.im/post/5856680c8e450a006c6474bd" target="_blank" rel="noopener">OKio - 重新定义了“短小精悍”的IO框架</a></p><p><a href="https://zh.wikipedia.org/zh-hans/HTTP/2" target="_blank" rel="noopener">HTTP/2 - 维基百科</a></p><p><a href="http://www.blogjava.net/yongboy/archive/2015/03/18/423570.html" target="_blank" rel="noopener">HTTP/2笔记之连接建立</a></p><p><a href="http://www.blogjava.net/yongboy/archive/2015/03/20/423655.html" target="_blank" rel="noopener">HTTP/2笔记之帧</a></p><p><a href="https://juejin.im/post/5d033d3df265da1baa1e700e" target="_blank" rel="noopener">HPACK：http2中沉默的杀手</a></p><p><a href="http://www.freeoa.net/scheme/manual/data-compression-algorithm-deflate_1997.html" target="_blank" rel="noopener">数据压缩算法-DEFLATE</a></p><p><a href="https://www.jianshu.com/p/4b8c01f4941b" target="_blank" rel="noopener">Java 如何在运行时获取被擦除的泛型参数类型</a></p><p><a href="https://zhuanlan.zhihu.com/p/24473022" target="_blank" rel="noopener">关于RxJava最友好的文章——背压（Backpressure）</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一次网络请求&quot;&gt;&lt;a href=&quot;#一次网络请求&quot; class=&quot;headerlink&quot; title=&quot;一次网络请求&quot;&gt;&lt;/a&gt;一次网络请求&lt;/h2&gt;&lt;p&gt;目前我们的网络框架采用RxJava+Retrofit+OkHttp，使用起来非常简单，只需要简单几行代码便能
      
    
    </summary>
    
      <category term="Android" scheme="http://haojen.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://haojen.github.io/tags/Android/"/>
    
      <category term="网络" scheme="http://haojen.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Glidle杂记</title>
    <link href="http://haojen.github.io/2019/07/09/gilde/"/>
    <id>http://haojen.github.io/2019/07/09/gilde/</id>
    <published>2019-07-09T02:18:26.000Z</published>
    <updated>2020-04-23T05:57:08.950Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="Glide杂记"><a href="#Glide杂记" class="headerlink" title="Glide杂记"></a>Glide杂记</h1><p>Glide使用过程加载过程主要有如下几个步骤</p><ul><li>with ReqestManager （Lifecycle，RequestTracker）<br>管理关联在同一个Activity（不包括子Activity）或者说关联在统一Fragment上的所有Request</li><li>load RequestBuilder 设置请求的各种参数，用于创建请求</li><li>into Request.begin 开始请求</li></ul><p>总体来说Glide的使用可以分为Request构造和Request运行两个部分</p><h2 id="Reqest构造过程"><a href="#Reqest构造过程" class="headerlink" title="Reqest构造过程"></a>Reqest构造过程</h2><p>Reqest的构造过程主要完成了两件事：</p><ul><li>宿主（Activity、Fragment等）生命周期的绑定</li><li>Request参数的创建的管理</li></ul><h4 id="生命周期绑定"><a href="#生命周期绑定" class="headerlink" title="生命周期绑定"></a>生命周期绑定</h4><p><img src="./glide/request.png" alt="img"></p><h4 id="Request参数设置"><a href="#Request参数设置" class="headerlink" title="Request参数设置"></a>Request参数设置</h4><p>Request参数除了我们手动设置的url、placeHolder、transform等参数之外在创建真正的Request之前还会确定几个重要的策略，这些策略在Glide的不同版本可能会有不同的组合，但整体结构没有太大变化</p><ul><li>ModelLoader</li><li>DataLoadProvider</li><li>ModelLoader</li></ul><h2 id="Glide请求过程"><a href="#Glide请求过程" class="headerlink" title="Glide请求过程"></a>Glide请求过程</h2><p>Glide的请求过程主要分为</p><ul><li>构造请求<ul><li>DrawableTypeRequest</li><li>GifTypeRequest</li><li>BitmapTypeRequest</li></ul></li><li>获取数据源 loadProvider</li><li>加载解码成可用的数据</li><li>显示</li></ul><h3 id="loadProvider"><a href="#loadProvider" class="headerlink" title="loadProvider"></a>loadProvider</h3><p>可扩展的LoaderProvider</p><ul><li>FixedLoadProvider<br>集成了DataLoadProvider、ModelLoader和ResourceTranscoder<ul><li>ModelLoader定义了数据源（从Uri、文件、String等获取原始的输入流或着其封装类）</li><li>DataLoadProvider定义了输入流到目标资源以及缓存文件三者之间的转换关系</li><li>ResourceTranscoder定义了一种资源格式到另一种资源格式（Drawable、Bitmap、gif）的转码方式</li></ul></li><li>ChildLoadProvider</li></ul><h4 id="DataLoadProvider"><a href="#DataLoadProvider" class="headerlink" title="DataLoadProvider"></a>DataLoadProvider</h4><ul><li>DataFetcher获取的数据源(InputSream等)</li><li>目标资源Resourse&lt;?&gt;（Bitmap，Drawable，Gif等）</li><li>File 文件缓存</li></ul><p>预设的DataLoadProvider</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dataLoadProviderRegistry = <span class="keyword">new</span> DataLoadProviderRegistry();</span><br><span class="line"></span><br><span class="line">   StreamBitmapDataLoadProvider streamBitmapLoadProvider =</span><br><span class="line">           <span class="keyword">new</span> StreamBitmapDataLoadProvider(bitmapPool, decodeFormat);</span><br><span class="line">   dataLoadProviderRegistry.register(InputStream.class, Bitmap.class, streamBitmapLoadProvider);</span><br><span class="line"></span><br><span class="line">   FileDescriptorBitmapDataLoadProvider fileDescriptorLoadProvider =</span><br><span class="line">           <span class="keyword">new</span> FileDescriptorBitmapDataLoadProvider(bitmapPool, decodeFormat);</span><br><span class="line">   dataLoadProviderRegistry.register(ParcelFileDescriptor.class, Bitmap.class, fileDescriptorLoadProvider);</span><br><span class="line"></span><br><span class="line">   ImageVideoDataLoadProvider imageVideoDataLoadProvider =</span><br><span class="line">           <span class="keyword">new</span> ImageVideoDataLoadProvider(streamBitmapLoadProvider, fileDescriptorLoadProvider);</span><br><span class="line">   dataLoadProviderRegistry.register(ImageVideoWrapper.class, Bitmap.class, imageVideoDataLoadProvider);</span><br><span class="line"></span><br><span class="line">   GifDrawableLoadProvider gifDrawableLoadProvider =</span><br><span class="line">           <span class="keyword">new</span> GifDrawableLoadProvider(context, bitmapPool);</span><br><span class="line">   dataLoadProviderRegistry.register(InputStream.class, GifDrawable.class, gifDrawableLoadProvider);</span><br><span class="line"></span><br><span class="line">   dataLoadProviderRegistry.register(ImageVideoWrapper.class, GifBitmapWrapper.class,</span><br><span class="line">           <span class="keyword">new</span> ImageVideoGifDrawableLoadProvider(imageVideoDataLoadProvider, gifDrawableLoadProvider, bitmapPool));</span><br><span class="line"></span><br><span class="line">   dataLoadProviderRegistry.register(InputStream.class, File.class, <span class="keyword">new</span> StreamFileDataLoadProvider());</span><br></pre></td></tr></table></figure><h4 id="ModelLoader-装饰者-适配器"><a href="#ModelLoader-装饰者-适配器" class="headerlink" title="ModelLoader 装饰者+适配器"></a>ModelLoader 装饰者+适配器</h4><p>将我们通过load传入的参入转换成特定的DataFetcher<resource>输出（InputStream或者其封装类）<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Glide(Engine engine, MemoryCache memoryCache, BitmapPool bitmapPool, Context context, DecodeFormat decodeFormat) &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//Model class ,Resource class, LoaderFactory</span></span><br><span class="line">    register(File.class, ParcelFileDescriptor.class, <span class="keyword">new</span> FileDescriptorFileLoader.Factory());</span><br><span class="line">    register(File.class, InputStream.class, <span class="keyword">new</span> StreamFileLoader.Factory());</span><br><span class="line">    register(<span class="keyword">int</span>.class, ParcelFileDescriptor.class, <span class="keyword">new</span> FileDescriptorResourceLoader.Factory());</span><br><span class="line">    register(<span class="keyword">int</span>.class, InputStream.class, <span class="keyword">new</span> StreamResourceLoader.Factory());</span><br><span class="line">    register(Integer.class, ParcelFileDescriptor.class, <span class="keyword">new</span> FileDescriptorResourceLoader.Factory());</span><br><span class="line">    register(Integer.class, InputStream.class, <span class="keyword">new</span> StreamResourceLoader.Factory());</span><br><span class="line">    register(String.class, ParcelFileDescriptor.class, <span class="keyword">new</span> FileDescriptorStringLoader.Factory());</span><br><span class="line">    register(String.class, InputStream.class, <span class="keyword">new</span> StreamStringLoader.Factory());</span><br><span class="line">    register(Uri.class, ParcelFileDescriptor.class, <span class="keyword">new</span> FileDescriptorUriLoader.Factory());</span><br><span class="line">    register(Uri.class, InputStream.class, <span class="keyword">new</span> StreamUriLoader.Factory());</span><br><span class="line">    register(URL.class, InputStream.class, <span class="keyword">new</span> StreamUrlLoader.Factory());</span><br><span class="line">    register(GlideUrl.class, InputStream.class, <span class="keyword">new</span> HttpUrlGlideUrlLoader.Factory());</span><br><span class="line">    register(<span class="keyword">byte</span>[].class, InputStream.class, <span class="keyword">new</span> StreamByteArrayLoader.Factory());</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></resource></p><h4 id="DataFetcher-装饰者-适配器"><a href="#DataFetcher-装饰者-适配器" class="headerlink" title="DataFetcher 装饰者+适配器"></a>DataFetcher 装饰者+适配器</h4><p>通过网络或者文件、资源等方式获取数据源</p><h2 id="BitmapPool"><a href="#BitmapPool" class="headerlink" title="BitmapPool"></a>BitmapPool</h2><h3 id="LruPoolStrategy"><a href="#LruPoolStrategy" class="headerlink" title="LruPoolStrategy"></a>LruPoolStrategy</h3><h4 id="SizeConfigStrategy"><a href="#SizeConfigStrategy" class="headerlink" title="SizeConfigStrategy"></a>SizeConfigStrategy</h4><ul><li><code>GroupedLinkedMap&lt;Key, Bitmap&gt; groupedMap</code> 自定义的LruCache，使用链表和HashMap实现</li><li><code>Map&lt;Bitmap.Config, NavigableMap&lt;Integer, Integer&gt;&gt; sortedSizes</code> 以Bitmap的Config为纬度存储了对象池中每种对象大小的数量，用于快速判断是否存在可用的Bitmap对象缓存，这里使用的<code>NavigableMap</code>为<code>TreeMap</code>,key的存储方式为红黑树结构（使用红黑树是因为在复用时可能没有完全大小相同的Bitmap对象，所以会遍历整个map按大小顺序找到第一个比需要的Bitmap大的复用）</li></ul><h2 id="Glide-缓存"><a href="#Glide-缓存" class="headerlink" title="Glide 缓存"></a>Glide 缓存</h2><h3 id="Key的构造"><a href="#Key的构造" class="headerlink" title="Key的构造"></a>Key的构造</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">EngineKey key = keyFactory.buildKey(id, signature, width, height, loadProvider.getCacheDecoder(),</span><br><span class="line">               loadProvider.getSourceDecoder(), transformation, loadProvider.getEncoder(),</span><br><span class="line">               transcoder, loadProvider.getSourceEncoder());</span><br></pre></td></tr></table></figure><p>从EngineKey的构造可以看出，即使是同一个Url下的不同尺寸或者不同的transformation、transcoder，也会产生不同的Key</p><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>Glide的内存缓存中存在两种内存缓存机制、LruCache（使用LikedHashMap结构存储的强引用内存缓存，默认的缓存大小为两个整屏幕的图片大小）和使用弱引用存储的activeResources</p><ul><li>优先从强引用中获取图片</li><li>其次试图从弱引用中获取图片</li><li>最后再考虑磁盘</li></ul><p>LruCache的大小固定，即使内存情况良好，也不会缓存更多图片，使用弱引用就是为了在内存环境良好的情况下在内存中缓存更多的图片，从而提升缓存的加载速度。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">EngineResource&lt;?&gt; cached = loadFromCache(key, isMemoryCacheable);</span><br><span class="line"><span class="keyword">if</span> (cached != <span class="keyword">null</span>) &#123;</span><br><span class="line">    cb.onResourceReady(cached);</span><br><span class="line">    <span class="keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">        logWithTimeAndKey(<span class="string">"Loaded resource from cache"</span>, startTime, key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EngineResource&lt;?&gt; active = loadFromActiveResources(key, isMemoryCacheable);</span><br><span class="line"><span class="keyword">if</span> (active != <span class="keyword">null</span>) &#123;</span><br><span class="line">    cb.onResourceReady(active);</span><br><span class="line">    <span class="keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">        logWithTimeAndKey(<span class="string">"Loaded resource from active resources"</span>, startTime, key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EngineJob current = jobs.get(key);</span><br><span class="line"><span class="keyword">if</span> (current != <span class="keyword">null</span>) &#123;</span><br><span class="line">    current.addCallback(cb);</span><br><span class="line">    <span class="keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">        logWithTimeAndKey(<span class="string">"Added to existing load"</span>, startTime, key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> LoadStatus(cb, current);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EngineJob engineJob = engineJobFactory.build(key, isMemoryCacheable);</span><br><span class="line">DecodeJob&lt;T, Z, R&gt; decodeJob = <span class="keyword">new</span> DecodeJob&lt;T, Z, R&gt;(key, width, height, fetcher, loadProvider, transformation,</span><br><span class="line">        transcoder, diskCacheProvider, diskCacheStrategy, priority);</span><br><span class="line">EngineRunnable runnable = <span class="keyword">new</span> EngineRunnable(engineJob, decodeJob, priority);</span><br><span class="line">jobs.put(key, engineJob);</span><br><span class="line">engineJob.addCallback(cb);</span><br><span class="line">engineJob.start(runnable);</span><br></pre></td></tr></table></figure><p>代码中可以看出从内存缓存中获取Resource文件时，只使用原始的EngineKey，这样获取的Resource时是指定宽高且经过Transform和transcoder转换后的，由此也可以看出，内存缓存中只会有经过各种转换之后的图片资源</p><h3 id="磁盘缓存过程"><a href="#磁盘缓存过程" class="headerlink" title="磁盘缓存过程"></a>磁盘缓存过程</h3><p>在无法从内存中获取指定的图片资源之后，会尝试从磁盘或者网络获取，这个过程在<code>EngineRunnable</code>中完成<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Resource&lt;?&gt; decode() <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">if</span> (isDecodingFromCache()) &#123;</span><br><span class="line">        <span class="keyword">return</span> decodeFromCache();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> decodeFromSource();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Resource&lt;?&gt; decodeFromCache() <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Resource&lt;?&gt; result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            result = decodeJob.decodeResultFromCache();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Log.isLoggable(TAG, Log.DEBUG)) &#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"Exception decoding result from cache: "</span> + e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">            result = decodeJob.decodeSourceFromCache();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当从磁盘缓存中获取图片时会有两个过程</p><ol><li>试图使用完整的EngineKey（包括宽、高、Transform和transcoder）获取指定的文件，当然DataLoadProvider只提供从File到指定中间资源类型的转化，这里从磁盘获取资源之后还是会使用transcoder进行转化</li><li>当无法通过完整的EngineKey获取到资源时，会尝试使用OriginalKey获取资源，OriginalKey只包含请求id和签名，只能查找原始没有经过任何大小或者其他转换前的资源文件<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Resource&lt;Z&gt; <span class="title">decodeSourceFromCache</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!diskCacheStrategy.cacheSource()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> startTime = LogTime.getLogTime();</span><br><span class="line">    Resource&lt;T&gt; decoded = loadFromCache(resultKey.getOriginalKey());</span><br><span class="line">    <span class="keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">        logWithTimeAndKey(<span class="string">"Decoded source from cache"</span>, startTime);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> transformEncodeAndTranscode(decoded);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> Resource&lt;Z&gt; <span class="title">transformEncodeAndTranscode</span><span class="params">(Resource&lt;T&gt; decoded)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> startTime = LogTime.getLogTime();</span><br><span class="line">    Resource&lt;T&gt; transformed = transform(decoded);</span><br><span class="line">    <span class="keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">        logWithTimeAndKey(<span class="string">"Transformed resource from source"</span>, startTime);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    writeTransformedToCache(transformed);</span><br><span class="line"></span><br><span class="line">    startTime = LogTime.getLogTime();</span><br><span class="line">    Resource&lt;Z&gt; result = transcode(transformed);</span><br><span class="line">    <span class="keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">        logWithTimeAndKey(<span class="string">"Transcoded transformed from source"</span>, startTime);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>在第二次尝试从磁盘获取资源成功后会先通过transform来对中间的资源类型进行转换后，并把转换后同时宽高以及变换的图片写入磁盘缓存，最后进行transcode</p><h3 id="网络请求"><a href="#网络请求" class="headerlink" title="网络请求"></a>网络请求</h3><p>在无法通过磁盘缓存获取到数据时，会进入一个异常处理流程，同时会判断异常是否是由于磁盘没有文件导致的<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onLoadFailed</span><span class="params">(Exception e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isDecodingFromCache()) &#123;</span><br><span class="line">        stage = Stage.SOURCE;</span><br><span class="line">        manager.submitForSource(<span class="keyword">this</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        manager.onException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="纵观全局"><a href="#纵观全局" class="headerlink" title="纵观全局"></a>纵观全局</h2><p>在整个Glide的源码阅读过程中最大的印象就是缓存，图片有LRUcache，weakRefence、DiskLruCache，key有KeyPool，Bitmap有BitmapPool，ModelLoader有ModelLoaderCache</p><p>其次就是</p><h1 id="储备知识"><a href="#储备知识" class="headerlink" title="储备知识"></a>储备知识</h1><h3 id="ReferenceQueue"><a href="#ReferenceQueue" class="headerlink" title="ReferenceQueue"></a>ReferenceQueue</h3><ul><li>FinalReference</li><li>SoftReference</li><li>WeakReference</li><li>PhantomReference</li></ul><p>ReferenceQueue 主要适用于追踪后三种引用类型的被系统回收的情况，可以作为构造入参传入他们的构造函数中，系统会自动把被系统回收的对象添加到这个<code>ReferenceQueue</code>中。</p><figure class="highlight plain"><figcaption><span>```</span></figcaption><table><tr><td class="code"><pre><span class="line">```cpp</span><br><span class="line">collector::GcType Heap::CollectGarbageInternal(collector::GcType gc_type,</span><br><span class="line">                                               GcCause gc_cause,</span><br><span class="line">                                               bool clear_soft_references) &#123;</span><br><span class="line">  Thread* self = Thread::Current();</span><br><span class="line">  Runtime* runtime = Runtime::Current();</span><br><span class="line">  // If the heap can&apos;t run the GC, silently fail and return that no GC was run.</span><br><span class="line">  .....GC过程</span><br><span class="line">  // Enqueue cleared references.</span><br><span class="line">  reference_processor_-&gt;EnqueueClearedReferences(self);</span><br><span class="line">  // Grow the heap so that we know when to perform the next GC.</span><br><span class="line">  GrowForUtilization(collector, bytes_allocated_before_gc);</span><br><span class="line">  LogGC(gc_cause, collector);</span><br><span class="line">  FinishGC(self, gc_type);</span><br><span class="line">  // Inform DDMS that a GC completed.</span><br><span class="line">  Dbg::GcDidFinish();</span><br><span class="line">  ......</span><br><span class="line">  return gc_type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Android系统GC完成时会调用<code>ReferenceProcessor::EnqueueClearedReferences</code>来把回收掉的引用放入引用队列中。</p><figure class="highlight plain"><figcaption><span>```</span></figcaption><table><tr><td class="code"><pre><span class="line">```cpp</span><br><span class="line">void ReferenceProcessor::EnqueueClearedReferences(Thread* self) &#123;</span><br><span class="line">  Locks::mutator_lock_-&gt;AssertNotHeld(self);</span><br><span class="line">  // When a runtime isn&apos;t started there are no reference queues to care about so ignore.</span><br><span class="line">  if (!cleared_references_.IsEmpty()) &#123;</span><br><span class="line">    if (LIKELY(Runtime::Current()-&gt;IsStarted())) &#123;</span><br><span class="line">      jobject cleared_references;</span><br><span class="line">      &#123;</span><br><span class="line">        ReaderMutexLock mu(self, *Locks::mutator_lock_);</span><br><span class="line">        cleared_references = self-&gt;GetJniEnv()-&gt;vm-&gt;AddGlobalRef(</span><br><span class="line">            self, cleared_references_.GetList());</span><br><span class="line">      &#125;</span><br><span class="line">      if (kAsyncReferenceQueueAdd) &#123;</span><br><span class="line">        // TODO: This can cause RunFinalization to terminate before newly freed objects are</span><br><span class="line">        // finalized since they may not be enqueued by the time RunFinalization starts.</span><br><span class="line">        Runtime::Current()-&gt;GetHeap()-&gt;GetTaskProcessor()-&gt;AddTask(</span><br><span class="line">            self, new ClearedReferenceTask(cleared_references));</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        ClearedReferenceTask task(cleared_references);</span><br><span class="line">        task.Run(self);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cleared_references_.Clear();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ReferenceProcessor</code>主要通过<code>Thread</code>对象获取了回收的引用对象，创建了一个<code>ClearedReferenceTask</code>，这个task就是真正把回收的对象放入引用队列的方法</p><figure class="highlight plain"><figcaption><span>```</span></figcaption><table><tr><td class="code"><pre><span class="line">```cpp</span><br><span class="line">class ClearedReferenceTask : public HeapTask &#123;</span><br><span class="line"> public:</span><br><span class="line">  explicit ClearedReferenceTask(jobject cleared_references)</span><br><span class="line">      : HeapTask(NanoTime()), cleared_references_(cleared_references) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  virtual void Run(Thread* thread) &#123;</span><br><span class="line">    ScopedObjectAccess soa(thread);</span><br><span class="line">    jvalue args[1];</span><br><span class="line">    args[0].l = cleared_references_;</span><br><span class="line">    InvokeWithJValues(soa, nullptr, WellKnownClasses::java_lang_ref_ReferenceQueue_add, args);</span><br><span class="line">    soa.Env()-&gt;DeleteGlobalRef(cleared_references_);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line">  const jobject cleared_references_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>ClearedReferenceTask</code>主要作用就是回调Java层方法的相应方法</p><figure class="highlight plain"><figcaption><span>```</span></figcaption><table><tr><td class="code"><pre><span class="line">```java</span><br><span class="line">static void add(Reference&lt;?&gt; list) &#123;</span><br><span class="line">    synchronized (ReferenceQueue.class) &#123;</span><br><span class="line">        if (unenqueued == null) &#123;</span><br><span class="line">            unenqueued = list;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // Find the last element in unenqueued.</span><br><span class="line">            Reference&lt;?&gt; last = unenqueued;</span><br><span class="line">            while (last.pendingNext != unenqueued) &#123;</span><br><span class="line">              last = last.pendingNext;</span><br><span class="line">            &#125;</span><br><span class="line">            // Add our list to the end. Update the pendingNext to point back to enqueued.</span><br><span class="line">            last.pendingNext = list;</span><br><span class="line">            last = list;</span><br><span class="line">            while (last.pendingNext != list) &#123;</span><br><span class="line">                last = last.pendingNext;</span><br><span class="line">            &#125;</span><br><span class="line">            last.pendingNext = unenqueued;</span><br><span class="line">        &#125;</span><br><span class="line">        ReferenceQueue.class.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此为止，被回收的对象已经回到java层的<code>ReferenceQueue</code> 中，但是只是作为静态变量存储了，并没有进入相应的引用队列中，这个就得说起另外一个东西了,Deamons守护线程<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> Runtime::Start() &#123;</span><br><span class="line">    .....</span><br><span class="line">    StartDaemonThreads();</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Runtime::StartDaemonThreads() &#123;</span><br><span class="line">    <span class="function">ScopedTrace <span class="title">trace</span><span class="params">(__FUNCTION__)</span></span>;</span><br><span class="line">    VLOG(startup) &lt;&lt; <span class="string">"Runtime::StartDaemonThreads entering"</span>;</span><br><span class="line"></span><br><span class="line">    Thread* self = Thread::Current();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Must be in the kNative state for calling native methods.</span></span><br><span class="line">    CHECK_EQ(self-&gt;GetState(), kNative);</span><br><span class="line"></span><br><span class="line">    JNIEnv* env = self-&gt;GetJniEnv();</span><br><span class="line">    env-&gt;CallStaticVoidMethod(WellKnownClasses::java_lang_Daemons,</span><br><span class="line">                            WellKnownClasses::java_lang_Daemons_start);</span><br><span class="line">    <span class="keyword">if</span> (env-&gt;ExceptionCheck()) &#123;</span><br><span class="line">        env-&gt;ExceptionDescribe();</span><br><span class="line">        LOG(FATAL) &lt;&lt; <span class="string">"Error starting java.lang.Daemons"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    VLOG(startup) &lt;&lt; <span class="string">"Runtime::StartDaemonThreads exiting"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在Android Runtime的start方法中会调用一个<code>StartDaemonThreads</code>方法，最终会调用到java层<code>Daemons.start</code>方法。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//引用队列守护线程</span></span><br><span class="line">    ReferenceQueueDaemon.INSTANCE.start();</span><br><span class="line">    <span class="comment">//析构守护线程</span></span><br><span class="line">    FinalizerDaemon.INSTANCE.start();</span><br><span class="line">    <span class="comment">//析构监护守护线程</span></span><br><span class="line">    FinalizerWatchdogDaemon.INSTANCE.start();</span><br><span class="line">    <span class="comment">//守护堆任务线程</span></span><br><span class="line">    HeapTaskDaemon.INSTANCE.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在Daemons中有好几个守护线程，我们主要关注的是<code>ReferenceQueueDaemon</code>引用队列守护线程<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runInternal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (isRunning()) &#123;</span><br><span class="line">        Reference&lt;?&gt; list;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (ReferenceQueue.class) &#123;</span><br><span class="line">                <span class="keyword">while</span> (ReferenceQueue.unenqueued == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    ReferenceQueue.class.wait();</span><br><span class="line">                &#125;</span><br><span class="line">                list = ReferenceQueue.unenqueued;</span><br><span class="line">                ReferenceQueue.unenqueued = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (OutOfMemoryError e) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ReferenceQueue.enqueuePending(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在<code>ReferenceQueueDaemon.runInternal</code>方法中会获取前面GC后存入<code>ReferenceQueue.unenqueued</code>然后把引用分别放入每个<code>ReferenceQueue</code>中，Over！</p><h3 id="MessageQueue"><a href="#MessageQueue" class="headerlink" title="MessageQueue"></a>MessageQueue</h3><p>MessageQueue用于Handle机制中传递消息，但是在Handle机制中我们关注的是<code>MessageQueue.next</code>方法的前半部分,<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Message <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">//get Message and return</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// If first time idle, then get the number of idlers to run.</span></span><br><span class="line">            <span class="comment">// Idle handles only run if the queue is empty or if the first message</span></span><br><span class="line">            <span class="comment">// in the queue (possibly a barrier) is due to be handled in the future.</span></span><br><span class="line">            <span class="keyword">if</span> (pendingIdleHandlerCount &lt; <span class="number">0</span></span><br><span class="line">                    &amp;&amp; (mMessages == <span class="keyword">null</span> || now &lt; mMessages.when)) &#123;</span><br><span class="line">                pendingIdleHandlerCount = mIdleHandlers.size();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pendingIdleHandlerCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// No idle handlers to run.  Loop and wait some more.</span></span><br><span class="line">                mBlocked = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mPendingIdleHandlers == <span class="keyword">null</span>) &#123;</span><br><span class="line">                mPendingIdleHandlers = <span class="keyword">new</span> IdleHandler[Math.max(pendingIdleHandlerCount, <span class="number">4</span>)];</span><br><span class="line">            &#125;</span><br><span class="line">            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Run the idle handlers.</span></span><br><span class="line">        <span class="comment">// We only ever reach this code block during the first iteration.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> IdleHandler idler = mPendingIdleHandlers[i];</span><br><span class="line">            mPendingIdleHandlers[i] = <span class="keyword">null</span>; <span class="comment">// release the reference to the handler</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">boolean</span> keep = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                keep = idler.queueIdle();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                Log.wtf(TAG, <span class="string">"IdleHandler threw exception"</span>, t);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!keep) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                    mIdleHandlers.remove(idler);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Reset the idle handler count to 0 so we do not run them again.</span></span><br><span class="line">        pendingIdleHandlerCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// While calling an idle handler, a new message could have been delivered</span></span><br><span class="line">        <span class="comment">// so go back and look again for a pending message without waiting.</span></span><br><span class="line">        nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面段代码就是在通过<code>next</code>没有获取到下一条<code>Message</code>时运行，整段代码整体就是一个观察者默认，其它对象可以注策<code>IdleHandler</code>到<code>MessageQueue</code>中，当<code>MessageQueue</code>中没有消息时则会调用<code>IdleHandler</code>的<code>queueIdle</code>方法。</p><p>什么时候<code>MessageQueue</code>为空？</p><ul><li>对于主线层来说，当页面渲染完成且没有新的交互时<code>MessageQueue</code>才会为空。</li><li>对于子线程，连续操作之后会有</li></ul><p>目前Glide使用<code>IdleHandler</code>来进行弱引用缓存key的清理</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;Glide杂记&quot;&gt;&lt;a href=&quot;#Glide杂记&quot; class=&quot;headerlink&quot; title=&quot;Glide杂记&quot;&gt;&lt;/a&gt;Glide杂记&lt;/h1&gt;&lt;p&gt;Glide使用过程加载过程主要有如下几个步骤&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;w
      
    
    </summary>
    
      <category term="Android" scheme="http://haojen.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://haojen.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Handler解析</title>
    <link href="http://haojen.github.io/2018/08/16/Handler%E8%A7%A3%E6%9E%90/"/>
    <id>http://haojen.github.io/2018/08/16/Handler解析/</id>
    <published>2018-08-16T05:42:58.000Z</published>
    <updated>2018-08-24T07:39:45.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Handler介绍"><a href="#Handler介绍" class="headerlink" title="Handler介绍"></a>Handler介绍</h1><p><code>Handler</code> 是 Android 下异步线程通讯的主要机制，关于 <code>Handler</code> 的简单介绍如下图所示</p><p><img src="./Handler.png" alt="Handler流程"></p><p>在 <code>Handler</code> 机制中，主要的参与对象以及关系在上图中已经很清晰了，我这里在简单介绍一下：</p><ul><li><p><code>Handler</code> 异步消息的发送者，也是消息的处理者，但是值得注意的是发送的处理可以在不同线程</p></li><li><p><code>MessageQueue</code> 线程安全的消息队列，线程的变换主要是在 <code>MessageQueue</code> 中完成</p></li><li><p><code>Messager</code> 异步通信内容的载体</p></li><li><p><code>Looper</code> 通过循环不断的从 <code>MessageQueue</code> 中获取消息，然后分发给 <code>Handler</code> 处理，和<code>MessageQueue</code> 是一一对应的关系</p></li></ul><p>简单的介绍到此为止，下面开始详细介绍整个消息发送过程。</p><h1 id="Handler消息机制"><a href="#Handler消息机制" class="headerlink" title="Handler消息机制"></a>Handler消息机制</h1><h2 id="Handler创建"><a href="#Handler创建" class="headerlink" title="Handler创建"></a>Handler创建</h2><p>针对 <code>Handler</code> 消息机制，我这边直接从 <code>Handler</code> 构造函数开始解析</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//内存泄漏警告</span></span><br><span class="line">......</span><br><span class="line">    <span class="comment">//获取Looper</span></span><br><span class="line">    mLooper = Looper.myLooper();</span><br><span class="line">    <span class="keyword">if</span> (mLooper == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">            <span class="string">"Can't create handler inside thread that has not called Looper.prepare()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mQueue = mLooper.mQueue;</span><br><span class="line">    mCallback = callback;</span><br><span class="line">    mAsynchronous = async;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Looper是通过ThreadLocal获取的线程私有的变量，但是默认为null</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="meta">@Nullable</span> <span class="function">Looper <span class="title">myLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sThreadLocal.get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建Looper对象并设置给ThreadLocal</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建MessageQueue对象</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Looper</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">    mQueue = <span class="keyword">new</span> MessageQueue(quitAllowed);</span><br><span class="line">    mThread = Thread.currentThread();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这一段代码看似很多，其实就是告诉我们如果想要创建 <code>Handler</code> 就得先有一个 <code>Looper</code> ,  <code>Looper</code> 是跟线程绑定的，创建 <code>Looper</code> 的同时它也会把 <code>MessageQueue</code> 也一起创建好，我们平时在主线程中的用的时候不要  <code>Looper</code> ,是因为主线程以及帮我们干了。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityThread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">.....</span><br><span class="line">        Looper.prepareMainLooper();</span><br><span class="line">        ......</span><br><span class="line">        Looper.loop();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Main thread loop unexpectedly exited"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到现在可以确定线程、<code>Looper</code> 、<code>Handler</code> 、<code>MessageQueue</code> 的关系如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph TB</span><br><span class="line">subgraph 线程</span><br><span class="line">MessageQueue --&gt; Looper</span><br><span class="line">Looper --&gt; Handler1</span><br><span class="line">Looper --&gt; Handler2</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h2 id="消息发送"><a href="#消息发送" class="headerlink" title="消息发送"></a>消息发送</h2><p>使用 <code>Handler</code> 发送消息可以有多种形式，<code>Handler.sendMessage()</code> 、<code>Message.sendToTarget()</code> 以及类似的一些方法都可以发送消息，但是不管是哪种方法最终都会调用<code>Handler.enqueueMessage()</code> 方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(MessageQueue queue, Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">    msg.target = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">if</span> (mAsynchronous) &#123;</span><br><span class="line">        <span class="comment">//发送异步消息</span></span><br><span class="line">        msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法也没有做太多逻辑处理，直接调用了 <code>MessageQueue</code> 的 <code>enqueueMessage</code> 方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(Message msg, <span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">       ......</span><br><span class="line">        msg.markInUse();</span><br><span class="line">        msg.when = when;</span><br><span class="line">        Message p = mMessages;</span><br><span class="line">        <span class="keyword">boolean</span> needWake;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</span><br><span class="line">            <span class="comment">// New head, wake up the event queue if blocked.</span></span><br><span class="line">            msg.next = p;</span><br><span class="line">            mMessages = msg;</span><br><span class="line">            needWake = mBlocked;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Inserted within the middle of the queue.  Usually we don't have to wake</span></span><br><span class="line">            <span class="comment">// up the event queue unless there is a barrier at the head of the queue</span></span><br><span class="line">            <span class="comment">// and the message is the earliest asynchronous message in the queue.</span></span><br><span class="line">            needWake = mBlocked &amp;&amp; p.target == <span class="keyword">null</span> &amp;&amp; msg.isAsynchronous();</span><br><span class="line">            Message prev;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                prev = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">                <span class="keyword">if</span> (p == <span class="keyword">null</span> || when &lt; p.when) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                    needWake = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            msg.next = p; <span class="comment">// invariant: p == prev.next</span></span><br><span class="line">            prev.next = msg;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We can assume mPtr != 0 because mQuitting is false.</span></span><br><span class="line">        <span class="keyword">if</span> (needWake) &#123;</span><br><span class="line">            nativeWake(mPtr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一段事实上就是一个单链表插入，<code>mMessages</code> 为链表头，如果链表为空则直接把 <code>msg</code> 赋给表头，否则通过循环找到链表最后进行插入。<code>MessageQueue</code> 的消息在 <code>Looper.loop()</code> 来获取并处理的。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Looper me = myLooper();</span><br><span class="line">    <span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"No Looper; Looper.prepare() wasn't called on this thread."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> MessageQueue queue = me.mQueue;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Make sure the identity of this thread is that of the local process,</span></span><br><span class="line">    <span class="comment">// and keep track of what that identity token actually is.</span></span><br><span class="line">    Binder.clearCallingIdentity();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> ident = Binder.clearCallingIdentity();</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Message msg = queue.next(); <span class="comment">// might block</span></span><br><span class="line">        <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// No message indicates that the message queue is quitting.</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// This must be in a local variable, in case a UI event sets the logger</span></span><br><span class="line">        <span class="keyword">final</span> Printer logging = me.mLogging;</span><br><span class="line">        <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</span><br><span class="line">            logging.println(<span class="string">"&gt;&gt;&gt;&gt;&gt; Dispatching to "</span> + msg.target + <span class="string">" "</span> +</span><br><span class="line">                            msg.callback + <span class="string">": "</span> + msg.what);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> slowDispatchThresholdMs = me.mSlowDispatchThresholdMs;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> traceTag = me.mTraceTag;</span><br><span class="line">        <span class="keyword">if</span> (traceTag != <span class="number">0</span> &amp;&amp; Trace.isTagEnabled(traceTag)) &#123;</span><br><span class="line">            Trace.traceBegin(traceTag, msg.target.getTraceName(msg));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> start = (slowDispatchThresholdMs == <span class="number">0</span>) ? <span class="number">0</span> :SystemClock.uptimeMillis();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> end;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            msg.target.dispatchMessage(msg);</span><br><span class="line">            end = (slowDispatchThresholdMs == <span class="number">0</span>) ? <span class="number">0</span> : SystemClock.uptimeMillis();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (traceTag != <span class="number">0</span>) &#123;</span><br><span class="line">                Trace.traceEnd(traceTag);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (slowDispatchThresholdMs &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> time = end - start;</span><br><span class="line">            <span class="keyword">if</span> (time &gt; slowDispatchThresholdMs) &#123;</span><br><span class="line">                Slog.w(TAG, <span class="string">"Dispatch took "</span> + time + <span class="string">"ms on "</span></span><br><span class="line">                       + Thread.currentThread().getName() + <span class="string">", h="</span> +</span><br><span class="line">                       msg.target + <span class="string">" cb="</span> + msg.callback + <span class="string">" msg="</span> + msg.what);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</span><br><span class="line">            logging.println(<span class="string">"&lt;&lt;&lt;&lt;&lt; Finished to "</span> + msg.target + <span class="string">" "</span> + msg.callback);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Make sure that during the course of dispatching the</span></span><br><span class="line">        <span class="comment">// identity of the thread wasn't corrupted.</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> newIdent = Binder.clearCallingIdentity();</span><br><span class="line">        <span class="keyword">if</span> (ident != newIdent) &#123;</span><br><span class="line">            Log.wtf(TAG, <span class="string">"Thread identity changed from 0x"</span></span><br><span class="line">                    + Long.toHexString(ident) + <span class="string">" to 0x"</span></span><br><span class="line">                    + Long.toHexString(newIdent) + <span class="string">" while dispatching to "</span></span><br><span class="line">                    + msg.target.getClass().getName() + <span class="string">" "</span></span><br><span class="line">                    + msg.callback + <span class="string">" what="</span> + msg.what);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        msg.recycleUnchecked();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>loop()</code> 方法主要就是在一个无限循环中不断的通过 <code>next</code> 获取消息，然后使用 <code>dispatchMessage</code> 把消息交回给Handler处理。现在我们回头来看 <code>next</code> 方法是如何获取消息的。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Message <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   ......</span><br><span class="line">    <span class="keyword">int</span> pendingIdleHandlerCount = -<span class="number">1</span>; <span class="comment">// -1 only during first iteration</span></span><br><span class="line">    <span class="keyword">int</span> nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nextPollTimeoutMillis != <span class="number">0</span>) &#123;</span><br><span class="line">            Binder.flushPendingCommands();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">// Try to retrieve the next message.  Return if found.</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">            Message prevMsg = <span class="keyword">null</span>;</span><br><span class="line">            Message msg = mMessages;</span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="keyword">null</span> &amp;&amp; msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// Stalled by a barrier.  Find the next asynchronous message in the queue.</span></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    prevMsg = msg;</span><br><span class="line">                    msg = msg.next;</span><br><span class="line">                &#125; <span class="keyword">while</span> (msg != <span class="keyword">null</span> &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (now &lt; msg.when) &#123;</span><br><span class="line">                    <span class="comment">// Next message is not ready.  Set a timeout to wake up when it is ready.</span></span><br><span class="line">                    nextPollTimeoutMillis = (<span class="keyword">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// Got a message.</span></span><br><span class="line">                    mBlocked = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (prevMsg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        prevMsg.next = msg.next;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        mMessages = msg.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    msg.next = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">"Returning message: "</span> + msg);</span><br><span class="line">                    msg.markInUse();</span><br><span class="line">                    <span class="keyword">return</span> msg;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// No more messages.</span></span><br><span class="line">                nextPollTimeoutMillis = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <code>next</code> 方法的主要逻辑都在一个无限循环内，知道获取到消息才会返回，同时把消息从链表中移除。同时默认获取的是链表头，只有当 <code>msg.target == null</code> 时才会获取链表后第一个同步消息，但是要知道我们通过 <code>Handler</code> 发送的消息 <code>target</code> 都是 <code>Handler</code> 本身，事实上这是消息屏障机制</p><h2 id="同步屏障"><a href="#同步屏障" class="headerlink" title="同步屏障"></a>同步屏障</h2><p>事实上消息分为同步和异步两种，通过 <code>isAsynchronous</code> 来判断，我们平时使用的一般是异步消息 ,同步消息主要用于页面绘制等对时间敏感的地方，但是在通常情况下即使我们使用 <code>setAsynchronous(true)</code> 来手动设置一个同步消息它也不会生效，<code>MessageQueue</code> 还是会把他当作普通消息处理，只有配合 <code>postSyncBarrier</code> 添加一个同步屏障之后才能使用。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">postSyncBarrier</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> postSyncBarrier(SystemClock.uptimeMillis());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">postSyncBarrier</span><span class="params">(<span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Enqueue a new sync barrier token.</span></span><br><span class="line">    <span class="comment">// We don't need to wake the queue because the purpose of a barrier is to stall it.</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> token = mNextBarrierToken++;</span><br><span class="line">        <span class="keyword">final</span> Message msg = Message.obtain();</span><br><span class="line">        msg.markInUse();</span><br><span class="line">        msg.when = when;</span><br><span class="line">        msg.arg1 = token;</span><br><span class="line"></span><br><span class="line">        Message prev = <span class="keyword">null</span>;</span><br><span class="line">        Message p = mMessages;</span><br><span class="line">        <span class="keyword">if</span> (when != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; p.when &lt;= when) &#123;</span><br><span class="line">                prev = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123; <span class="comment">// invariant: p == prev.next</span></span><br><span class="line">            msg.next = p;</span><br><span class="line">            prev.next = msg;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            msg.next = p;</span><br><span class="line">            mMessages = msg;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> token;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>postSyncBarrier</code> 是一个隐藏 Api，我们无法调用，但这不妨碍我们分析它，它直接向 <code>MessageQueue</code> 的单链表中头插入了一个 <code>target==null</code> 的消息，也就是上一节 <code>next</code> 方法中的逻辑，当这种情况下，<code>MessageQueue</code> 会忽略所有的异步消息，只获取同步消息，需要调用 <code>removeSyncBarrier(int token)</code> 才能取消这个同步屏障，目前同步屏障主要是在 <code>ViewRootImpl</code> 绘制时使用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Handler介绍&quot;&gt;&lt;a href=&quot;#Handler介绍&quot; class=&quot;headerlink&quot; title=&quot;Handler介绍&quot;&gt;&lt;/a&gt;Handler介绍&lt;/h1&gt;&lt;p&gt;&lt;code&gt;Handler&lt;/code&gt; 是 Android 下异步线程通讯的主要机
      
    
    </summary>
    
      <category term="Android" scheme="http://haojen.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://haojen.github.io/tags/Android/"/>
    
      <category term="Handler" scheme="http://haojen.github.io/tags/Handler/"/>
    
  </entry>
  
  <entry>
    <title>RecyclerView源码详解</title>
    <link href="http://haojen.github.io/2018/07/30/RecyclerView%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3/"/>
    <id>http://haojen.github.io/2018/07/30/RecyclerView源码详解/</id>
    <published>2018-07-30T08:58:48.000Z</published>
    <updated>2018-08-24T07:39:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p><strong>免责声明：</strong> 这篇文章还没有写完，发布的原因是因为我懒的放到草稿箱了，如有错误或者以后请勿怪</p><h1 id="RecyclerView介绍"><a href="#RecyclerView介绍" class="headerlink" title="RecyclerView介绍"></a>RecyclerView介绍</h1><p><code>RecyclerView</code> 是Google support-v7包中的控件，用于提供一个列表的显示，和 <code>ListView</code> 类似，但是比 <code>ListView</code> 更高级也更具扩展性，它更倾向于使用一个模块化的方式来使用多个模块共同实现一个复杂的列表控件，<code>RecyclerView</code>主要由如下几个组件构成</p><ul><li><p><code>LayoutManager</code> 用于控制List子View的测量和布局</p></li><li><p><code>Adapter</code> 和 <code>ListView</code> 中的Adapter功能类似，但是已经预先添加了 <code>ViewHolder</code> ,不需要我们手动添加</p></li><li><p><code>ItemDecoration</code> 用于控制和显示分割线</p></li><li><p><code>ItemAnimator</code> 用于实现Item显示消失时动画效果</p></li></ul><p>当然除了上面所说的这些模块之外，<code>RecyclerView</code> 还把很多其他的功能也都拆分了出来，这里就不一一列举，文中遇到了在做说明。</p><h1 id="LayoutManager"><a href="#LayoutManager" class="headerlink" title="LayoutManager"></a>LayoutManager</h1><p><code>LayoutManager</code> 相当于把本身View应该完成的测量和布局过程抽离出来单独处理，而这两个步骤也是决定一个View显示效果的重要步骤，因此同一个 <code>RecyclerView</code> 完全可以通过不同的 <code>LayoutManager</code> 实现不同的显示效果，而不是使用不同的控件。</p><p>  目前Google已经预先提供好了几种 <code>LayoutManager</code> ,分别如下所示</p><ul><li><p><code>LinearLayoutManager</code> 实现类似 <code>ListView</code> 列表样式的布局</p></li><li><p><code>GridLayoutManager</code> 实现类似 <code>GridView</code> 网格样式的布局</p></li><li><p><code>StaggeredGridLayoutManager</code> 实现了瀑布流样式的布局</p></li></ul><p>我们以 <code>LinearLayoutManager</code> 为例来说明 <code>LayoutManager</code> 在 <code>RecyclerView</code> 中的重要作用，首先先说明一下 <code>LinearLayoutManager</code> 中的两个辅助类，这两个类在 <code>LinearLayoutManager</code> 的工作中也起着一定作用</p><ul><li><code>AnchorInfo</code> 布局的锚点，在测量和布局过程中 <code>LinearLayoutManager</code> 都是先确定一个锚点位置，然后根据锚点，分别向上和向下去测量和布局子 <code>View</code></li><li><code>LayoutState</code> 是 <code>LinearLayoutManager</code> 在填充整体布局的帮助类，他可以通过一个给定的方向获取下一个需要填充的 <code>View</code></li></ul><h2 id="onMeasure"><a href="#onMeasure" class="headerlink" title="onMeasure"></a>onMeasure</h2><p>我们都知道控件的展示主要分为测量、布局、绘制等三个阶段进行，我们首先关注 <code>RecyclerView</code> 的测量过程。代码片段会省略部分代码和注释</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthSpec, <span class="keyword">int</span> heightSpec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mLayout == <span class="keyword">null</span>) &#123;</span><br><span class="line">        defaultOnMeasure(widthSpec, heightSpec);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//isAutoMeasureEnabled方法返回false，表示必须要重写LayoutManager的onMeasure方法，完成测量</span></span><br><span class="line">    <span class="comment">//如果设置为true，则表示由RecyclerView的AutoMeasure机制完成测量</span></span><br><span class="line">    <span class="comment">//LinearLayoutManager已经重写了这个方法，永久返回true</span></span><br><span class="line">    <span class="keyword">if</span> (mLayout.isAutoMeasureEnabled()) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> widthMode = MeasureSpec.getMode(widthSpec);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> heightMode = MeasureSpec.getMode(heightSpec);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里看似调用了LayoutManager的onMeasure，但是LinearLayoutManager没有重写这个方法，</span></span><br><span class="line">        <span class="comment">//因此这个最终是调用了RecyclerView自己默认的方法</span></span><br><span class="line">        mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//RecyclerView固定宽高或者Match_Parent的情况下measureSpecModeIsExactly为true</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> measureSpecModeIsExactly =</span><br><span class="line">            widthMode == MeasureSpec.EXACTLY &amp;&amp; heightMode == MeasureSpec.EXACTLY;</span><br><span class="line">        <span class="comment">//即如果RecyclerView的宽高不是Wrap_Content，到这里测量过程就结束了</span></span><br><span class="line">        <span class="keyword">if</span> (measureSpecModeIsExactly || mAdapter == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//mState是RecyclerView的State对象，这个对象存储了当前RecyclerView的各种状态</span></span><br><span class="line">        <span class="comment">//在RecyclerView中各个组件的交互也是通过State对象来进行的</span></span><br><span class="line">        <span class="comment">//mState初始mLayoutStep为STEP_START</span></span><br><span class="line">        <span class="keyword">if</span> (mState.mLayoutStep == State.STEP_START) &#123;</span><br><span class="line">            <span class="comment">//dispatchLayoutStep1主要对RecyclerView的动画做了处理，没有绘制流程</span></span><br><span class="line">            <span class="comment">//后续在动画中在做说明</span></span><br><span class="line">            dispatchLayoutStep1();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这里widthSpec和heightSpec是RecyclerView默认测量的结果</span></span><br><span class="line">        mLayout.setMeasureSpecs(widthSpec, heightSpec);</span><br><span class="line">        mState.mIsMeasuring = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//实际的测量，会测量childView</span></span><br><span class="line">        dispatchLayoutStep2();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// now we can get the width and height from the children.</span></span><br><span class="line">        mLayout.setMeasuredDimensionFromChildren(widthSpec, heightSpec);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// if RecyclerView has non-exact width and height and if there is at least one child</span></span><br><span class="line">        <span class="comment">// which also has non-exact width &amp; height, we have to re-measure.</span></span><br><span class="line">        <span class="keyword">if</span> (mLayout.shouldMeasureTwice()) &#123;</span><br><span class="line">            mLayout.setMeasureSpecs(</span><br><span class="line">                MeasureSpec.makeMeasureSpec(getMeasuredWidth(), MeasureSpec.EXACTLY),</span><br><span class="line">                MeasureSpec.makeMeasureSpec(getMeasuredHeight(), MeasureSpec.EXACTLY));</span><br><span class="line">            mState.mIsMeasuring = <span class="keyword">true</span>;</span><br><span class="line">            dispatchLayoutStep2();</span><br><span class="line">            <span class="comment">// now we can get the width and height from the children.</span></span><br><span class="line">            mLayout.setMeasuredDimensionFromChildren(widthSpec, heightSpec);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在 <code>onMeasure</code> 方法中，如果我们给 <code>RecyclerView</code> 设置了不是 <code>Wrap_Content</code> 的宽高，那么 <code>RecyclerView</code> 的测量过程很简单，直接使用父控件给定的宽高即可，只有当我们设置为 <code>Wrap_Content</code> 时，才需要先去测量子 View 。</p><p>测量子 View 的过程事实上是在 <code>dispatchLayoutStep2</code> 方法中进行的，这个方法事实上是 Layout 时调用的方法，这个不难理解，因为只有在确定了 Layout 的方式时，才能真正确定子 View 需要多少的屏幕空间</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatchLayoutStep2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    startInterceptRequestLayout();</span><br><span class="line">    onEnterLayoutOrScroll();</span><br><span class="line">    mState.assertLayoutStep(State.STEP_LAYOUT | State.STEP_ANIMATIONS);</span><br><span class="line">    mAdapterHelper.consumeUpdatesInOnePass();</span><br><span class="line">    mState.mItemCount = mAdapter.getItemCount();</span><br><span class="line">    mState.mDeletedInvisibleItemCountSincePreviousLayout = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 2: Run layout</span></span><br><span class="line">    mState.mInPreLayout = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//上述代码基本上就是在往mState中填充RecyclerView的信息，上段代码的注释中也提到State的</span></span><br><span class="line">    <span class="comment">//主要功能就是在RecyclerView各组件间传递信息</span></span><br><span class="line">    mLayout.onLayoutChildren(mRecycler, mState);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>dispatchLayoutStep2</code> 主要的功能就是为 <code>mState</code> 的更新了一些 <code>RecyclerView</code> 的最新状态，然后调用了 <code>LayoutManager</code> 的 <code>onLayoutChildren</code> 方法，值得注意的是这个方法和上个方法一样是用于布局的，所以后面还会调用，这里暂时只说明测量的部分。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLayoutChildren</span><span class="params">(RecyclerView.Recycler recycler, RecyclerView.State state)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//计算锚点信息以及获取边缘的extraSpace，锚点初始化时一般是方向上的第一个View（反转的列表则为最后）</span></span><br><span class="line">    <span class="comment">//细节代码有兴趣可以自行研究</span></span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (mAnchorInfo.mLayoutFromEnd) &#123;</span><br><span class="line">        <span class="comment">// fill towards start</span></span><br><span class="line">        <span class="comment">//通过锚点更新LayoutState信息,更新后LayoutState.next会向上寻找View</span></span><br><span class="line">        updateLayoutStateToFillStart(mAnchorInfo);</span><br><span class="line">        mLayoutState.mExtra = extraForStart;</span><br><span class="line">        fill(recycler, mLayoutState, state, <span class="keyword">false</span>);</span><br><span class="line">        startOffset = mLayoutState.mOffset;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> firstElement = mLayoutState.mCurrentPosition;</span><br><span class="line">        <span class="keyword">if</span> (mLayoutState.mAvailable &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            extraForEnd += mLayoutState.mAvailable;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// fill towards end</span></span><br><span class="line">        <span class="comment">//通过锚点更新LayoutState信息,更新后LayoutState.next会向下寻找View</span></span><br><span class="line">        updateLayoutStateToFillEnd(mAnchorInfo);</span><br><span class="line">        mLayoutState.mExtra = extraForEnd;</span><br><span class="line">        mLayoutState.mCurrentPosition += mLayoutState.mItemDirection;</span><br><span class="line">        fill(recycler, mLayoutState, state, <span class="keyword">false</span>);</span><br><span class="line">        endOffset = mLayoutState.mOffset;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mLayoutState.mAvailable &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// end could not consume all. add more items towards start</span></span><br><span class="line">            extraForStart = mLayoutState.mAvailable;</span><br><span class="line">            updateLayoutStateToFillStart(firstElement, startOffset);</span><br><span class="line">            mLayoutState.mExtra = extraForStart;</span><br><span class="line">            fill(recycler, mLayoutState, state, <span class="keyword">false</span>);</span><br><span class="line">            startOffset = mLayoutState.mOffset;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//这段代码几乎和上段一样，只是填充的方向不同</span></span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中可以看出在 <code>onLayoutChildren</code> 过程中，<code>LinearLayoutManager</code> 是首先确定一个锚点，然后从锚点位置开始向不同方向填充布局。真正的填充部分代码在 <code>fill</code> 方法中</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fill</span><span class="params">(RecyclerView.Recycler recycler, LayoutState layoutState,</span></span></span><br><span class="line"><span class="function"><span class="params">            RecyclerView.State state, <span class="keyword">boolean</span> stopOnFocusable)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// bug修复代码</span></span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//mAvailable是上面的方法中由锚点更新给layoutState的，为指定指定方向上需要填充的距离</span></span><br><span class="line">    <span class="comment">//mExtra也是前面计算的边缘的extraSpace，</span></span><br><span class="line">    <span class="keyword">int</span> remainingSpace = layoutState.mAvailable + layoutState.mExtra;</span><br><span class="line">    LayoutChunkResult layoutChunkResult = mLayoutChunkResult;</span><br><span class="line">    <span class="comment">//由于最开始onMeasure的时候先调用了RecyclerView默认的onMeasure方法，所以这里remainingSpace</span></span><br><span class="line">    <span class="comment">//就是能Recycler能取到的最大值</span></span><br><span class="line">    <span class="keyword">while</span> ((layoutState.mInfinite || remainingSpace &gt; <span class="number">0</span>) &amp;&amp; layoutState.hasMore(state)) &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">//核心代码，用于计算子View需要的空间</span></span><br><span class="line">        layoutChunk(recycler, state, layoutState, layoutChunkResult);</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">//根据layoutChunkResult缩减remainingSpace大小</span></span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> start - layoutState.mAvailable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在 <code>fill</code> 方法中起着比较核心作用的是 <code>layoutChunk</code> 方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">layoutChunk</span><span class="params">(RecyclerView.Recycler recycler, RecyclerView.State state,</span></span></span><br><span class="line"><span class="function"><span class="params">            LayoutState layoutState, LayoutChunkResult result)</span> </span>&#123;</span><br><span class="line">    View view = layoutState.next(recycler);</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//测量ChildView</span></span><br><span class="line">    measureChildWithMargins(view, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    result.mConsumed = mOrientationHelper.getDecoratedMeasurement(view);</span><br><span class="line">    <span class="keyword">int</span> left, top, right, bottom;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//布局ChildView</span></span><br><span class="line">    layoutDecoratedWithMargins(view, left, top, right, bottom);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码其实很清楚了，<code>layoutChunk</code> 方法首先获取的 <code>ChildView</code> ，对它进行测量，然后布局。恩，你没有看错就是布局 <code>Layout</code> ，通过布局方法确定 <code>ChildView</code> 的具体位置，<code>dispatchLayoutStep2</code>方法的深入展开到此结束，让我们回到 <code>onMeasure</code> 的地方在看一下我们没有看完的代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthSpec, <span class="keyword">int</span> heightSpec)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (mLayout.isAutoMeasureEnabled()) &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">//上次的代码到这了</span></span><br><span class="line">        dispatchLayoutStep2();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过ChildView的位置综合父控件给的widthSpec和heightSpec选择合适的宽高</span></span><br><span class="line">        mLayout.setMeasuredDimensionFromChildren(widthSpec, heightSpec);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//重新进行测量，对于LinearLayoutManager来说中如果本身是WARP_CONTENT，</span></span><br><span class="line">        <span class="comment">//同时至少有一个ChildView有不确定（WRAP_CONTENT或者MATCH_PARENT）的宽和高</span></span><br><span class="line">        <span class="keyword">if</span> (mLayout.shouldMeasureTwice()) &#123;</span><br><span class="line">            <span class="comment">//重新走一遍上面的测量</span></span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setMeasuredDimensionFromChildren</span><span class="params">(<span class="keyword">int</span> widthSpec, <span class="keyword">int</span> heightSpec)</span> </span>&#123;</span><br><span class="line">  ......</span><br><span class="line">    <span class="comment">//遍历ChildView，选出坐上右下四个值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        View child = getChildAt(i);</span><br><span class="line">        <span class="keyword">final</span> Rect bounds = mRecyclerView.mTempRect;</span><br><span class="line">        getDecoratedBoundsWithMargins(child, bounds);</span><br><span class="line">        <span class="keyword">if</span> (bounds.left &lt; minX) &#123;</span><br><span class="line">            minX = bounds.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (bounds.right &gt; maxX) &#123;</span><br><span class="line">            maxX = bounds.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (bounds.top &lt; minY) &#123;</span><br><span class="line">            minY = bounds.top;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (bounds.bottom &gt; maxY) &#123;</span><br><span class="line">            maxY = bounds.bottom;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mRecyclerView.mTempRect.set(minX, minY, maxX, maxY);</span><br><span class="line">    <span class="comment">//根据获得的Rect范围综合父控件给的值综合获取最终的宽高</span></span><br><span class="line">    setMeasuredDimension(mRecyclerView.mTempRect, widthSpec, heightSpec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了到此为止，整个测量过程基本上清楚了，下面我们根据一张时序图回顾一下整个流程</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">participant RecyclerView as A</span><br><span class="line">participant LinearLayoutManager as B</span><br><span class="line">A-&gt;A:onMeasure</span><br><span class="line">A-&gt;B:isAutoMeasureEnabled</span><br><span class="line">A-&gt;A:dispatchLayoutStep2</span><br><span class="line">A-&gt;B:onLayoutChildren</span><br><span class="line">B-&gt;B:fill</span><br><span class="line">B-&gt;B:layoutChunk</span><br><span class="line">B-&gt;B:measureChildWithMargins</span><br><span class="line">B-&gt;B:layoutDecoratedWithMargins</span><br><span class="line">A-&gt;B:setMeasuredDimensionFromChildren</span><br><span class="line">A-&gt;B:shouldMeasureTwice</span><br><span class="line">B-&gt;B:calculate measurezise......</span><br><span class="line">B-&gt;A:setMeasuredDimension</span><br></pre></td></tr></table></figure><p>可以看出 <code>RecyclerView</code> 在整个测量过程还是整个流程的主导，<code>LayoutManager</code> 更多像是一个提供具体配置参数的。这个表可以作为我们自定义 <code>LayoutManager</code> 时的一个参考。</p><h3 id="onLayout"><a href="#onLayout" class="headerlink" title="onLayout"></a>onLayout</h3><p>继续看布局的相关方法，首先从 <code>RecyclerView</code> 的 <code>onLayout</code> 方法开始</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    TraceCompat.beginSection(TRACE_ON_LAYOUT_TAG);</span><br><span class="line">    <span class="comment">//直接调用了dispatchLayout</span></span><br><span class="line">    dispatchLayout();</span><br><span class="line">    TraceCompat.endSection();</span><br><span class="line">    mFirstLayoutComplete = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatchLayout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mAdapter == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mLayout == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mState.mIsMeasuring = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//mLayoutStep初始为STEP_START，然后会在dispatchLayoutStep1方法修改为STEP_LAYOUT</span></span><br><span class="line">    <span class="comment">//然后在dispatchLayoutStep2方法中修改为STEP_ANIMATIONS</span></span><br><span class="line">    <span class="comment">//除非若RecyclerView宽高为Wrap_Content，否则此处为STEP_START</span></span><br><span class="line">    <span class="keyword">if</span> (mState.mLayoutStep == State.STEP_START) &#123;</span><br><span class="line">        <span class="comment">//完成一次完整的测量布局</span></span><br><span class="line">        dispatchLayoutStep1();</span><br><span class="line">        mLayout.setExactMeasureSpecsFrom(<span class="keyword">this</span>);</span><br><span class="line">        dispatchLayoutStep2();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mAdapterHelper.hasUpdates() || mLayout.getWidth() != getWidth()</span><br><span class="line">               || mLayout.getHeight() != getHeight()) &#123;</span><br><span class="line">        <span class="comment">//测量布局已经但是，种种原因，大小改变了，需要重新测量布局</span></span><br><span class="line">        <span class="comment">//这个方法把RecyclerView的测量宽高以一EXACTLY的形式给了LayoutManager</span></span><br><span class="line">        mLayout.setExactMeasureSpecsFrom(<span class="keyword">this</span>);</span><br><span class="line">        dispatchLayoutStep2();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// always make sure we sync them (to ensure mode is exact)</span></span><br><span class="line">        mLayout.setExactMeasureSpecsFrom(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    dispatchLayoutStep3();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>onLayout</code> 中 <code>RecyclerView</code> 并没有做什么多余的操作，而是直接调用了 <code>dispatchLayout</code> 方法，这个方法会根据我们在 <code>onMeasure</code> 中的行为判断是否需要调用 <code>dispatchLayoutStep1</code> 和 <code>dispatchLayoutStep2</code> ，但是无论哪种情况都会通过 <code>setExactMeasureSpecsFrom</code> 给 <code>LayoutManager</code> 设置一个确切的宽高，最后调用 <code>dispatchLayoutStep3</code> 方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatchLayoutStep3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//STEP_ANIMATIONS状态就可以看出来，这个方法主要是完成前面dispatchLayoutStep1中</span></span><br><span class="line">    <span class="comment">//设置好的动画</span></span><br><span class="line">    mState.assertLayoutStep(State.STEP_ANIMATIONS);</span><br><span class="line">    startInterceptRequestLayout();</span><br><span class="line">    onEnterLayoutOrScroll();</span><br><span class="line">    mState.mLayoutStep = State.STEP_START;</span><br><span class="line">    <span class="keyword">if</span> (mState.mRunSimpleAnimations) &#123;</span><br><span class="line">        <span class="comment">//这个整段代码全都是动画相关的</span></span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一些状态的置位和资源的释放</span></span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (mLayout.mPrefetchMaxObservedInInitialPrefetch) &#123;</span><br><span class="line">        <span class="comment">// Initial prefetch has expanded cache, so reset until next prefetch.</span></span><br><span class="line">        <span class="comment">// This prevents initial prefetches from expanding the cache permanently.</span></span><br><span class="line">        mLayout.mPrefetchMaxCountObserved = <span class="number">0</span>;</span><br><span class="line">        mLayout.mPrefetchMaxObservedInInitialPrefetch = <span class="keyword">false</span>;</span><br><span class="line">        mRecycler.updateViewCacheSize();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里也是一样，部分状态的初始化</span></span><br><span class="line">    mLayout.onLayoutCompleted(mState);</span><br><span class="line">    onExitLayoutOrScroll();</span><br><span class="line">    stopInterceptRequestLayout(<span class="keyword">false</span>);</span><br><span class="line">    mViewInfoStore.clear();</span><br><span class="line">    <span class="keyword">if</span> (didChildRangeChange(mMinMaxLayoutPositions[<span class="number">0</span>], mMinMaxLayoutPositions[<span class="number">1</span>])) &#123;</span><br><span class="line">        dispatchOnScrolled(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    recoverFocusFromState();</span><br><span class="line">    resetFocusInfo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>￼<img src="./153.jpg" alt=""></p><p>这就结束了？，没错到此为止 <code>LinearLayoutManager</code> 或者说 <code>RecyclerView</code> 的 auto measure 就是这样的，当然 <code>LayoutManager</code> 还有一些其他功能这里还没有涉及到或者没有展开，后面遇到再进行说明。</p><h1 id="Recycler"><a href="#Recycler" class="headerlink" title="Recycler"></a>Recycler</h1><p>按照顺序这里应该是本应该是 <code>Adapter</code> ，但是我发现如果没有 <code>Recycler</code> 存在 <code>Adapter</code> 根本玩不下去，看名字 <code>Recycler</code> 就感觉像是 <code>RecyclerView</code> 的核心，确实它也掌管了所有 <code>ChildView</code> 的生成、复用、回收，确实也是核心，首先我们介绍一下 <code>Recycler</code> 中的几个缓存队列</p><ul><li><p><code>mChangedScrap</code> item被标记为更新、有动画且动画支持变化</p></li><li><p><code>mAttachedScrap</code> </p></li><li><code>mCachedViews</code></li></ul><p><code>Recycler</code> 也还是得从测量过程中的 <code>LayoutChunk</code> 说起，虽然这个 <code>Recycler</code> 对象在一开始 <code>onLayoutChildren</code> 就作为参数传递到了 <code>LayoutManager</code> ，但是一直没有正经的使用它。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">layoutChunk</span><span class="params">(RecyclerView.Recycler recycler, RecyclerView.State state,</span></span></span><br><span class="line"><span class="function"><span class="params">            LayoutState layoutState, LayoutChunkResult result)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//从LayoutState中获取下一个View</span></span><br><span class="line">    View view = layoutState.next(recycler);</span><br><span class="line">    <span class="keyword">if</span> (view == <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="comment">//说明已经没有更多的View，到底或者到顶了</span></span><br><span class="line">        result.mFinished = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LayoutParams params = (LayoutParams) view.getLayoutParams();</span><br><span class="line">    <span class="comment">//mScrapList一般情况下都为null，只有在为动画做准备时才会有内存</span></span><br><span class="line">    <span class="keyword">if</span> (layoutState.mScrapList == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mShouldReverseLayout == (layoutState.mLayoutDirection</span><br><span class="line">                                     == LayoutState.LAYOUT_START)) &#123;</span><br><span class="line">            addView(view);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            addView(view, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//暂时可以不考虑</span></span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">   measureChildWithMargins(view, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">View <span class="title">next</span><span class="params">(RecyclerView.Recycler recycler)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//mScrapList一般情况下都为null，这里暂不考虑</span></span><br><span class="line">    <span class="keyword">if</span> (mScrapList != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> nextViewFromScrapList();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//调用了getViewForPosition来获取真正View</span></span><br><span class="line">    <span class="keyword">final</span> View view = recycler.getViewForPosition(mCurrentPosition);</span><br><span class="line">    mCurrentPosition += mItemDirection;</span><br><span class="line">    <span class="keyword">return</span> view;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> View <span class="title">getViewForPosition</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getViewForPosition(position, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">View <span class="title">getViewForPosition</span><span class="params">(<span class="keyword">int</span> position, <span class="keyword">boolean</span> dryRun)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> tryGetViewHolderForPositionByDeadline(position, dryRun, FOREVER_NS).itemView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>layoutChunk</code> 根本意义上说也还没有使用 <code>Recycler</code> 对象，但是这里算上获取 <code>childView</code> 的一个起点，所以我们从这里开始分析，后续的几个方法也都没有做太多工作。到了 <code>tryGetViewHolderForPositionByDeadline</code> 真正的逻辑开始了。代码之前我们先整理一下逻辑，这个方法的的主要工作如下</p><ol><li>如果进行了 <code>PreLayout</code> 则会优先从 <code>mChangedScrap</code> 中查找 <code>ViewHolder</code> , <code>PreLayout</code> 这个行为发生在 <code>dispatchLayoutStep1</code> 中，虽然是 <code>PreLayout</code> 但是终究还是会去 <code>onLayoutChildren</code> ，然后最后还是会调用 <code>tryGetViewHolderForPositionByDeadline</code> ，所以本质上来说第一次来步骤1肯定会跳过 </li><li></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">ViewHolder <span class="title">tryGetViewHolderForPositionByDeadline</span><span class="params">(<span class="keyword">int</span> position,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">boolean</span> dryRun, <span class="keyword">long</span> deadlineNs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (position &lt; <span class="number">0</span> || position &gt;= mState.getItemCount()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(...);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> fromScrapOrHiddenOrCache = <span class="keyword">false</span>;</span><br><span class="line">    ViewHolder holder = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 0) If there is a changed scrap, try to find from there</span></span><br><span class="line">    <span class="keyword">if</span> (mState.isPreLayout()) &#123;</span><br><span class="line">        holder = getChangedScrapViewForPosition(position);</span><br><span class="line">        fromScrapOrHiddenOrCache = holder != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1) Find by position from scrap/hidden list/cache</span></span><br><span class="line">    <span class="keyword">if</span> (holder == <span class="keyword">null</span>) &#123;</span><br><span class="line">        holder = getScrapOrHiddenOrCachedHolderForPosition(position, dryRun);</span><br><span class="line">        <span class="keyword">if</span> (holder != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!validateViewHolderForOffsetPosition(holder)) &#123;</span><br><span class="line">                <span class="comment">// recycle holder (and unscrap if relevant) since it can't be used</span></span><br><span class="line">                <span class="keyword">if</span> (!dryRun) &#123;</span><br><span class="line">                    <span class="comment">// we would like to recycle this but need to make sure it is not used by</span></span><br><span class="line">                    <span class="comment">// animation logic etc.</span></span><br><span class="line">                    holder.addFlags(ViewHolder.FLAG_INVALID);</span><br><span class="line">                    <span class="keyword">if</span> (holder.isScrap()) &#123;</span><br><span class="line">                        removeDetachedView(holder.itemView, <span class="keyword">false</span>);</span><br><span class="line">                        holder.unScrap();</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (holder.wasReturnedFromScrap()) &#123;</span><br><span class="line">                        holder.clearReturnedFromScrapFlag();</span><br><span class="line">                    &#125;</span><br><span class="line">                    recycleViewHolderInternal(holder);</span><br><span class="line">                &#125;</span><br><span class="line">                holder = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                fromScrapOrHiddenOrCache = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (holder == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> offsetPosition = mAdapterHelper.findPositionOffset(position);</span><br><span class="line">        <span class="keyword">if</span> (offsetPosition &lt; <span class="number">0</span> || offsetPosition &gt;= mAdapter.getItemCount()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(...);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> type = mAdapter.getItemViewType(offsetPosition);</span><br><span class="line">        <span class="comment">// 2) Find from scrap/cache via stable ids, if exists</span></span><br><span class="line">        <span class="keyword">if</span> (mAdapter.hasStableIds()) &#123;</span><br><span class="line">            holder = getScrapOrCachedViewForId(mAdapter.getItemId(offsetPosition),</span><br><span class="line">                                               type, dryRun);</span><br><span class="line">            <span class="keyword">if</span> (holder != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// update position</span></span><br><span class="line">                holder.mPosition = offsetPosition;</span><br><span class="line">                fromScrapOrHiddenOrCache = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (holder == <span class="keyword">null</span> &amp;&amp; mViewCacheExtension != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// We are NOT sending the offsetPosition because LayoutManager does not</span></span><br><span class="line">            <span class="comment">// know it.</span></span><br><span class="line">            <span class="keyword">final</span> View view = mViewCacheExtension</span><br><span class="line">                .getViewForPositionAndType(<span class="keyword">this</span>, position, type);</span><br><span class="line">            <span class="keyword">if</span> (view != <span class="keyword">null</span>) &#123;</span><br><span class="line">                holder = getChildViewHolder(view);</span><br><span class="line">                <span class="keyword">if</span> (holder == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(...);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (holder.shouldIgnore()) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(...);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (holder == <span class="keyword">null</span>) &#123; <span class="comment">// fallback to pool</span></span><br><span class="line">           </span><br><span class="line">            holder = getRecycledViewPool().getRecycledView(type);</span><br><span class="line">            <span class="keyword">if</span> (holder != <span class="keyword">null</span>) &#123;</span><br><span class="line">                holder.resetInternal();</span><br><span class="line">                <span class="keyword">if</span> (FORCE_INVALIDATE_DISPLAY_LIST) &#123;</span><br><span class="line">                    invalidateDisplayListInt(holder);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (holder == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> start = getNanoTime();</span><br><span class="line">            <span class="keyword">if</span> (deadlineNs != FOREVER_NS</span><br><span class="line">                &amp;&amp; !mRecyclerPool.willCreateInTime(type, start, deadlineNs)) &#123;</span><br><span class="line">                <span class="comment">// abort - we have a deadline we can't meet</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            holder = mAdapter.createViewHolder(RecyclerView.<span class="keyword">this</span>, type);</span><br><span class="line">            <span class="keyword">if</span> (ALLOW_THREAD_GAP_WORK) &#123;</span><br><span class="line">                <span class="comment">// only bother finding nested RV if prefetching</span></span><br><span class="line">                RecyclerView innerView = findNestedRecyclerView(holder.itemView);</span><br><span class="line">                <span class="keyword">if</span> (innerView != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    holder.mNestedRecyclerView = <span class="keyword">new</span> WeakReference&lt;&gt;(innerView);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">long</span> end = getNanoTime();</span><br><span class="line">            mRecyclerPool.factorInCreateTime(type, end - start);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This is very ugly but the only place we can grab this information</span></span><br><span class="line">    <span class="comment">// before the View is rebound and returned to the LayoutManager for post layout ops.</span></span><br><span class="line">    <span class="comment">// We don't need this in pre-layout since the VH is not updated by the LM.</span></span><br><span class="line">    <span class="keyword">if</span> (fromScrapOrHiddenOrCache &amp;&amp; !mState.isPreLayout() &amp;&amp; holder</span><br><span class="line">        .hasAnyOfTheFlags(ViewHolder.FLAG_BOUNCED_FROM_HIDDEN_LIST)) &#123;</span><br><span class="line">        holder.setFlags(<span class="number">0</span>, ViewHolder.FLAG_BOUNCED_FROM_HIDDEN_LIST);</span><br><span class="line">        <span class="keyword">if</span> (mState.mRunSimpleAnimations) &#123;</span><br><span class="line">            <span class="keyword">int</span> changeFlags = ItemAnimator</span><br><span class="line">                .buildAdapterChangeFlagsForAnimations(holder);</span><br><span class="line">            changeFlags |= ItemAnimator.FLAG_APPEARED_IN_PRE_LAYOUT;</span><br><span class="line">            <span class="keyword">final</span> ItemHolderInfo info = mItemAnimator.recordPreLayoutInformation(mState,</span><br><span class="line">                                                                                 holder, changeFlags, holder.getUnmodifiedPayloads());</span><br><span class="line">            recordAnimationInfoIfBouncedHiddenView(holder, info);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> bound = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (mState.isPreLayout() &amp;&amp; holder.isBound()) &#123;</span><br><span class="line">        <span class="comment">// do not update unless we absolutely have to.</span></span><br><span class="line">        holder.mPreLayoutPosition = position;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!holder.isBound() || holder.needsUpdate() || holder.isInvalid()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG &amp;&amp; holder.isRemoved()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(...);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> offsetPosition = mAdapterHelper.findPositionOffset(position);</span><br><span class="line">        bound = tryBindViewHolderByDeadline(holder, offsetPosition, position, deadlineNs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ViewGroup.LayoutParams lp = holder.itemView.getLayoutParams();</span><br><span class="line">    <span class="keyword">final</span> LayoutParams rvLayoutParams;</span><br><span class="line">    <span class="keyword">if</span> (lp == <span class="keyword">null</span>) &#123;</span><br><span class="line">        rvLayoutParams = (LayoutParams) generateDefaultLayoutParams();</span><br><span class="line">        holder.itemView.setLayoutParams(rvLayoutParams);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!checkLayoutParams(lp)) &#123;</span><br><span class="line">        rvLayoutParams = (LayoutParams) generateLayoutParams(lp);</span><br><span class="line">        holder.itemView.setLayoutParams(rvLayoutParams);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        rvLayoutParams = (LayoutParams) lp;</span><br><span class="line">    &#125;</span><br><span class="line">    rvLayoutParams.mViewHolder = holder;</span><br><span class="line">    rvLayoutParams.mPendingInvalidate = fromScrapOrHiddenOrCache &amp;&amp; bound;</span><br><span class="line">    <span class="keyword">return</span> holder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;免责声明：&lt;/strong&gt; 这篇文章还没有写完，发布的原因是因为我懒的放到草稿箱了，如有错误或者以后请勿怪&lt;/p&gt;
&lt;h1 id=&quot;RecyclerView介绍&quot;&gt;&lt;a href=&quot;#RecyclerView介绍&quot; class=&quot;
      
    
    </summary>
    
      <category term="Android" scheme="http://haojen.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://haojen.github.io/tags/Android/"/>
    
      <category term="View" scheme="http://haojen.github.io/tags/View/"/>
    
  </entry>
  
  <entry>
    <title>ThreadLocal详解</title>
    <link href="http://haojen.github.io/2018/07/19/ThreadLocal%E8%AF%A6%E8%A7%A3/"/>
    <id>http://haojen.github.io/2018/07/19/ThreadLocal详解/</id>
    <published>2018-07-19T02:18:26.000Z</published>
    <updated>2018-08-24T07:39:42.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ThreadLocal是什么"><a href="#ThreadLocal是什么" class="headerlink" title="ThreadLocal是什么"></a>ThreadLocal是什么</h2><p><code>ThreadLocal</code>是java中处理并发问题的一种方式，但是和<code>Synchronized</code>、<code>volatile</code>等进程同步关键字不同，<code>ThreadLocal</code>主要用于进程隔离，即每一个线程都有一个自己的<code>ThreadLocal</code>，访问时访问的都是线程持有的对象，无法访问其他线程的<code>ThreadLocal</code>,也就不存在并发的问题。</p><h2 id="ThreadLocal使用"><a href="#ThreadLocal使用" class="headerlink" title="ThreadLocal使用"></a>ThreadLocal使用</h2><p><code>ThreadLocal</code>使用起来类似一个数据封装类，使用set和get方法设置和获取存储的内容</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建ThreadLocal对象，使用泛型制定类型</span></span><br><span class="line">ThreadLocal&lt;Integer&gt; localInt = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"><span class="comment">//写入内容</span></span><br><span class="line">localInt.set(<span class="number">10</span>);</span><br><span class="line"><span class="comment">//获取内容</span></span><br><span class="line"><span class="keyword">assert</span> locaInt.get()==<span class="number">10</span>;</span><br></pre></td></tr></table></figure><p><code>ThreadLocal</code>特殊的地方就在于不同线程间是无法获取到其它线程的相应对象的，在多线程场景中对ThreadLocal的使用实例如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ThreadLocal&lt;Integer&gt; localInt = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">Thread threadA = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">100</span>;i&lt;<span class="number">200</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                localInt.set(i);</span><br><span class="line">                sleep(<span class="number">10</span>);</span><br><span class="line">                <span class="keyword">assert</span> localInt.get()==i;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">super</span>.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Thread threadB = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                localInt.set(i);</span><br><span class="line">                sleep(<span class="number">10</span>);</span><br><span class="line">                <span class="keyword">assert</span> localInt.get()==i;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">super</span>.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">threadA.start();</span><br><span class="line">threadB.start();</span><br></pre></td></tr></table></figure><p>ThreadA和ThreadB中<code>ThreadLocal</code>是不会相互影响的，他们每次从<code>ThreadLocal</code>中获取的都是线程内部的相应数据。</p><p>在上面的例子中我们只是用<code>ThreadLocal</code>存储了一个变量，如果想要同时拥有多个线程私有的变量就只能创建多个<code>TreadLocal</code>对象。</p><h2 id="ThreadLocal实现原理"><a href="#ThreadLocal实现原理" class="headerlink" title="ThreadLocal实现原理"></a>ThreadLocal实现原理</h2><p><code>ThreadLocal</code>看上去很神奇，原理其实并不难，它只是把我们的变量关联到了线程的<code>Thread</code>对象上，我们借助<code>ThreadLocal</code>的set方法来说明这点。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在我们通过set方法设置<code>ThreadLocal</code>的内容是，它首先获取当前的<code>Thread</code>对象，同时获取<code>Thread</code>上的<code>ThreadLocalMap</code>，<code>ThreadLocalMap</code>事实上是hash表的一种实现，set事实上是把<code>ThreadLocal</code>对象和相应的value分别作为key和value保证在了这个map中，也就是说我们的value保存在Thread对象内。</p><p><img src="ThreadLocal.png" alt="ThreadLocal"></p><p>get方法也是类似的，我们使用get方法获取值的时候，首先是获取currentThread，然后通过<code>Thread</code>的<code>ThreadLocalMap</code>用<code>ThreadLocal</code>作为key获取对应的value。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果没有创建过<code>ThreadLocalMap</code>，<code>setInitialValue</code>会创建<code>ThreadLocalMap</code>同时返回null。</p><h2 id="ThreadLocal内存泄漏"><a href="#ThreadLocal内存泄漏" class="headerlink" title="ThreadLocal内存泄漏"></a>ThreadLocal内存泄漏</h2><p>正常来说<code>ThreadLocal</code>的对象和其保存的value持有在一个普通的对象内，而在保存时他们会作为key和value保存在<code>Thread</code>对象的map内，线程一般拥有比普通对象更长的生命周期，特别是对于线程池中的线程。</p><p>这种情况下作为key的<code>ThreadLocal</code>和value就有泄漏的风险，<code>ThreadLocal</code>的设计上自然也考虑到了这点，因此<code>ThreadLocalMap</code>中Key都是作为弱引用存在的</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="keyword">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样当持有<code>ThreadLocal</code>的对象销毁后，没有强引用的<code>ThreadLocal</code>也会很快被回收，但是与之对应的value却没法被自动回收。</p><p>事实上<code>ThreadLocalMap</code>对于这样的情况也是有所处理，即<code>ThreadLocalMap</code>在每次set或者get时发现有key为空的元素，都会把它清理掉</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class="line"> ......</span><br><span class="line">    <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">    e != <span class="keyword">null</span>;</span><br><span class="line">    e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">    ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//清理掉key==null的元素</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            replaceStaleEntry(key, value, i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是即使这样光靠<code>ThreadLocalMap</code>也没有办法完全避免value的内存泄漏，最好的就是每次使用完<code>ThreadLocal</code>后都调用它的remove方法，清除数据。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;ThreadLocal是什么&quot;&gt;&lt;a href=&quot;#ThreadLocal是什么&quot; class=&quot;headerlink&quot; title=&quot;ThreadLocal是什么&quot;&gt;&lt;/a&gt;ThreadLocal是什么&lt;/h2&gt;&lt;p&gt;&lt;code&gt;ThreadLocal&lt;/cod
      
    
    </summary>
    
      <category term="Android" scheme="http://haojen.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://haojen.github.io/tags/Android/"/>
    
      <category term="线程" scheme="http://haojen.github.io/tags/%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Android线程池</title>
    <link href="http://haojen.github.io/2018/07/16/Android%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>http://haojen.github.io/2018/07/16/Android线程池/</id>
    <published>2018-07-16T06:09:26.000Z</published>
    <updated>2018-08-24T07:39:46.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么使用线程池"><a href="#为什么使用线程池" class="headerlink" title="为什么使用线程池"></a>为什么使用线程池</h2><p>线程是操作系统能进行运算调度的最小单元，在Java 中直接使用线程，给我们带来了很多便利，但是线程的使用同时也存在一些问题</p><ul><li>线程生命周期的开销非常高，即在线程的创建和销毁过程都会消耗较大的cpu资源</li><li>资源消耗，线程的存在期间会消耗系统资源，尤其是内存（短时间内高并发任务尤其需要注意）</li></ul><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>线程池就是一种线程复用的手段，它通过缓存已有线程，来减小线程创建过程的消耗，它通过控制线程数量来控制线程存在的系统消耗，同时他把任务和任务的执行进行了解耦，把任务本身和任务的执行过程分离。这一点从Executor就可以看出</p><pre><code>public interface Executor {    void execute(Runnable command);}</code></pre><p>任务封装成Runnable，通过execute在内部通过缓存的线程对任务进行处理，对于Runnable这个任务而言，具体的执行策略它毫不知晓，同时我们可以有极大的空间来制定执行策略。</p><h2 id="构造线程池"><a href="#构造线程池" class="headerlink" title="构造线程池"></a>构造线程池</h2><p>线程池给我们创造了极大扩展空间用于管理线程资源和定义任务的执行策略，同时为了更加方便我们使用，Java定义了一些配置成型的线程池供我们使用，这些线程池可以通过Executors这样一个工厂类获取</p><ul><li>newFixedThreadPool。newFixedThreadPool会创建一个固定长度的线程池，每当提交一个任务时，就会创建一个线程（即使有空闲的线程），直到达到线程最大值。</li><li>newCachedThreadPool。newCachedThreadPool会创建一个可缓存的线程池，任务提交时没有空闲的线程就会创建新的线程，且这个过程没有上线，当线程执行完成后60s内没有被其他任务复用就会被销毁。</li><li>newSingleThreadExecutor。newSingleThreadExecutor是一个单线程的Executor，一般按照FIFO的顺序执行（不同于我们自己创建的单线程Thread，如果Thread不慎挂掉，会创建一个新的线程保证运行过程）</li><li>newSingleThreadExecutor。创建一个固定长度线程池，会使用延迟或者定时的方式来执行任务。</li></ul><p>上面列举了几个Java中提供好的线程策略，类似的在Executors中还有很多，这里不一一列举，本质上来说，这些方法是对现有的几个线程池实现类的一种配置方式，具体线程池的复用以及调度的方式是怎么样的呢？</p><h2 id="线程池调度策略"><a href="#线程池调度策略" class="headerlink" title="线程池调度策略"></a>线程池调度策略</h2><h3 id="调度内容"><a href="#调度内容" class="headerlink" title="调度内容"></a>调度内容</h3><p>线程池是对线程的一个管理，它到底管理什么东西</p><ul><li>使用什么线程执行任务</li><li>任务执行顺序</li><li>有多少任务可以同时处理</li><li>能够有多少任务等待，如果需要执行的任务超过这个上限如何处理</li><li>任务运行时出现异常怎么处理</li><li>任务前后有哪些动作</li></ul><h3 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h3><p>我们使用的绝大部分线程池最终的实现类都是ThreadPoolExecutor，我们可以通过这个对象来真正了解线程池，首先是ThreadPoolExecutor的构造方法</p><pre><code>public ThreadPoolExecutor(int corePoolSize,                         int maximumPoolSize,                         long keepAliveTime,                         TimeUnit unit,                         BlockingQueue&lt;Runnable&gt; workQueue,                         ThreadFactory threadFactory,                         RejectedExecutionHandler handler)</code></pre><p>从构造方法可以看出很多内容，ThreadPoolExecutor中的线程分为普通线程和核心线程，有线程存活时间，任务等待队列，线程工厂，任务拒绝的handler。</p><h3 id="核心线程数和最大线程数"><a href="#核心线程数和最大线程数" class="headerlink" title="核心线程数和最大线程数"></a>核心线程数和最大线程数</h3><p>关于核心线程和最大线程可以看一下execute方法的一段代码</p><pre><code>//线程数小于核心线程直接添加新线程执行int c = ctl.get();if (workerCountOf(c) &lt; corePoolSize) {        if (addWorker(command, true))            return;        c = ctl.get();}//将任务放入等待队列，同时检测线程池运行状态并处理if (isRunning(c) &amp;&amp; workQueue.offer(command)) {    int recheck = ctl.get();    //线程池状态改变（不是运行状态）直接打回任务    if (! isRunning(recheck) &amp;&amp; remove(command))        reject(command);    else if (workerCountOf(recheck) == 0)        addWorker(null, false);//等待队列满了，试图添加新线程，如果失败打回任务//（当线程数以达到最大线程数则会失败）}else if (!addWorker(command, false))    reject(command);</code></pre><p>ctl是一个AtomicInteger类型，它用前3位标示线程池运行状态，后面位数表示已有的线程数量，当线程池新增一个任务时，会有四种情况</p><ol><li>当前线程数小于核心线程数，直接新建线程执行任务</li><li>大于核心线程数，等待队列未满，直接进入队列</li><li>等待队列已满，且小于最大线程数，直接新建线程执行任务</li><li>都不满足，打回任务</li></ol><p>可以看出即使等待队列时FIFO，任务也不一定会完成按照我们添加的顺序执行，当等待队列满的时候，一部分任务会优先执行。</p><h3 id="线程复用与回收"><a href="#线程复用与回收" class="headerlink" title="线程复用与回收"></a>线程复用与回收</h3><p>线程池最大的特点就是线程的复用，同时还有上一节中的非核心线程的回收，本质上来说核心线程和非核心线程没有去吧，他们都存储在一个集合中</p><pre><code>private final HashSet&lt;Worker&gt; workers = new HashSet&lt;&gt;();</code></pre><p>线程池中的线程都使用Worker进行封装，线程复用的过程也是借助Workder来进行的，Worker的主要代码如下</p><pre><code> private final class Worker extends AbstractQueuedSynchronizer    implements Runnable{    ......    final Thread thread;    Runnable firstTask;    ......    Worker(Runnable firstTask) {        setState(-1); // inhibit interrupts until runWorker        this.firstTask = firstTask;        this.thread = getThreadFactory().newThread(this);    }    /** Delegates main run loop to outer runWorker. */    public void run() {        runWorker(this);    }    ......}</code></pre><p>我们可以看到Worker本身就是Runnable，他在创建内部线程的同时只是把自己作为参数传递进去，最终thread.start运行时执行的就是Worker的run方法，同时这里会调用ThreadPoolExecutor的runWorker方法以完成最终的线程调度。</p><pre><code>final void runWorker(Worker w) {    Thread wt = Thread.currentThread();    Runnable task = w.firstTask;    ......    try {        //getTask从等待队列中获取下一个task        while (task != null || (task = getTask()) != null) {            ......            try {                beforeExecute(wt, task);                Throwable thrown = null;                try {                    task.run();                } catch (RuntimeException x) {                    thrown = x; throw x;                } catch (Error x) {                    thrown = x; throw x;                } catch (Throwable x) {                    thrown = x; throw new Error(x);                } finally {                    afterExecute(task, thrown);                }            } finally {                task = null;                w.completedTasks++;                w.unlock();            }        }        completedAbruptly = false;    } finally {        processWorkerExit(w, completedAbruptly);    }}</code></pre><p>可以看到在runWorker方法里，Worker内的task为空，会从等待队列中获取一个新的task并执行，同时会调用beforeExecute和afterExecute这两个生命周期方法，同时当任务队列没有清空或者没有异常发生时，这是一个死循环，如果跳出循环，则说明要么任务队列被清空，要么线程异常结束，processWorkerExit会处理这些情况，如果是异常结束会起一个新的线程，否则则会移除大于核心线程数的线程，到此线程的复用过程基本清楚了</p><p>我们可以看到ThreadPoolExecutor还有一个keepAliveTime的参数用于空闲时回收非核心线程的时机，这个过程事实上是在getTask获取下一个任务时进行的</p><pre><code>​private Runnable getTask() {    boolean timedOut = false; // Did the last poll() time out?    for (;;) {        int c = ctl.get();        ......        int wc = workerCountOf(c);        // Are workers subject to culling?        boolean timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;        ......        try {            Runnable r = timed ?                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :                workQueue.take();            if (r != null)                return r;            timedOut = true;        } catch (InterruptedException retry) {            timedOut = false;        }    }}</code></pre><p>可以看到当目前的线程数大于核心线程数时，获取任务时会执行workQueue.poll方法，这个方法在队列空时会等待给定的时间然后才会返回，如果在规定的时间仍然没有新的任务，则会在上面的processWorkerExit回收线程。</p><p>除此之外线程池还有等待队列、线程工厂、任务拒绝的handler等要点，由于时间有限，这里暂时不一一说明，以后有时间再做补充，大家也可自行探索。</p><h2 id="需要注意的问题"><a href="#需要注意的问题" class="headerlink" title="需要注意的问题"></a>需要注意的问题</h2><p>线程池十分好用，但是使用中也有些需要注意的点，这里我稍稍列举一些，希望大家使用中可以注意</p><ul><li>不要使用线程池执行可能会相互依赖的任务，因为线程池不一定能保证执行顺序，很有可能会发生线程死锁</li><li>任务需要考虑可能出现的同步问题，因为任务不是在单线程环境下运行</li><li>对时间敏感的任务，不要使用线程池，因为线程池可以保证执行但是无法保证执行的时间</li><li>运行时间较长的任务尽量不要和时间较短的任务一起执行，这会严重影响短耗时任务的执行效率</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;为什么使用线程池&quot;&gt;&lt;a href=&quot;#为什么使用线程池&quot; class=&quot;headerlink&quot; title=&quot;为什么使用线程池&quot;&gt;&lt;/a&gt;为什么使用线程池&lt;/h2&gt;&lt;p&gt;线程是操作系统能进行运算调度的最小单元，在Java 中直接使用线程，给我们带来了很多便利，但
      
    
    </summary>
    
      <category term="Android" scheme="http://haojen.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://haojen.github.io/tags/Android/"/>
    
      <category term="线程" scheme="http://haojen.github.io/tags/%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Android权限管理</title>
    <link href="http://haojen.github.io/2018/07/11/Android%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/"/>
    <id>http://haojen.github.io/2018/07/11/Android权限管理/</id>
    <published>2018-07-11T06:26:22.000Z</published>
    <updated>2018-08-24T07:39:47.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Android动态权限"><a href="#Android动态权限" class="headerlink" title="Android动态权限"></a>Android动态权限</h2><p>Android6.0（API23）开始，系统权限出现了很大的变化，此前在权限的检查和获取只发生在app安装时，同时获取后可以一直享有权限。在6.0以后，一些敏感的权限需要动态的获取，同时每次用户可以随时关闭权限，因此需要在每次使用前进行权限检查和获取。</p><h2 id="权限等级"><a href="#权限等级" class="headerlink" title="权限等级"></a>权限等级</h2><p>6.0以后也不是所有权限的获取都需要动态的申请，权限被分成了几个等级，权限的等级主要有四种，分别是Normal、Signature、Dangerous和SignatureOrSystem。</p><ul><li>Normal等级：任何应用都可以申请，直接在manifest声明，安装时提示用户，之后会自动获取此类权限。</li><li>Dangerous等级：任何应用都可以申请，需要在manifest中声明，同时在使用时需要动态的获取权限。</li><li>Signature等级：只有与声明权限的apk使用相同的签名私钥才能申请权限。</li><li>SignatureOrSystem:只有与声明权限的apk使用相同的签名私钥或者在/system/app目录下的应用才能申请权限。</li></ul><p>这四种权限都是在manifest中声明权限时指定的，在普通的应用开发中我们一般需要关注的只有Normal和Dangerous两种，其中需要动态申请权限的只有Dangerous权限。</p><h2 id="Dangerous权限"><a href="#Dangerous权限" class="headerlink" title="Dangerous权限"></a>Dangerous权限</h2><p>Android下所有的Dangerous权限都被分成权限组，在动态申请权限时，申请的时提示给用户的信息都以组为单位的，比如如果app申请<code>READ_CONTACTS</code>权限,那么系统仅仅提示用户申请联系人权限，如果用户允许，在8.0以下的版本中同组的<code>WRITE_CONTACTS</code>也会一并被获取到，而在8.0及以上<code>WRITE_CONTACTS</code>权限还需要我们去动态的申请，但是系统会立即授予该权限而不会提示用户。</p><p>Dangerous权限分组</p><table><thead><tr><th>权限组</th><th>权限</th></tr></thead><tbody><tr><td>CALENDAR</td><td>READ_CALENDAR<br>WRITE_CALENDAR</td></tr><tr><td>CAMERA</td><td>CAMERA</td></tr><tr><td>CONTACTS</td><td>READ_CONTACTS<br>WRITE_CONTACTS<br>GET_ACCOUNTS</td></tr><tr><td>LOCATION</td><td>ACCESS_FINE_LOCATION<br>ACCESS_COARSE_LOCATION</td></tr><tr><td>MICROPHONE</td><td>RECORD_AUDIO</td></tr><tr><td>PHONE</td><td>READ_PHONE_STATE<br>READ_PHONE_NUMBERS<br>CALL_PHONE<br>ANSWER_PHONE_CALLS<br>READ_CALL_LOG<br>WRITE_CALL_LOG<br>ADD_VOICEMAIL<br>USE_SIP<br>PROCESS_OUTGOING_CALLS</td></tr><tr><td>SENSORS</td><td>BODY_SENSORS</td></tr><tr><td>SMS</td><td>SEND_SMS<br>RECEIVE_SMS<br>READ_SMS<br>RECEIVE_WAP_PUSH<br>RECEIVE_MMS</td></tr><tr><td>STORAGE</td><td>READ_EXTERNAL_STORAGE<br>WRITE_EXTERNAL_STORAGE</td></tr></tbody></table><h2 id="动态权限申请"><a href="#动态权限申请" class="headerlink" title="动态权限申请"></a>动态权限申请</h2><h3 id="申明权限"><a href="#申明权限" class="headerlink" title="申明权限"></a>申明权限</h3><p>对于Dangerous的权限，我们首先也需要在manifest中申请，这里以联系人权限为例</p><pre><code>&lt;uses-permission android:name=&quot;android.permission.READ_CONTACTS&quot;/&gt;&lt;uses-permission android:name=&quot;android.permission.WRITE_CONTACTS&quot;/&gt;</code></pre><h3 id="权限检查"><a href="#权限检查" class="headerlink" title="权限检查"></a>权限检查</h3><p>在使用试图操作联系人前需要首先确认有没有这个权限</p><pre><code>if(ContextCompat.checkSelfPermission(this, Manifest.permission.READ_CONTACTS)            != PackageManager.PERMISSION_GRANTED){    //申请权限    }else{      //读取联系人}</code></pre><p><code>ContextCompat.checkSelfPermission(Context context,  String permission)</code>方法用于检查App是否拥有参数指定的权限，方法的返回值为int，可能的取值如下</p><ul><li><p><code>PERMISSION_GRANTED</code> 已经获取权限</p></li><li><p><code>PERMISSION_DENIED</code> 还没有获取权限</p></li></ul><h3 id="权限申请"><a href="#权限申请" class="headerlink" title="权限申请"></a>权限申请</h3><p>如果尚未获取权限则在使用之前需要先申请权限</p><pre><code>ActivityCompat.requestPermissions(this,                new String[]{Manifest.permission.READ_CONTACTS},CODE_REQUEST_CONTACTS);</code></pre><p>一般情况下，<code>ActivityCompat.requestPermissions</code>方法会使用一个标准的对话框提示用户，但是有些机型则会跳转到一个新的页面做这件事（会导致Activity声明周期变化，甚至重启）。</p><p>申请之后则需要等待用户选择，如果如果你的<code>Activity</code>不是继承自<code>AppCompatActivity</code>，则需要实现<code>OnRequestPermissionsResultCallback</code>用于接收权限请求的结果回掉。</p><pre><code>public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {    super.onRequestPermissionsResult(requestCode, permissions, grantResults);    if(requestCode==CODE_REQUEST_CONTACTS){        if(grantResults[0]==PackageManager.PERMISSION_GRANTED){            //读取联系人        }else{            //权限获取失败        }    }}</code></pre><h3 id="合理的权限申请"><a href="#合理的权限申请" class="headerlink" title="合理的权限申请"></a>合理的权限申请</h3><p>用户首次拒绝授予权限之后，当第二次进行权限请求时，会出现“不再提示”的选项，如果用户勾选，则后续对此权限的申请将不再提示用户，直接失败。因此我们需要在合适的时机解释获取权限的原因，我们可以使用<code>ActivityCompat.shouldShowRequestPermissionRationale</code>方法来确定是否需要告知用户，这个方法默认情况下返回false，当用户拒绝过授予此权限后，这个返回值为true（用户勾选不再提示后返回值为false）。</p><pre><code>if (ContextCompat.checkSelfPermission(this, Manifest.permission.READ_CONTACTS)            != PackageManager.PERMISSION_GRANTED) {    if (ActivityCompat.shouldShowRequestPermissionRationale(this,                Manifest.permission.READ_CONTACTS)) {        //提示用户后申请权限    } else {        //申请权限        ActivityCompat.requestPermissions(this,                new String[]{Manifest.permission.READ_CONTACTS}, CODE_REQUEST_CONTACTS);    }} else {    //读取联系人}</code></pre><h3 id="权限被拒绝"><a href="#权限被拒绝" class="headerlink" title="权限被拒绝"></a>权限被拒绝</h3><p>权限被拒绝后，再次申请会继续弹出，但是当用户勾选“不再提示”后，下次权限申请系统将不再提示用户，而是直接拒绝，这种情况下，我们只能引导用户到设置里自己打开权限，我们可以在<code>onRequestPermissionsResult</code>中通过<code>ActivityCompat.shouldShowRequestPermissionRationale</code>来判断用户是否选择了不再提示。</p><pre><code>public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {    if (requestCode == CODE_REQUEST_CONTACTS) {        if (grantResults[0] == PackageManager.PERMISSION_GRANTED) {            //读取联系人        } else {            if(!ActivityCompat.shouldShowRequestPermissionRationale(this,                    Manifest.permission.READ_CONTACTS)){               //引导用户到设置页面开启权限            }        }    }}//跳转到设置页面相关代码Intent intent = new Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS);Uri uri = Uri.fromParts(&quot;package&quot;,getApplicationContext().getPackageName(), null);intent.setData(uri);startActivity(intent);</code></pre><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://blog.csdn.net/u013553529/article/details/53167072" target="_blank" rel="noopener">Android 权限的一些细节</a> </li><li><a href="https://blog.csdn.net/jltxgcy/article/details/48288467" target="_blank" rel="noopener">Android中的权限管理</a></li><li><a href="https://blog.csdn.net/lmj623565791/article/details/50709663" target="_blank" rel="noopener">Android 6.0 运行时权限处理完全解析</a></li><li><a href="https://www.jianshu.com/p/a51593817825" target="_blank" rel="noopener">Android6.0动态权限申请步骤以及需要注意的一些坑</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Android动态权限&quot;&gt;&lt;a href=&quot;#Android动态权限&quot; class=&quot;headerlink&quot; title=&quot;Android动态权限&quot;&gt;&lt;/a&gt;Android动态权限&lt;/h2&gt;&lt;p&gt;Android6.0（API23）开始，系统权限出现了很大的变化，此
      
    
    </summary>
    
      <category term="Android" scheme="http://haojen.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://haojen.github.io/tags/Android/"/>
    
      <category term="permission" scheme="http://haojen.github.io/tags/permission/"/>
    
  </entry>
  
  <entry>
    <title>AndrodUI测试入门</title>
    <link href="http://haojen.github.io/2018/03/05/AndrodUI%E6%B5%8B%E8%AF%95%E5%85%A5%E9%97%A8/"/>
    <id>http://haojen.github.io/2018/03/05/AndrodUI测试入门/</id>
    <published>2018-03-05T09:11:28.000Z</published>
    <updated>2018-08-24T07:39:47.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="UI测试"><a href="#UI测试" class="headerlink" title="UI测试"></a>UI测试</h2><p>UI 测试是为了确保对于用户的UI动作，app能返回正确的UI输出。根据实际实现方案大体可以分为两种：</p><ul><li>End-To-End（E2E）UI测试，直接通过客户端和后台服务器的交互测试整个系统，普通操作UI，通过网络获取数据，验证UI数据。实现简单，但是存在测试速度缓慢，可能因为网络导致测试用例不通过的问题。</li><li>封闭UI测试，测试方法使得测试不需要外部依赖和网络请求，使用Mock Server或者其他方式替代真实的网络请求，只验证UI输出的正确性。</li></ul><h2 id="UI测试框架"><a href="#UI测试框架" class="headerlink" title="UI测试框架"></a>UI测试框架</h2><p>Android之前比较流行的UI测试框架有<a href="https://github.com/RobotiumTech/robotium" target="_blank" rel="noopener">robotium</a>、<a href="http://appium.io/?yyue=a21bo.50862.201879" target="_blank" rel="noopener">Appium</a>、<a href="">uiautomator</a>、<a href="http://calaba.sh/?yyue=a21bo.50862.201879" target="_blank" rel="noopener">Calabash</a>、<a href="https://developer.android.com/training/testing/espresso/index.html" target="_blank" rel="noopener">Espresso</a>,但是其中Espresso作为Google官方开源的UI测试框架，以其官方的身份、完整的使用文档以及简单的使用方法，快速成为UI测试框架中的主流，本文就是以Espresso框架为主要测试框架。</p><h2 id="Espresso"><a href="#Espresso" class="headerlink" title="Espresso"></a>Espresso</h2><h3 id="介绍及集成"><a href="#介绍及集成" class="headerlink" title="介绍及集成"></a>介绍及集成</h3><p>Espresso 测试框架提供了一组 API 来构建 UI 测试，用于测试应用中的用户流。利用这些 API，您可以编写简洁、运行可靠的自动化 UI 测试。Espresso 非常适合编写白盒自动化测试，其中测试代码将利用所测试应用的实现代码详情。<br>目前Espresso最新的版本已经出道3.0.1，使用AS创建的工程，默认已经集成了2.2.2版本的Espresso，但是如果要集成最新版本的Espresso库，需要在仓库配置中添加对应仓库地址：</p><pre><code>allprojects {    repositories {        jcenter()        maven {            url &quot;https://maven.google.com&quot;            //Espresso3.0.1所在仓库地址        }    }}</code></pre><p>默认集成的Espresso包espresso-core及其相关依赖包，足以完成一般性的UI测试，除此之外Espresso还有一些扩展包，用于完成一些特殊的测试场景:</p><ul><li>espresso-web 提供了对WebView测试的相关支持</li><li>espresso-contrib 提供了对DatePicker, RecyclerView 和 Drawer等控件的特有动作、无障碍以及CountingIdlingResource的支持</li><li>espresso-intents 用于校验多app测试中intent的正确性</li><li>espresso-idling-resource（已经包含在core的依赖中）用于处理异步线程同步问题</li></ul><p>如果测试过程中不需要上述的扩展功能，则只需要添加core的依赖</p><pre><code>dependencies {    androidTestCompile(&apos;com.android.support.test.espresso:espresso-core:3.0.1&apos;, {        exclude group: &apos;com.android.support&apos;, module: &apos;support-annotations&apos;        //不导入依赖中的support-annotations，避免出现依赖冲突，会使用用户自己导入的包    })}</code></pre><p>其余诸如runner，rules包都被core依赖，会自动导入，没有必要手动导入，以免导入版本不正确引起其他问题，除了上面描述的相关库，Espresso还依赖了JUnit和Hamcrest等其他测试辅助框架。</p><h3 id="EspressoUI测试的重要对象"><a href="#EspressoUI测试的重要对象" class="headerlink" title="EspressoUI测试的重要对象"></a>EspressoUI测试的重要对象</h3><ul><li><strong><a href="https://developer.android.com/reference/android/support/test/espresso/Espresso.html" target="_blank" rel="noopener"><code>Espresso</code></a></strong> Espresso框架的入口类，提供了一些静态方法，便于开始整个测试代码，它提供了类似onView和onData这种方法获取一个可交互的对象ViewInteraction，或者直接进行一个例如页面返回的顶层操作。</li><li><strong><a href="https://developer.android.com/reference/android/support/test/espresso/matcher/ViewMatchers.html" target="_blank" rel="noopener"><code>ViewMatchers</code></a></strong> 定义了一系列静态方法用于根据不同条件返回Matcher&lt;? super View&gt;对象，作为参数传递给onView()。</li><li><strong><a href="https://developer.android.com/reference/android/support/test/espresso/action/ViewActions.html" target="_blank" rel="noopener"><code>ViewActions</code></a></strong> view的操作行为例如click()，最为ViewInteraction.perform()的参数用于对指定View的进行对应操作。</li><li><strong><a href="https://developer.android.com/reference/android/support/test/espresso/assertion/ViewAssertions.html" target="_blank" rel="noopener"><code>ViewAssertions</code></a></strong> 作为ViewInteraction.check()的参数，判断view的输出是否正确</li><li><strong><a href="https://developer.android.com/reference/android/support/test/rule/ActivityTestRule.html" target="_blank" rel="noopener"><code>ActivityTestRule</code></a></strong> 提供了测试单个Activity的功能，当它的launchActivity设置为true时，它会在每个使用<code>@Test</code>注释的方法前和所有注释者<code>@Before</code>的方法前启动。同时可以通过ActivityTestRule对象获取对应Activity的对象。</li></ul><p>一个简单的代码示例如下：</p><pre><code>@RunWith(AndroidJUnit4.class)public class LoginTest {    @Rule    public ActivityTestRule&lt;LoginActivity&gt; mActivityRule =            new ActivityTestRule(LoginActivity.class);    @Test    public void login() throws Exception {        onView(withId(R.id.et_login_number)).perform(click(),replaceText(&quot;17720380994&quot;),closeSoftKeyboard());        onView(withId(R.id.btn_login_next)).perform(click());        onView(withId(R.id.et_password)).perform(click(),replaceText(&quot;aa123456&quot;),closeSoftKeyboard());        onView(withId(R.id.btn_login)).perform(click());        onView(withId(R.id.toolbar)).check(matches(isDisplayed()));        onView(allOf(instanceOf(ImageButton.class),withParent(withId(R.id.toolbar)),isDisplayed())).perform(click());        onView(withId(R.id.tv_phone_number)).check(matches(withText(&quot;17720380994&quot;)));        onView(IsInstanceOf.&lt;View&gt;instanceOf(ScrollView.class)).perform(swipeUp());        onView(withId(R.id.tv_exit)).perform(click());        onView(withText(R.string.exit_login_confirm)).check(matches(isDisplayed()));        onView(withId(R.id.tv_ok)).perform(click());        onView(withId(R.id.et_login_number)).check(matches(isDisplayed()));    }}</code></pre><p>总体来说UI测试的过程就是：<strong>找到某个元素，做一些操作，检查结果</strong>。</p><h3 id="寻找View"><a href="#寻找View" class="headerlink" title="寻找View"></a>寻找View</h3><p>Espresso中定位View主要有两种，通过页面显示的View特征（onView）和通过数据内容（onData），其中onView用于普通场景，onData用于adapterView这种可能没有渲染的view，但是两者都是基于hamcrest的matcher来进行，本质是相同的不同的是匹配规则</p><h4 id="ViewMathcer"><a href="#ViewMathcer" class="headerlink" title="ViewMathcer"></a>ViewMathcer</h4><p><code>ViewMathcer</code>实质上提供了很多Matcher对象，主要用于配合OnView匹配控件，这些Matcher同时可以配合hamcrest中的matcher一起使用，效果更好。常用的Matcher如下</p><ul><li><code>withId()</code> <code>onView(withId(R.id.tv_ok))</code><br>直接通过id定位指定的的View，简单粗暴，但是非常实用。</li><li><code>isAssignableFrom()</code> <code>onView(isAssignableFrom(ScrollView.class))</code>通过对象类型判断</li><li><code>isDisplayed()</code>  <code>onView(allOf(isDisplayed(),isAssignableFrom(ScrollView.class)))</code> 通过是否显示判断，通常和其他matcher配合(<code>allOf</code>是hamcrest库重的方法，用于匹配多个matcher，类似的还有<code>anyOf</code>)</li><li><code>isEnabled()</code></li><li><code>isFocusable()</code><br>……</li></ul><p><code>ViewMathcer</code>中几乎把所有的View属性都定义了对应的matcher，需要的可以自行查阅源码或文档。</p><h4 id="DataInteraction"><a href="#DataInteraction" class="headerlink" title="DataInteraction"></a>DataInteraction</h4><p><code>DataInteraction</code> 是onData方法的返回值，因为onData方法匹配出的不直接就是View，它匹配的是一个数据集合，只有我们想要进行具体的View操作时，Espresso才会把它转化为View。<br>​<br>     onData(instanceOf(Account.class))<br>Espresso没有为<code>onData</code>定义Matcher，基本都是使用hamcrest中定义的matcher或者自定义matcher</p><h5 id="自定义Matcher"><a href="#自定义Matcher" class="headerlink" title="自定义Matcher"></a>自定义Matcher</h5><p>一般自定义Matcher都继承<code>TypeSafeMatcher</code>，需要实现的方法如下</p><pre><code>public class CallInfoMatcher extends TypeSafeMatcher&lt;CallInfo&gt; {    @Override    public void describeTo(Description description) {        //匹配失败时的描述，用于描述具体的匹配失败信息    }    @Override    protected boolean matchesSafely(CallInfo item) {        //具体的匹配过程        return false;    }}</code></pre><h3 id="对View的操作"><a href="#对View的操作" class="headerlink" title="对View的操作"></a>对View的操作</h3><p>View的操作都是在<code>ViewInteraction</code>上进行的。<code>ViewInteraction</code>也就是<code>onView</code>的返回值对象，用于对于具体的View进行操作（<code>DataInteraction</code>的操作也是转换为ViewInteraction后进行的），<code>ViewInteraction</code>提供了如下方法来对相应的元素做操作：</p><pre><code>public ViewInteraction perform(final ViewAction... viewActions) {}</code></pre><p>具体的操作通过<code>ViewAction</code>定义，连续操作可以链式调用或者作为参数顺序排列。</p><h4 id="ViewAction"><a href="#ViewAction" class="headerlink" title="ViewAction"></a>ViewAction</h4><p><code>ViewAction</code>是espresso中定义的针对View操作的接口类型。<code>ViewAction</code>中实现主要在ViewActions类中通过静态方法提供。常见的action如下</p><ul><li><code>click()</code></li><li><code>closeSoftKeyboard()</code></li><li><code>replaceText()</code><br>……</li></ul><p>除去ViewActions提供的较为通用的操作方法，Espresso还提供了很多ViewAction的子类用于完成不同View的特定操作。     </p><blockquote><p>ViewAction是在View匹配成功的基础上进行的匹配失败或者匹配不唯一都会导致测试不通过，同时Action与View类型不匹配也会失败</p></blockquote><h3 id="校验结果"><a href="#校验结果" class="headerlink" title="校验结果"></a>校验结果</h3><p>测试最重要的一步就是校验结果的正确性，<code>ViewInteraction</code>提供了<code>check()</code>方法用于校验正确性</p><pre><code>public ViewInteraction check(final ViewAssertion viewAssert) {    ......}</code></pre><p>和<code>perform()</code>方法类似，<code>check()</code>也是可以链式调用多次校验。</p><h4 id="ViewAssertion"><a href="#ViewAssertion" class="headerlink" title="ViewAssertion"></a>ViewAssertion</h4><p><code>ViewAssertion</code>是espresso中定义的用于校验View状态的接口类型，同样<code>ViewAssertion</code>也主要由<code>ViewAssertions</code>中的静态方法提供。其中主要使用的就是<code>matches()</code>方法</p><pre><code>public static ViewAssertion matches(final Matcher&lt;? super View&gt; viewMatcher) {    return new MatchesViewAssertion(checkNotNull(viewMatcher));}</code></pre><p>其中参数viewMatcher就是前面用于匹配View的<code>ViewMatcher</code>。</p><h3 id="异步问题"><a href="#异步问题" class="headerlink" title="异步问题"></a>异步问题</h3><p>Espresso提供了大量的同步机制，这些机制主要针对于主线层的MQ，但是Espresso对于其他的异步操作是无感知的，如果View的显示依赖于网络数据，很有可能就会导致测试用例不通过，因此需要使用前面使用的<code>espresso-idling-resource</code>来保证Espresso在异步线程的可靠性。</p><p><code>espresso-idling-resource</code>依赖添加如下</p><pre><code>compile(&quot;com.android.support.test.espresso:espresso-idling-resource:3.0.1&quot;) {    exclude module: &apos;support-annotations&apos;}androidTestCompile(&quot;com.android.support.test.espresso:espresso-idling-resource:3.0.1&quot;) {    exclude module: &apos;support-annotations&apos;}//由于Espresso对与异步线程无感知，我们需要在代码中主动使用IdlingResource，因此需要使用compile依赖。</code></pre><h3 id="IdlingResource"><a href="#IdlingResource" class="headerlink" title="IdlingResource"></a>IdlingResource</h3><p>Espresso主要通过<code>IdlingResource</code>这个接口类型完成对异步资源的感知，主要方法如下</p><pre><code>public interface IdlingResource {    //用于标识对于的异步资源    public String getName();    //返回目前资源是否可用(闲置)，    public boolean isIdleNow();    //Espresso会注册此回掉，需要判断资源可用时主动调用    public void registerIdleTransitionCallback(ResourceCallback callback);    public interface ResourceCallback {        public void onTransitionToIdle();    }}</code></pre><p>Espresso提供了几个<code>IdlingResource</code>的实现类，可以直接使用：</p><ul><li><a href="https://developer.android.com/reference/android/support/test/espresso/idling/CountingIdlingResource.html" target="_blank" rel="noopener">CountingIdlingResource</a> 为资源提供了一个简单的使用计数，当count为0时资源为闲置状态。</li><li><a href="https://developer.android.com/reference/android/support/test/espresso/idling/net/UriIdlingResource.html" target="_blank" rel="noopener">UriIdlingResource</a> 类似<code>CountingIdlingResource</code>,但是count为0时资源不会立即为闲置状态。</li><li><a href="https://developer.android.com/reference/android/support/test/espresso/idling/concurrent/IdlingThreadPoolExecutor.html" target="_blank" rel="noopener">IdlingThreadPoolExecutor</a>  一个有<code>IdlingResource</code>功能的<code>ThreadPoolExecutor</code>。</li><li><a href="https://developer.android.com/reference/android/support/test/espresso/idling/concurrent/IdlingScheduledThreadPoolExecutor.html" target="_blank" rel="noopener">IdlingScheduledThreadPoolExecutor</a> em.. 同上</li></ul><p>我们借<code>CountingIdlingResource</code>来了解下<code>IdlingResource</code>的主要用法，<code>CountingIdlingResource</code>主要提供的两个共有方法供我们使用</p><ul><li><code>increment()</code>计数加一</li><li><code>decrement()</code>计数减一，为0时调用<code>onTransitionToIdle()</code></li></ul><p>例如使用网络请求的场景，发起请求时<code>increment()</code>表示资源被占用，请求结束时<code>decrement()</code>，表示资源被释放。同时还需要在测试代码中注册对应资源</p><pre><code>IdlingRegistry.getInstance().register(idlingResource);</code></pre><p><code>IdlingResource</code>解决了异步代码的问题，但是依旧存在问题，我们在业务逻辑代码中创建<code>IdlingResource</code>对象，同时在需要的地方去改变它的状态，然后在测试代码中使用。这无疑是为了测试而给正常的业务代码增加了不必要的逻辑。</p><p>未完待续～</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;UI测试&quot;&gt;&lt;a href=&quot;#UI测试&quot; class=&quot;headerlink&quot; title=&quot;UI测试&quot;&gt;&lt;/a&gt;UI测试&lt;/h2&gt;&lt;p&gt;UI 测试是为了确保对于用户的UI动作，app能返回正确的UI输出。根据实际实现方案大体可以分为两种：&lt;/p&gt;
&lt;ul&gt;
&lt;
      
    
    </summary>
    
      <category term="Android" scheme="http://haojen.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="http://haojen.github.io/tags/Android/"/>
    
      <category term="Test" scheme="http://haojen.github.io/tags/Test/"/>
    
  </entry>
  
</feed>
