<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>yihome</title>
  <icon>https://www.gravatar.com/avatar/1dbd1d499c3a70d9e39ff8ab1bc714a3</icon>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://haojen.github.io/"/>
  <updated>2018-08-17T09:12:36.213Z</updated>
  <id>http://haojen.github.io/</id>
  
  <author>
    <name>houyi</name>
    <email>yihome926@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Handler解析</title>
    <link href="http://haojen.github.io/2018/08/16/Handler%E8%A7%A3%E6%9E%90/"/>
    <id>http://haojen.github.io/2018/08/16/Handler解析/</id>
    <published>2018-08-16T05:42:58.000Z</published>
    <updated>2018-08-17T09:12:36.213Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Handler介绍"><a href="#Handler介绍" class="headerlink" title="Handler介绍"></a>Handler介绍</h1><p><code>Handler</code> 是 Android 下异步线程通讯的主要机制，关于 <code>Handler</code> 的简单介绍如下图所示</p><p><img src="./Handler.png" alt="Handler流程"></p><p>在 <code>Handler</code> 机制中，主要的参与对象以及关系在上图中已经很清晰了，我这里在简单介绍一下：</p><ul><li><p><code>Handler</code> 异步消息的发送者，也是消息的处理者，但是值得注意的是发送的处理可以在不同线程</p></li><li><p><code>MessageQueue</code> 线程安全的消息队列，线程的变换主要是在 <code>MessageQueue</code> 中完成</p></li><li><p><code>Messager</code> 异步通信内容的载体</p></li><li><p><code>Looper</code> 通过循环不断的从 <code>MessageQueue</code> 中获取消息，然后分发给 <code>Handler</code> 处理，和<code>MessageQueue</code> 是一一对应的关系</p></li></ul><p>简单的介绍到此为止，下面开始详细介绍整个消息发送过程。</p><h1 id="Handler消息机制"><a href="#Handler消息机制" class="headerlink" title="Handler消息机制"></a>Handler消息机制</h1><h2 id="Handler创建"><a href="#Handler创建" class="headerlink" title="Handler创建"></a>Handler创建</h2><p>针对 <code>Handler</code> 消息机制，我这边直接从 <code>Handler</code> 构造函数开始解析</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//内存泄漏警告</span></span><br><span class="line">......</span><br><span class="line">    <span class="comment">//获取Looper</span></span><br><span class="line">    mLooper = Looper.myLooper();</span><br><span class="line">    <span class="keyword">if</span> (mLooper == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">            <span class="string">"Can't create handler inside thread that has not called Looper.prepare()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mQueue = mLooper.mQueue;</span><br><span class="line">    mCallback = callback;</span><br><span class="line">    mAsynchronous = async;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Looper是通过ThreadLocal获取的线程私有的变量，但是默认为null</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="meta">@Nullable</span> <span class="function">Looper <span class="title">myLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sThreadLocal.get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建Looper对象并设置给ThreadLocal</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建MessageQueue对象</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Looper</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">    mQueue = <span class="keyword">new</span> MessageQueue(quitAllowed);</span><br><span class="line">    mThread = Thread.currentThread();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这一段代码看似很多，其实就是告诉我们如果想要创建 <code>Handler</code> 就得先有一个 <code>Looper</code> ,  <code>Looper</code> 是跟线程绑定的，创建 <code>Looper</code> 的同时它也会把 <code>MessageQueue</code> 也一起创建好，我们平时在主线程中的用的时候不要  <code>Looper</code> ,是因为主线程以及帮我们干了。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityThread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">.....</span><br><span class="line">        Looper.prepareMainLooper();</span><br><span class="line">        ......</span><br><span class="line">        Looper.loop();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Main thread loop unexpectedly exited"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到现在可以确定线程、<code>Looper</code> 、<code>Handler</code> 、<code>MessageQueue</code> 的关系如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph TB</span><br><span class="line">subgraph 线程</span><br><span class="line">MessageQueue --&gt; Looper</span><br><span class="line">Looper --&gt; Handler1</span><br><span class="line">Looper --&gt; Handler2</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h2 id="消息发送"><a href="#消息发送" class="headerlink" title="消息发送"></a>消息发送</h2><p>使用 <code>Handler</code> 发送消息可以有多种形式，<code>Handler.sendMessage()</code> 、<code>Message.sendToTarget()</code> 以及类似的一些方法都可以发送消息，但是不管是哪种方法最终都会调用<code>Handler.enqueueMessage()</code> 方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(MessageQueue queue, Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">    msg.target = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">if</span> (mAsynchronous) &#123;</span><br><span class="line">        <span class="comment">//发送异步消息</span></span><br><span class="line">        msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法也没有做太多逻辑处理，直接调用了 <code>MessageQueue</code> 的 <code>enqueueMessage</code> 方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(Message msg, <span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">       ......</span><br><span class="line">        msg.markInUse();</span><br><span class="line">        msg.when = when;</span><br><span class="line">        Message p = mMessages;</span><br><span class="line">        <span class="keyword">boolean</span> needWake;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</span><br><span class="line">            <span class="comment">// New head, wake up the event queue if blocked.</span></span><br><span class="line">            msg.next = p;</span><br><span class="line">            mMessages = msg;</span><br><span class="line">            needWake = mBlocked;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Inserted within the middle of the queue.  Usually we don't have to wake</span></span><br><span class="line">            <span class="comment">// up the event queue unless there is a barrier at the head of the queue</span></span><br><span class="line">            <span class="comment">// and the message is the earliest asynchronous message in the queue.</span></span><br><span class="line">            needWake = mBlocked &amp;&amp; p.target == <span class="keyword">null</span> &amp;&amp; msg.isAsynchronous();</span><br><span class="line">            Message prev;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                prev = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">                <span class="keyword">if</span> (p == <span class="keyword">null</span> || when &lt; p.when) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                    needWake = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            msg.next = p; <span class="comment">// invariant: p == prev.next</span></span><br><span class="line">            prev.next = msg;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We can assume mPtr != 0 because mQuitting is false.</span></span><br><span class="line">        <span class="keyword">if</span> (needWake) &#123;</span><br><span class="line">            nativeWake(mPtr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一段事实上就是一个单链表插入，<code>mMessages</code> 为链表头，如果链表为空则直接把 <code>msg</code> 赋给表头，否则通过循环找到链表最后进行插入。<code>MessageQueue</code> 的消息在 <code>Looper.loop()</code> 来获取并处理的。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Looper me = myLooper();</span><br><span class="line">    <span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"No Looper; Looper.prepare() wasn't called on this thread."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> MessageQueue queue = me.mQueue;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Make sure the identity of this thread is that of the local process,</span></span><br><span class="line">    <span class="comment">// and keep track of what that identity token actually is.</span></span><br><span class="line">    Binder.clearCallingIdentity();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> ident = Binder.clearCallingIdentity();</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Message msg = queue.next(); <span class="comment">// might block</span></span><br><span class="line">        <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// No message indicates that the message queue is quitting.</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// This must be in a local variable, in case a UI event sets the logger</span></span><br><span class="line">        <span class="keyword">final</span> Printer logging = me.mLogging;</span><br><span class="line">        <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</span><br><span class="line">            logging.println(<span class="string">"&gt;&gt;&gt;&gt;&gt; Dispatching to "</span> + msg.target + <span class="string">" "</span> +</span><br><span class="line">                            msg.callback + <span class="string">": "</span> + msg.what);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> slowDispatchThresholdMs = me.mSlowDispatchThresholdMs;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> traceTag = me.mTraceTag;</span><br><span class="line">        <span class="keyword">if</span> (traceTag != <span class="number">0</span> &amp;&amp; Trace.isTagEnabled(traceTag)) &#123;</span><br><span class="line">            Trace.traceBegin(traceTag, msg.target.getTraceName(msg));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> start = (slowDispatchThresholdMs == <span class="number">0</span>) ? <span class="number">0</span> :SystemClock.uptimeMillis();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> end;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            msg.target.dispatchMessage(msg);</span><br><span class="line">            end = (slowDispatchThresholdMs == <span class="number">0</span>) ? <span class="number">0</span> : SystemClock.uptimeMillis();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (traceTag != <span class="number">0</span>) &#123;</span><br><span class="line">                Trace.traceEnd(traceTag);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (slowDispatchThresholdMs &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> time = end - start;</span><br><span class="line">            <span class="keyword">if</span> (time &gt; slowDispatchThresholdMs) &#123;</span><br><span class="line">                Slog.w(TAG, <span class="string">"Dispatch took "</span> + time + <span class="string">"ms on "</span></span><br><span class="line">                       + Thread.currentThread().getName() + <span class="string">", h="</span> +</span><br><span class="line">                       msg.target + <span class="string">" cb="</span> + msg.callback + <span class="string">" msg="</span> + msg.what);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</span><br><span class="line">            logging.println(<span class="string">"&lt;&lt;&lt;&lt;&lt; Finished to "</span> + msg.target + <span class="string">" "</span> + msg.callback);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Make sure that during the course of dispatching the</span></span><br><span class="line">        <span class="comment">// identity of the thread wasn't corrupted.</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> newIdent = Binder.clearCallingIdentity();</span><br><span class="line">        <span class="keyword">if</span> (ident != newIdent) &#123;</span><br><span class="line">            Log.wtf(TAG, <span class="string">"Thread identity changed from 0x"</span></span><br><span class="line">                    + Long.toHexString(ident) + <span class="string">" to 0x"</span></span><br><span class="line">                    + Long.toHexString(newIdent) + <span class="string">" while dispatching to "</span></span><br><span class="line">                    + msg.target.getClass().getName() + <span class="string">" "</span></span><br><span class="line">                    + msg.callback + <span class="string">" what="</span> + msg.what);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        msg.recycleUnchecked();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>loop()</code> 方法主要就是在一个无限循环中不断的通过 <code>next</code> 获取消息，然后使用 <code>dispatchMessage</code> 把消息交回给Handler处理。现在我们回头来看 <code>next</code> 方法是如何获取消息的。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Message <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   ......</span><br><span class="line">    <span class="keyword">int</span> pendingIdleHandlerCount = -<span class="number">1</span>; <span class="comment">// -1 only during first iteration</span></span><br><span class="line">    <span class="keyword">int</span> nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nextPollTimeoutMillis != <span class="number">0</span>) &#123;</span><br><span class="line">            Binder.flushPendingCommands();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">// Try to retrieve the next message.  Return if found.</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">            Message prevMsg = <span class="keyword">null</span>;</span><br><span class="line">            Message msg = mMessages;</span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="keyword">null</span> &amp;&amp; msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// Stalled by a barrier.  Find the next asynchronous message in the queue.</span></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    prevMsg = msg;</span><br><span class="line">                    msg = msg.next;</span><br><span class="line">                &#125; <span class="keyword">while</span> (msg != <span class="keyword">null</span> &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (now &lt; msg.when) &#123;</span><br><span class="line">                    <span class="comment">// Next message is not ready.  Set a timeout to wake up when it is ready.</span></span><br><span class="line">                    nextPollTimeoutMillis = (<span class="keyword">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// Got a message.</span></span><br><span class="line">                    mBlocked = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (prevMsg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        prevMsg.next = msg.next;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        mMessages = msg.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    msg.next = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">"Returning message: "</span> + msg);</span><br><span class="line">                    msg.markInUse();</span><br><span class="line">                    <span class="keyword">return</span> msg;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// No more messages.</span></span><br><span class="line">                nextPollTimeoutMillis = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <code>next</code> 方法的主要逻辑都在一个无限循环内，知道获取到消息才会返回，同时把消息从链表中移除。同时默认获取的是链表头，只有当 <code>msg.target == null</code> 时才会获取链表后第一个同步消息，但是要知道我们通过 <code>Handler</code> 发送的消息 <code>target</code> 都是 <code>Handler</code> 本身，事实上这是消息屏障机制</p><h2 id="同步屏障"><a href="#同步屏障" class="headerlink" title="同步屏障"></a>同步屏障</h2><p>事实上消息分为同步和异步两种，通过 <code>isAsynchronous</code> 来判断，我们平时使用的一般是异步消息 ,同步消息主要用于页面绘制等对时间敏感的地方，但是在通常情况下即使我们使用 <code>setAsynchronous(true)</code> 来手动设置一个同步消息它也不会生效，<code>MessageQueue</code> 还是会把他当作普通消息处理，只有配合 <code>postSyncBarrier</code> 添加一个同步屏障之后才能使用。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">postSyncBarrier</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> postSyncBarrier(SystemClock.uptimeMillis());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">postSyncBarrier</span><span class="params">(<span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Enqueue a new sync barrier token.</span></span><br><span class="line">    <span class="comment">// We don't need to wake the queue because the purpose of a barrier is to stall it.</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> token = mNextBarrierToken++;</span><br><span class="line">        <span class="keyword">final</span> Message msg = Message.obtain();</span><br><span class="line">        msg.markInUse();</span><br><span class="line">        msg.when = when;</span><br><span class="line">        msg.arg1 = token;</span><br><span class="line"></span><br><span class="line">        Message prev = <span class="keyword">null</span>;</span><br><span class="line">        Message p = mMessages;</span><br><span class="line">        <span class="keyword">if</span> (when != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; p.when &lt;= when) &#123;</span><br><span class="line">                prev = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123; <span class="comment">// invariant: p == prev.next</span></span><br><span class="line">            msg.next = p;</span><br><span class="line">            prev.next = msg;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            msg.next = p;</span><br><span class="line">            mMessages = msg;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> token;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>postSyncBarrier</code> 是一个隐藏 Api，我们无法调用，但这不妨碍我们分析它，它直接向 <code>MessageQueue</code> 的单链表中头插入了一个 <code>target==null</code> 的消息，也就是上一节 <code>next</code> 方法中的逻辑，当这种情况下，<code>MessageQueue</code> 会忽略所有的异步消息，只获取同步消息，需要调用 <code>removeSyncBarrier(int token)</code> 才能取消这个同步屏障，目前同步屏障主要是在 <code>ViewRootImpl</code> 绘制时使用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Handler介绍&quot;&gt;&lt;a href=&quot;#Handler介绍&quot; class=&quot;headerlink&quot; title=&quot;Handler介绍&quot;&gt;&lt;/a&gt;Handler介绍&lt;/h1&gt;&lt;p&gt;&lt;code&gt;Handler&lt;/code&gt; 是 Android 下异步线程通讯的主要机
      
    
    </summary>
    
    
      <category term="Android" scheme="http://haojen.github.io/tags/Android/"/>
    
      <category term="Handler" scheme="http://haojen.github.io/tags/Handler/"/>
    
  </entry>
  
  <entry>
    <title>RecyclerView源码详解</title>
    <link href="http://haojen.github.io/2018/07/30/RecyclerView%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3/"/>
    <id>http://haojen.github.io/2018/07/30/RecyclerView源码详解/</id>
    <published>2018-07-30T08:58:48.000Z</published>
    <updated>2018-08-17T09:12:44.570Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p><strong>免责声明：</strong> 这篇文章还没有写完，发布的原因是因为我懒的放到草稿箱了，如有错误或者以后请勿怪</p><h1 id="RecyclerView介绍"><a href="#RecyclerView介绍" class="headerlink" title="RecyclerView介绍"></a>RecyclerView介绍</h1><p><code>RecyclerView</code> 是Google support-v7包中的控件，用于提供一个列表的显示，和 <code>ListView</code> 类似，但是比 <code>ListView</code> 更高级也更具扩展性，它更倾向于使用一个模块化的方式来使用多个模块共同实现一个复杂的列表控件，<code>RecyclerView</code>主要由如下几个组件构成</p><ul><li><p><code>LayoutManager</code> 用于控制List子View的测量和布局</p></li><li><p><code>Adapter</code> 和 <code>ListView</code> 中的Adapter功能类似，但是已经预先添加了 <code>ViewHolder</code> ,不需要我们手动添加</p></li><li><p><code>ItemDecoration</code> 用于控制和显示分割线</p></li><li><p><code>ItemAnimator</code> 用于实现Item显示消失时动画效果</p></li></ul><p>当然除了上面所说的这些模块之外，<code>RecyclerView</code> 还把很多其他的功能也都拆分了出来，这里就不一一列举，文中遇到了在做说明。</p><h1 id="LayoutManager"><a href="#LayoutManager" class="headerlink" title="LayoutManager"></a>LayoutManager</h1><p><code>LayoutManager</code> 相当于把本身View应该完成的测量和布局过程抽离出来单独处理，而这两个步骤也是决定一个View显示效果的重要步骤，因此同一个 <code>RecyclerView</code> 完全可以通过不同的 <code>LayoutManager</code> 实现不同的显示效果，而不是使用不同的控件。</p><p>  目前Google已经预先提供好了几种 <code>LayoutManager</code> ,分别如下所示</p><ul><li><p><code>LinearLayoutManager</code> 实现类似 <code>ListView</code> 列表样式的布局</p></li><li><p><code>GridLayoutManager</code> 实现类似 <code>GridView</code> 网格样式的布局</p></li><li><p><code>StaggeredGridLayoutManager</code> 实现了瀑布流样式的布局</p></li></ul><p>我们以 <code>LinearLayoutManager</code> 为例来说明 <code>LayoutManager</code> 在 <code>RecyclerView</code> 中的重要作用，首先先说明一下 <code>LinearLayoutManager</code> 中的两个辅助类，这两个类在 <code>LinearLayoutManager</code> 的工作中也起着一定作用</p><ul><li><code>AnchorInfo</code> 布局的锚点，在测量和布局过程中 <code>LinearLayoutManager</code> 都是先确定一个锚点位置，然后根据锚点，分别向上和向下去测量和布局子 <code>View</code></li><li><code>LayoutState</code> 是 <code>LinearLayoutManager</code> 在填充整体布局的帮助类，他可以通过一个给定的方向获取下一个需要填充的 <code>View</code></li></ul><h2 id="onMeasure"><a href="#onMeasure" class="headerlink" title="onMeasure"></a>onMeasure</h2><p>我们都知道控件的展示主要分为测量、布局、绘制等三个阶段进行，我们首先关注 <code>RecyclerView</code> 的测量过程。代码片段会省略部分代码和注释</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthSpec, <span class="keyword">int</span> heightSpec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mLayout == <span class="keyword">null</span>) &#123;</span><br><span class="line">        defaultOnMeasure(widthSpec, heightSpec);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//isAutoMeasureEnabled方法返回false，表示必须要重写LayoutManager的onMeasure方法，完成测量</span></span><br><span class="line">    <span class="comment">//如果设置为true，则表示由RecyclerView的AutoMeasure机制完成测量</span></span><br><span class="line">    <span class="comment">//LinearLayoutManager已经重写了这个方法，永久返回true</span></span><br><span class="line">    <span class="keyword">if</span> (mLayout.isAutoMeasureEnabled()) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> widthMode = MeasureSpec.getMode(widthSpec);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> heightMode = MeasureSpec.getMode(heightSpec);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里看似调用了LayoutManager的onMeasure，但是LinearLayoutManager没有重写这个方法，</span></span><br><span class="line">        <span class="comment">//因此这个最终是调用了RecyclerView自己默认的方法</span></span><br><span class="line">        mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//RecyclerView固定宽高或者Match_Parent的情况下measureSpecModeIsExactly为true</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> measureSpecModeIsExactly =</span><br><span class="line">            widthMode == MeasureSpec.EXACTLY &amp;&amp; heightMode == MeasureSpec.EXACTLY;</span><br><span class="line">        <span class="comment">//即如果RecyclerView的宽高不是Wrap_Content，到这里测量过程就结束了</span></span><br><span class="line">        <span class="keyword">if</span> (measureSpecModeIsExactly || mAdapter == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//mState是RecyclerView的State对象，这个对象存储了当前RecyclerView的各种状态</span></span><br><span class="line">        <span class="comment">//在RecyclerView中各个组件的交互也是通过State对象来进行的</span></span><br><span class="line">        <span class="comment">//mState初始mLayoutStep为STEP_START</span></span><br><span class="line">        <span class="keyword">if</span> (mState.mLayoutStep == State.STEP_START) &#123;</span><br><span class="line">            <span class="comment">//dispatchLayoutStep1主要对RecyclerView的动画做了处理，没有绘制流程</span></span><br><span class="line">            <span class="comment">//后续在动画中在做说明</span></span><br><span class="line">            dispatchLayoutStep1();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这里widthSpec和heightSpec是RecyclerView默认测量的结果</span></span><br><span class="line">        mLayout.setMeasureSpecs(widthSpec, heightSpec);</span><br><span class="line">        mState.mIsMeasuring = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//实际的测量，会测量childView</span></span><br><span class="line">        dispatchLayoutStep2();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// now we can get the width and height from the children.</span></span><br><span class="line">        mLayout.setMeasuredDimensionFromChildren(widthSpec, heightSpec);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// if RecyclerView has non-exact width and height and if there is at least one child</span></span><br><span class="line">        <span class="comment">// which also has non-exact width &amp; height, we have to re-measure.</span></span><br><span class="line">        <span class="keyword">if</span> (mLayout.shouldMeasureTwice()) &#123;</span><br><span class="line">            mLayout.setMeasureSpecs(</span><br><span class="line">                MeasureSpec.makeMeasureSpec(getMeasuredWidth(), MeasureSpec.EXACTLY),</span><br><span class="line">                MeasureSpec.makeMeasureSpec(getMeasuredHeight(), MeasureSpec.EXACTLY));</span><br><span class="line">            mState.mIsMeasuring = <span class="keyword">true</span>;</span><br><span class="line">            dispatchLayoutStep2();</span><br><span class="line">            <span class="comment">// now we can get the width and height from the children.</span></span><br><span class="line">            mLayout.setMeasuredDimensionFromChildren(widthSpec, heightSpec);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在 <code>onMeasure</code> 方法中，如果我们给 <code>RecyclerView</code> 设置了不是 <code>Wrap_Content</code> 的宽高，那么 <code>RecyclerView</code> 的测量过程很简单，直接使用父控件给定的宽高即可，只有当我们设置为 <code>Wrap_Content</code> 时，才需要先去测量子 View 。</p><p>测量子 View 的过程事实上是在 <code>dispatchLayoutStep2</code> 方法中进行的，这个方法事实上是 Layout 时调用的方法，这个不难理解，因为只有在确定了 Layout 的方式时，才能真正确定子 View 需要多少的屏幕空间</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatchLayoutStep2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    startInterceptRequestLayout();</span><br><span class="line">    onEnterLayoutOrScroll();</span><br><span class="line">    mState.assertLayoutStep(State.STEP_LAYOUT | State.STEP_ANIMATIONS);</span><br><span class="line">    mAdapterHelper.consumeUpdatesInOnePass();</span><br><span class="line">    mState.mItemCount = mAdapter.getItemCount();</span><br><span class="line">    mState.mDeletedInvisibleItemCountSincePreviousLayout = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 2: Run layout</span></span><br><span class="line">    mState.mInPreLayout = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//上述代码基本上就是在往mState中填充RecyclerView的信息，上段代码的注释中也提到State的</span></span><br><span class="line">    <span class="comment">//主要功能就是在RecyclerView各组件间传递信息</span></span><br><span class="line">    mLayout.onLayoutChildren(mRecycler, mState);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>dispatchLayoutStep2</code> 主要的功能就是为 <code>mState</code> 的更新了一些 <code>RecyclerView</code> 的最新状态，然后调用了 <code>LayoutManager</code> 的 <code>onLayoutChildren</code> 方法，值得注意的是这个方法和上个方法一样是用于布局的，所以后面还会调用，这里暂时只说明测量的部分。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLayoutChildren</span><span class="params">(RecyclerView.Recycler recycler, RecyclerView.State state)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//计算锚点信息以及获取边缘的extraSpace，锚点初始化时一般是方向上的第一个View（反转的列表则为最后）</span></span><br><span class="line">    <span class="comment">//细节代码有兴趣可以自行研究</span></span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (mAnchorInfo.mLayoutFromEnd) &#123;</span><br><span class="line">        <span class="comment">// fill towards start</span></span><br><span class="line">        <span class="comment">//通过锚点更新LayoutState信息,更新后LayoutState.next会向上寻找View</span></span><br><span class="line">        updateLayoutStateToFillStart(mAnchorInfo);</span><br><span class="line">        mLayoutState.mExtra = extraForStart;</span><br><span class="line">        fill(recycler, mLayoutState, state, <span class="keyword">false</span>);</span><br><span class="line">        startOffset = mLayoutState.mOffset;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> firstElement = mLayoutState.mCurrentPosition;</span><br><span class="line">        <span class="keyword">if</span> (mLayoutState.mAvailable &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            extraForEnd += mLayoutState.mAvailable;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// fill towards end</span></span><br><span class="line">        <span class="comment">//通过锚点更新LayoutState信息,更新后LayoutState.next会向下寻找View</span></span><br><span class="line">        updateLayoutStateToFillEnd(mAnchorInfo);</span><br><span class="line">        mLayoutState.mExtra = extraForEnd;</span><br><span class="line">        mLayoutState.mCurrentPosition += mLayoutState.mItemDirection;</span><br><span class="line">        fill(recycler, mLayoutState, state, <span class="keyword">false</span>);</span><br><span class="line">        endOffset = mLayoutState.mOffset;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mLayoutState.mAvailable &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// end could not consume all. add more items towards start</span></span><br><span class="line">            extraForStart = mLayoutState.mAvailable;</span><br><span class="line">            updateLayoutStateToFillStart(firstElement, startOffset);</span><br><span class="line">            mLayoutState.mExtra = extraForStart;</span><br><span class="line">            fill(recycler, mLayoutState, state, <span class="keyword">false</span>);</span><br><span class="line">            startOffset = mLayoutState.mOffset;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//这段代码几乎和上段一样，只是填充的方向不同</span></span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中可以看出在 <code>onLayoutChildren</code> 过程中，<code>LinearLayoutManager</code> 是首先确定一个锚点，然后从锚点位置开始向不同方向填充布局。真正的填充部分代码在 <code>fill</code> 方法中</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fill</span><span class="params">(RecyclerView.Recycler recycler, LayoutState layoutState,</span></span></span><br><span class="line"><span class="function"><span class="params">            RecyclerView.State state, <span class="keyword">boolean</span> stopOnFocusable)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// bug修复代码</span></span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//mAvailable是上面的方法中由锚点更新给layoutState的，为指定指定方向上需要填充的距离</span></span><br><span class="line">    <span class="comment">//mExtra也是前面计算的边缘的extraSpace，</span></span><br><span class="line">    <span class="keyword">int</span> remainingSpace = layoutState.mAvailable + layoutState.mExtra;</span><br><span class="line">    LayoutChunkResult layoutChunkResult = mLayoutChunkResult;</span><br><span class="line">    <span class="comment">//由于最开始onMeasure的时候先调用了RecyclerView默认的onMeasure方法，所以这里remainingSpace</span></span><br><span class="line">    <span class="comment">//就是能Recycler能取到的最大值</span></span><br><span class="line">    <span class="keyword">while</span> ((layoutState.mInfinite || remainingSpace &gt; <span class="number">0</span>) &amp;&amp; layoutState.hasMore(state)) &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">//核心代码，用于计算子View需要的空间</span></span><br><span class="line">        layoutChunk(recycler, state, layoutState, layoutChunkResult);</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">//根据layoutChunkResult缩减remainingSpace大小</span></span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> start - layoutState.mAvailable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在 <code>fill</code> 方法中起着比较核心作用的是 <code>layoutChunk</code> 方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">layoutChunk</span><span class="params">(RecyclerView.Recycler recycler, RecyclerView.State state,</span></span></span><br><span class="line"><span class="function"><span class="params">            LayoutState layoutState, LayoutChunkResult result)</span> </span>&#123;</span><br><span class="line">    View view = layoutState.next(recycler);</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//测量ChildView</span></span><br><span class="line">    measureChildWithMargins(view, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    result.mConsumed = mOrientationHelper.getDecoratedMeasurement(view);</span><br><span class="line">    <span class="keyword">int</span> left, top, right, bottom;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//布局ChildView</span></span><br><span class="line">    layoutDecoratedWithMargins(view, left, top, right, bottom);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码其实很清楚了，<code>layoutChunk</code> 方法首先获取的 <code>ChildView</code> ，对它进行测量，然后布局。恩，你没有看错就是布局 <code>Layout</code> ，通过布局方法确定 <code>ChildView</code> 的具体位置，<code>dispatchLayoutStep2</code>方法的深入展开到此结束，让我们回到 <code>onMeasure</code> 的地方在看一下我们没有看完的代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthSpec, <span class="keyword">int</span> heightSpec)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (mLayout.isAutoMeasureEnabled()) &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">//上次的代码到这了</span></span><br><span class="line">        dispatchLayoutStep2();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过ChildView的位置综合父控件给的widthSpec和heightSpec选择合适的宽高</span></span><br><span class="line">        mLayout.setMeasuredDimensionFromChildren(widthSpec, heightSpec);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//重新进行测量，对于LinearLayoutManager来说中如果本身是WARP_CONTENT，</span></span><br><span class="line">        <span class="comment">//同时至少有一个ChildView有不确定（WRAP_CONTENT或者MATCH_PARENT）的宽和高</span></span><br><span class="line">        <span class="keyword">if</span> (mLayout.shouldMeasureTwice()) &#123;</span><br><span class="line">            <span class="comment">//重新走一遍上面的测量</span></span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setMeasuredDimensionFromChildren</span><span class="params">(<span class="keyword">int</span> widthSpec, <span class="keyword">int</span> heightSpec)</span> </span>&#123;</span><br><span class="line">  ......</span><br><span class="line">    <span class="comment">//遍历ChildView，选出坐上右下四个值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        View child = getChildAt(i);</span><br><span class="line">        <span class="keyword">final</span> Rect bounds = mRecyclerView.mTempRect;</span><br><span class="line">        getDecoratedBoundsWithMargins(child, bounds);</span><br><span class="line">        <span class="keyword">if</span> (bounds.left &lt; minX) &#123;</span><br><span class="line">            minX = bounds.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (bounds.right &gt; maxX) &#123;</span><br><span class="line">            maxX = bounds.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (bounds.top &lt; minY) &#123;</span><br><span class="line">            minY = bounds.top;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (bounds.bottom &gt; maxY) &#123;</span><br><span class="line">            maxY = bounds.bottom;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mRecyclerView.mTempRect.set(minX, minY, maxX, maxY);</span><br><span class="line">    <span class="comment">//根据获得的Rect范围综合父控件给的值综合获取最终的宽高</span></span><br><span class="line">    setMeasuredDimension(mRecyclerView.mTempRect, widthSpec, heightSpec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了到此为止，整个测量过程基本上清楚了，下面我们根据一张时序图回顾一下整个流程</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">participant RecyclerView as A</span><br><span class="line">participant LinearLayoutManager as B</span><br><span class="line">A-&gt;A:onMeasure</span><br><span class="line">A-&gt;B:isAutoMeasureEnabled</span><br><span class="line">A-&gt;A:dispatchLayoutStep2</span><br><span class="line">A-&gt;B:onLayoutChildren</span><br><span class="line">B-&gt;B:fill</span><br><span class="line">B-&gt;B:layoutChunk</span><br><span class="line">B-&gt;B:measureChildWithMargins</span><br><span class="line">B-&gt;B:layoutDecoratedWithMargins</span><br><span class="line">A-&gt;B:setMeasuredDimensionFromChildren</span><br><span class="line">A-&gt;B:shouldMeasureTwice</span><br><span class="line">B-&gt;B:calculate measurezise......</span><br><span class="line">B-&gt;A:setMeasuredDimension</span><br></pre></td></tr></table></figure><p>可以看出 <code>RecyclerView</code> 在整个测量过程还是整个流程的主导，<code>LayoutManager</code> 更多像是一个提供具体配置参数的。这个表可以作为我们自定义 <code>LayoutManager</code> 时的一个参考。</p><h3 id="onLayout"><a href="#onLayout" class="headerlink" title="onLayout"></a>onLayout</h3><p>继续看布局的相关方法，首先从 <code>RecyclerView</code> 的 <code>onLayout</code> 方法开始</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    TraceCompat.beginSection(TRACE_ON_LAYOUT_TAG);</span><br><span class="line">    <span class="comment">//直接调用了dispatchLayout</span></span><br><span class="line">    dispatchLayout();</span><br><span class="line">    TraceCompat.endSection();</span><br><span class="line">    mFirstLayoutComplete = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatchLayout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mAdapter == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mLayout == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mState.mIsMeasuring = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//mLayoutStep初始为STEP_START，然后会在dispatchLayoutStep1方法修改为STEP_LAYOUT</span></span><br><span class="line">    <span class="comment">//然后在dispatchLayoutStep2方法中修改为STEP_ANIMATIONS</span></span><br><span class="line">    <span class="comment">//除非若RecyclerView宽高为Wrap_Content，否则此处为STEP_START</span></span><br><span class="line">    <span class="keyword">if</span> (mState.mLayoutStep == State.STEP_START) &#123;</span><br><span class="line">        <span class="comment">//完成一次完整的测量布局</span></span><br><span class="line">        dispatchLayoutStep1();</span><br><span class="line">        mLayout.setExactMeasureSpecsFrom(<span class="keyword">this</span>);</span><br><span class="line">        dispatchLayoutStep2();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mAdapterHelper.hasUpdates() || mLayout.getWidth() != getWidth()</span><br><span class="line">               || mLayout.getHeight() != getHeight()) &#123;</span><br><span class="line">        <span class="comment">//测量布局已经但是，种种原因，大小改变了，需要重新测量布局</span></span><br><span class="line">        <span class="comment">//这个方法把RecyclerView的测量宽高以一EXACTLY的形式给了LayoutManager</span></span><br><span class="line">        mLayout.setExactMeasureSpecsFrom(<span class="keyword">this</span>);</span><br><span class="line">        dispatchLayoutStep2();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// always make sure we sync them (to ensure mode is exact)</span></span><br><span class="line">        mLayout.setExactMeasureSpecsFrom(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    dispatchLayoutStep3();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>onLayout</code> 中 <code>RecyclerView</code> 并没有做什么多余的操作，而是直接调用了 <code>dispatchLayout</code> 方法，这个方法会根据我们在 <code>onMeasure</code> 中的行为判断是否需要调用 <code>dispatchLayoutStep1</code> 和 <code>dispatchLayoutStep2</code> ，但是无论哪种情况都会通过 <code>setExactMeasureSpecsFrom</code> 给 <code>LayoutManager</code> 设置一个确切的宽高，最后调用 <code>dispatchLayoutStep3</code> 方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatchLayoutStep3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//STEP_ANIMATIONS状态就可以看出来，这个方法主要是完成前面dispatchLayoutStep1中</span></span><br><span class="line">    <span class="comment">//设置好的动画</span></span><br><span class="line">    mState.assertLayoutStep(State.STEP_ANIMATIONS);</span><br><span class="line">    startInterceptRequestLayout();</span><br><span class="line">    onEnterLayoutOrScroll();</span><br><span class="line">    mState.mLayoutStep = State.STEP_START;</span><br><span class="line">    <span class="keyword">if</span> (mState.mRunSimpleAnimations) &#123;</span><br><span class="line">        <span class="comment">//这个整段代码全都是动画相关的</span></span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一些状态的置位和资源的释放</span></span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (mLayout.mPrefetchMaxObservedInInitialPrefetch) &#123;</span><br><span class="line">        <span class="comment">// Initial prefetch has expanded cache, so reset until next prefetch.</span></span><br><span class="line">        <span class="comment">// This prevents initial prefetches from expanding the cache permanently.</span></span><br><span class="line">        mLayout.mPrefetchMaxCountObserved = <span class="number">0</span>;</span><br><span class="line">        mLayout.mPrefetchMaxObservedInInitialPrefetch = <span class="keyword">false</span>;</span><br><span class="line">        mRecycler.updateViewCacheSize();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里也是一样，部分状态的初始化</span></span><br><span class="line">    mLayout.onLayoutCompleted(mState);</span><br><span class="line">    onExitLayoutOrScroll();</span><br><span class="line">    stopInterceptRequestLayout(<span class="keyword">false</span>);</span><br><span class="line">    mViewInfoStore.clear();</span><br><span class="line">    <span class="keyword">if</span> (didChildRangeChange(mMinMaxLayoutPositions[<span class="number">0</span>], mMinMaxLayoutPositions[<span class="number">1</span>])) &#123;</span><br><span class="line">        dispatchOnScrolled(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    recoverFocusFromState();</span><br><span class="line">    resetFocusInfo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>￼<img src="./153.jpg" alt=""></p><p>这就结束了？，没错到此为止 <code>LinearLayoutManager</code> 或者说 <code>RecyclerView</code> 的 auto measure 就是这样的，当然 <code>LayoutManager</code> 还有一些其他功能这里还没有涉及到或者没有展开，后面遇到再进行说明。</p><h1 id="Recycler"><a href="#Recycler" class="headerlink" title="Recycler"></a>Recycler</h1><p>按照顺序这里应该是本应该是 <code>Adapter</code> ，但是我发现如果没有 <code>Recycler</code> 存在 <code>Adapter</code> 根本玩不下去，看名字 <code>Recycler</code> 就感觉像是 <code>RecyclerView</code> 的核心，确实它也掌管了所有 <code>ChildView</code> 的生成、复用、回收，确实也是核心，首先我们介绍一下 <code>Recycler</code> 中的几个缓存队列</p><ul><li><p><code>mChangedScrap</code> item被标记为更新、有动画且动画支持变化</p></li><li><p><code>mAttachedScrap</code> </p></li><li><code>mCachedViews</code></li></ul><p><code>Recycler</code> 也还是得从测量过程中的 <code>LayoutChunk</code> 说起，虽然这个 <code>Recycler</code> 对象在一开始 <code>onLayoutChildren</code> 就作为参数传递到了 <code>LayoutManager</code> ，但是一直没有正经的使用它。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">layoutChunk</span><span class="params">(RecyclerView.Recycler recycler, RecyclerView.State state,</span></span></span><br><span class="line"><span class="function"><span class="params">            LayoutState layoutState, LayoutChunkResult result)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//从LayoutState中获取下一个View</span></span><br><span class="line">    View view = layoutState.next(recycler);</span><br><span class="line">    <span class="keyword">if</span> (view == <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="comment">//说明已经没有更多的View，到底或者到顶了</span></span><br><span class="line">        result.mFinished = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LayoutParams params = (LayoutParams) view.getLayoutParams();</span><br><span class="line">    <span class="comment">//mScrapList一般情况下都为null，只有在为动画做准备时才会有内存</span></span><br><span class="line">    <span class="keyword">if</span> (layoutState.mScrapList == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mShouldReverseLayout == (layoutState.mLayoutDirection</span><br><span class="line">                                     == LayoutState.LAYOUT_START)) &#123;</span><br><span class="line">            addView(view);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            addView(view, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//暂时可以不考虑</span></span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">   measureChildWithMargins(view, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">View <span class="title">next</span><span class="params">(RecyclerView.Recycler recycler)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//mScrapList一般情况下都为null，这里暂不考虑</span></span><br><span class="line">    <span class="keyword">if</span> (mScrapList != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> nextViewFromScrapList();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//调用了getViewForPosition来获取真正View</span></span><br><span class="line">    <span class="keyword">final</span> View view = recycler.getViewForPosition(mCurrentPosition);</span><br><span class="line">    mCurrentPosition += mItemDirection;</span><br><span class="line">    <span class="keyword">return</span> view;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> View <span class="title">getViewForPosition</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getViewForPosition(position, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">View <span class="title">getViewForPosition</span><span class="params">(<span class="keyword">int</span> position, <span class="keyword">boolean</span> dryRun)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> tryGetViewHolderForPositionByDeadline(position, dryRun, FOREVER_NS).itemView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>layoutChunk</code> 根本意义上说也还没有使用 <code>Recycler</code> 对象，但是这里算上获取 <code>childView</code> 的一个起点，所以我们从这里开始分析，后续的几个方法也都没有做太多工作。到了 <code>tryGetViewHolderForPositionByDeadline</code> 真正的逻辑开始了。代码之前我们先整理一下逻辑，这个方法的的主要工作如下</p><ol><li>如果进行了 <code>PreLayout</code> 则会优先从 <code>mChangedScrap</code> 中查找 <code>ViewHolder</code> , <code>PreLayout</code> 这个行为发生在 <code>dispatchLayoutStep1</code> 中，虽然是 <code>PreLayout</code> 但是终究还是会去 <code>onLayoutChildren</code> ，然后最后还是会调用 <code>tryGetViewHolderForPositionByDeadline</code> ，所以本质上来说第一次来步骤1肯定会跳过 </li><li></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">ViewHolder <span class="title">tryGetViewHolderForPositionByDeadline</span><span class="params">(<span class="keyword">int</span> position,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">boolean</span> dryRun, <span class="keyword">long</span> deadlineNs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (position &lt; <span class="number">0</span> || position &gt;= mState.getItemCount()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(...);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> fromScrapOrHiddenOrCache = <span class="keyword">false</span>;</span><br><span class="line">    ViewHolder holder = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 0) If there is a changed scrap, try to find from there</span></span><br><span class="line">    <span class="keyword">if</span> (mState.isPreLayout()) &#123;</span><br><span class="line">        holder = getChangedScrapViewForPosition(position);</span><br><span class="line">        fromScrapOrHiddenOrCache = holder != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1) Find by position from scrap/hidden list/cache</span></span><br><span class="line">    <span class="keyword">if</span> (holder == <span class="keyword">null</span>) &#123;</span><br><span class="line">        holder = getScrapOrHiddenOrCachedHolderForPosition(position, dryRun);</span><br><span class="line">        <span class="keyword">if</span> (holder != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!validateViewHolderForOffsetPosition(holder)) &#123;</span><br><span class="line">                <span class="comment">// recycle holder (and unscrap if relevant) since it can't be used</span></span><br><span class="line">                <span class="keyword">if</span> (!dryRun) &#123;</span><br><span class="line">                    <span class="comment">// we would like to recycle this but need to make sure it is not used by</span></span><br><span class="line">                    <span class="comment">// animation logic etc.</span></span><br><span class="line">                    holder.addFlags(ViewHolder.FLAG_INVALID);</span><br><span class="line">                    <span class="keyword">if</span> (holder.isScrap()) &#123;</span><br><span class="line">                        removeDetachedView(holder.itemView, <span class="keyword">false</span>);</span><br><span class="line">                        holder.unScrap();</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (holder.wasReturnedFromScrap()) &#123;</span><br><span class="line">                        holder.clearReturnedFromScrapFlag();</span><br><span class="line">                    &#125;</span><br><span class="line">                    recycleViewHolderInternal(holder);</span><br><span class="line">                &#125;</span><br><span class="line">                holder = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                fromScrapOrHiddenOrCache = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (holder == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> offsetPosition = mAdapterHelper.findPositionOffset(position);</span><br><span class="line">        <span class="keyword">if</span> (offsetPosition &lt; <span class="number">0</span> || offsetPosition &gt;= mAdapter.getItemCount()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(...);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> type = mAdapter.getItemViewType(offsetPosition);</span><br><span class="line">        <span class="comment">// 2) Find from scrap/cache via stable ids, if exists</span></span><br><span class="line">        <span class="keyword">if</span> (mAdapter.hasStableIds()) &#123;</span><br><span class="line">            holder = getScrapOrCachedViewForId(mAdapter.getItemId(offsetPosition),</span><br><span class="line">                                               type, dryRun);</span><br><span class="line">            <span class="keyword">if</span> (holder != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// update position</span></span><br><span class="line">                holder.mPosition = offsetPosition;</span><br><span class="line">                fromScrapOrHiddenOrCache = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (holder == <span class="keyword">null</span> &amp;&amp; mViewCacheExtension != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// We are NOT sending the offsetPosition because LayoutManager does not</span></span><br><span class="line">            <span class="comment">// know it.</span></span><br><span class="line">            <span class="keyword">final</span> View view = mViewCacheExtension</span><br><span class="line">                .getViewForPositionAndType(<span class="keyword">this</span>, position, type);</span><br><span class="line">            <span class="keyword">if</span> (view != <span class="keyword">null</span>) &#123;</span><br><span class="line">                holder = getChildViewHolder(view);</span><br><span class="line">                <span class="keyword">if</span> (holder == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(...);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (holder.shouldIgnore()) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(...);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (holder == <span class="keyword">null</span>) &#123; <span class="comment">// fallback to pool</span></span><br><span class="line">           </span><br><span class="line">            holder = getRecycledViewPool().getRecycledView(type);</span><br><span class="line">            <span class="keyword">if</span> (holder != <span class="keyword">null</span>) &#123;</span><br><span class="line">                holder.resetInternal();</span><br><span class="line">                <span class="keyword">if</span> (FORCE_INVALIDATE_DISPLAY_LIST) &#123;</span><br><span class="line">                    invalidateDisplayListInt(holder);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (holder == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> start = getNanoTime();</span><br><span class="line">            <span class="keyword">if</span> (deadlineNs != FOREVER_NS</span><br><span class="line">                &amp;&amp; !mRecyclerPool.willCreateInTime(type, start, deadlineNs)) &#123;</span><br><span class="line">                <span class="comment">// abort - we have a deadline we can't meet</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            holder = mAdapter.createViewHolder(RecyclerView.<span class="keyword">this</span>, type);</span><br><span class="line">            <span class="keyword">if</span> (ALLOW_THREAD_GAP_WORK) &#123;</span><br><span class="line">                <span class="comment">// only bother finding nested RV if prefetching</span></span><br><span class="line">                RecyclerView innerView = findNestedRecyclerView(holder.itemView);</span><br><span class="line">                <span class="keyword">if</span> (innerView != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    holder.mNestedRecyclerView = <span class="keyword">new</span> WeakReference&lt;&gt;(innerView);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">long</span> end = getNanoTime();</span><br><span class="line">            mRecyclerPool.factorInCreateTime(type, end - start);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This is very ugly but the only place we can grab this information</span></span><br><span class="line">    <span class="comment">// before the View is rebound and returned to the LayoutManager for post layout ops.</span></span><br><span class="line">    <span class="comment">// We don't need this in pre-layout since the VH is not updated by the LM.</span></span><br><span class="line">    <span class="keyword">if</span> (fromScrapOrHiddenOrCache &amp;&amp; !mState.isPreLayout() &amp;&amp; holder</span><br><span class="line">        .hasAnyOfTheFlags(ViewHolder.FLAG_BOUNCED_FROM_HIDDEN_LIST)) &#123;</span><br><span class="line">        holder.setFlags(<span class="number">0</span>, ViewHolder.FLAG_BOUNCED_FROM_HIDDEN_LIST);</span><br><span class="line">        <span class="keyword">if</span> (mState.mRunSimpleAnimations) &#123;</span><br><span class="line">            <span class="keyword">int</span> changeFlags = ItemAnimator</span><br><span class="line">                .buildAdapterChangeFlagsForAnimations(holder);</span><br><span class="line">            changeFlags |= ItemAnimator.FLAG_APPEARED_IN_PRE_LAYOUT;</span><br><span class="line">            <span class="keyword">final</span> ItemHolderInfo info = mItemAnimator.recordPreLayoutInformation(mState,</span><br><span class="line">                                                                                 holder, changeFlags, holder.getUnmodifiedPayloads());</span><br><span class="line">            recordAnimationInfoIfBouncedHiddenView(holder, info);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> bound = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (mState.isPreLayout() &amp;&amp; holder.isBound()) &#123;</span><br><span class="line">        <span class="comment">// do not update unless we absolutely have to.</span></span><br><span class="line">        holder.mPreLayoutPosition = position;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!holder.isBound() || holder.needsUpdate() || holder.isInvalid()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG &amp;&amp; holder.isRemoved()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(...);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> offsetPosition = mAdapterHelper.findPositionOffset(position);</span><br><span class="line">        bound = tryBindViewHolderByDeadline(holder, offsetPosition, position, deadlineNs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ViewGroup.LayoutParams lp = holder.itemView.getLayoutParams();</span><br><span class="line">    <span class="keyword">final</span> LayoutParams rvLayoutParams;</span><br><span class="line">    <span class="keyword">if</span> (lp == <span class="keyword">null</span>) &#123;</span><br><span class="line">        rvLayoutParams = (LayoutParams) generateDefaultLayoutParams();</span><br><span class="line">        holder.itemView.setLayoutParams(rvLayoutParams);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!checkLayoutParams(lp)) &#123;</span><br><span class="line">        rvLayoutParams = (LayoutParams) generateLayoutParams(lp);</span><br><span class="line">        holder.itemView.setLayoutParams(rvLayoutParams);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        rvLayoutParams = (LayoutParams) lp;</span><br><span class="line">    &#125;</span><br><span class="line">    rvLayoutParams.mViewHolder = holder;</span><br><span class="line">    rvLayoutParams.mPendingInvalidate = fromScrapOrHiddenOrCache &amp;&amp; bound;</span><br><span class="line">    <span class="keyword">return</span> holder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;免责声明：&lt;/strong&gt; 这篇文章还没有写完，发布的原因是因为我懒的放到草稿箱了，如有错误或者以后请勿怪&lt;/p&gt;
&lt;h1 id=&quot;RecyclerView介绍&quot;&gt;&lt;a href=&quot;#RecyclerView介绍&quot; class=&quot;
      
    
    </summary>
    
    
      <category term="Android" scheme="http://haojen.github.io/tags/Android/"/>
    
      <category term="View" scheme="http://haojen.github.io/tags/View/"/>
    
  </entry>
  
  <entry>
    <title>ThreadLocal详解</title>
    <link href="http://haojen.github.io/2018/07/19/ThreadLocal%E8%AF%A6%E8%A7%A3/"/>
    <id>http://haojen.github.io/2018/07/19/ThreadLocal详解/</id>
    <published>2018-07-19T02:18:26.000Z</published>
    <updated>2018-07-19T05:39:02.387Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ThreadLocal是什么"><a href="#ThreadLocal是什么" class="headerlink" title="ThreadLocal是什么"></a>ThreadLocal是什么</h2><p><code>ThreadLocal</code>是java中处理并发问题的一种方式，但是和<code>Synchronized</code>、<code>volatile</code>等进程同步关键字不同，<code>ThreadLocal</code>主要用于进程隔离，即每一个线程都有一个自己的<code>ThreadLocal</code>，访问时访问的都是线程持有的对象，无法访问其他线程的<code>ThreadLocal</code>,也就不存在并发的问题。</p><h2 id="ThreadLocal使用"><a href="#ThreadLocal使用" class="headerlink" title="ThreadLocal使用"></a>ThreadLocal使用</h2><p><code>ThreadLocal</code>使用起来类似一个数据封装类，使用set和get方法设置和获取存储的内容</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建ThreadLocal对象，使用泛型制定类型</span></span><br><span class="line">ThreadLocal&lt;Integer&gt; localInt = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"><span class="comment">//写入内容</span></span><br><span class="line">localInt.set(<span class="number">10</span>);</span><br><span class="line"><span class="comment">//获取内容</span></span><br><span class="line"><span class="keyword">assert</span> locaInt.get()==<span class="number">10</span>;</span><br></pre></td></tr></table></figure><p><code>ThreadLocal</code>特殊的地方就在于不同线程间是无法获取到其它线程的相应对象的，在多线程场景中对ThreadLocal的使用实例如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ThreadLocal&lt;Integer&gt; localInt = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">Thread threadA = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">100</span>;i&lt;<span class="number">200</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                localInt.set(i);</span><br><span class="line">                sleep(<span class="number">10</span>);</span><br><span class="line">                <span class="keyword">assert</span> localInt.get()==i;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">super</span>.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Thread threadB = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                localInt.set(i);</span><br><span class="line">                sleep(<span class="number">10</span>);</span><br><span class="line">                <span class="keyword">assert</span> localInt.get()==i;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">super</span>.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">threadA.start();</span><br><span class="line">threadB.start();</span><br></pre></td></tr></table></figure><p>ThreadA和ThreadB中<code>ThreadLocal</code>是不会相互影响的，他们每次从<code>ThreadLocal</code>中获取的都是线程内部的相应数据。</p><p>在上面的例子中我们只是用<code>ThreadLocal</code>存储了一个变量，如果想要同时拥有多个线程私有的变量就只能创建多个<code>TreadLocal</code>对象。</p><h2 id="ThreadLocal实现原理"><a href="#ThreadLocal实现原理" class="headerlink" title="ThreadLocal实现原理"></a>ThreadLocal实现原理</h2><p><code>ThreadLocal</code>看上去很神奇，原理其实并不难，它只是把我们的变量关联到了线程的<code>Thread</code>对象上，我们借助<code>ThreadLocal</code>的set方法来说明这点。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在我们通过set方法设置<code>ThreadLocal</code>的内容是，它首先获取当前的<code>Thread</code>对象，同时获取<code>Thread</code>上的<code>ThreadLocalMap</code>，<code>ThreadLocalMap</code>事实上是hash表的一种实现，set事实上是把<code>ThreadLocal</code>对象和相应的value分别作为key和value保证在了这个map中，也就是说我们的value保存在Thread对象内。</p><p><img src="ThreadLocal.png" alt="ThreadLocal"></p><p>get方法也是类似的，我们使用get方法获取值的时候，首先是获取currentThread，然后通过<code>Thread</code>的<code>ThreadLocalMap</code>用<code>ThreadLocal</code>作为key获取对应的value。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果没有创建过<code>ThreadLocalMap</code>，<code>setInitialValue</code>会创建<code>ThreadLocalMap</code>同时返回null。</p><h2 id="ThreadLocal内存泄漏"><a href="#ThreadLocal内存泄漏" class="headerlink" title="ThreadLocal内存泄漏"></a>ThreadLocal内存泄漏</h2><p>正常来说<code>ThreadLocal</code>的对象和其保存的value持有在一个普通的对象内，而在保存时他们会作为key和value保存在<code>Thread</code>对象的map内，线程一般拥有比普通对象更长的生命周期，特别是对于线程池中的线程。</p><p>这种情况下作为key的<code>ThreadLocal</code>和value就有泄漏的风险，<code>ThreadLocal</code>的设计上自然也考虑到了这点，因此<code>ThreadLocalMap</code>中Key都是作为弱引用存在的</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="keyword">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样当持有<code>ThreadLocal</code>的对象销毁后，没有强引用的<code>ThreadLocal</code>也会很快被回收，但是与之对应的value却没法被自动回收。</p><p>事实上<code>ThreadLocalMap</code>对于这样的情况也是有所处理，即<code>ThreadLocalMap</code>在每次set或者get时发现有key为空的元素，都会把它清理掉</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class="line"> ......</span><br><span class="line">    <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">    e != <span class="keyword">null</span>;</span><br><span class="line">    e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">    ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//清理掉key==null的元素</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            replaceStaleEntry(key, value, i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是即使这样光靠<code>ThreadLocalMap</code>也没有办法完全避免value的内存泄漏，最好的就是每次使用完<code>ThreadLocal</code>后都调用它的remove方法，清除数据。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;ThreadLocal是什么&quot;&gt;&lt;a href=&quot;#ThreadLocal是什么&quot; class=&quot;headerlink&quot; title=&quot;ThreadLocal是什么&quot;&gt;&lt;/a&gt;ThreadLocal是什么&lt;/h2&gt;&lt;p&gt;&lt;code&gt;ThreadLocal&lt;/cod
      
    
    </summary>
    
    
      <category term="Android" scheme="http://haojen.github.io/tags/Android/"/>
    
      <category term="线程" scheme="http://haojen.github.io/tags/%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Android线程池</title>
    <link href="http://haojen.github.io/2018/07/16/Android%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>http://haojen.github.io/2018/07/16/Android线程池/</id>
    <published>2018-07-16T06:09:26.000Z</published>
    <updated>2018-07-19T02:25:35.988Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么使用线程池"><a href="#为什么使用线程池" class="headerlink" title="为什么使用线程池"></a>为什么使用线程池</h2><p>线程是操作系统能进行运算调度的最小单元，在Java 中直接使用线程，给我们带来了很多便利，但是线程的使用同时也存在一些问题</p><ul><li>线程生命周期的开销非常高，即在线程的创建和销毁过程都会消耗较大的cpu资源</li><li>资源消耗，线程的存在期间会消耗系统资源，尤其是内存（短时间内高并发任务尤其需要注意）</li></ul><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>线程池就是一种线程复用的手段，它通过缓存已有线程，来减小线程创建过程的消耗，它通过控制线程数量来控制线程存在的系统消耗，同时他把任务和任务的执行进行了解耦，把任务本身和任务的执行过程分离。这一点从Executor就可以看出</p><pre><code>public interface Executor {    void execute(Runnable command);}</code></pre><p>任务封装成Runnable，通过execute在内部通过缓存的线程对任务进行处理，对于Runnable这个任务而言，具体的执行策略它毫不知晓，同时我们可以有极大的空间来制定执行策略。</p><h2 id="构造线程池"><a href="#构造线程池" class="headerlink" title="构造线程池"></a>构造线程池</h2><p>线程池给我们创造了极大扩展空间用于管理线程资源和定义任务的执行策略，同时为了更加方便我们使用，Java定义了一些配置成型的线程池供我们使用，这些线程池可以通过Executors这样一个工厂类获取</p><ul><li>newFixedThreadPool。newFixedThreadPool会创建一个固定长度的线程池，每当提交一个任务时，就会创建一个线程（即使有空闲的线程），直到达到线程最大值。</li><li>newCachedThreadPool。newCachedThreadPool会创建一个可缓存的线程池，任务提交时没有空闲的线程就会创建新的线程，且这个过程没有上线，当线程执行完成后60s内没有被其他任务复用就会被销毁。</li><li>newSingleThreadExecutor。newSingleThreadExecutor是一个单线程的Executor，一般按照FIFO的顺序执行（不同于我们自己创建的单线程Thread，如果Thread不慎挂掉，会创建一个新的线程保证运行过程）</li><li>newSingleThreadExecutor。创建一个固定长度线程池，会使用延迟或者定时的方式来执行任务。</li></ul><p>上面列举了几个Java中提供好的线程策略，类似的在Executors中还有很多，这里不一一列举，本质上来说，这些方法是对现有的几个线程池实现类的一种配置方式，具体线程池的复用以及调度的方式是怎么样的呢？</p><h2 id="线程池调度策略"><a href="#线程池调度策略" class="headerlink" title="线程池调度策略"></a>线程池调度策略</h2><h3 id="调度内容"><a href="#调度内容" class="headerlink" title="调度内容"></a>调度内容</h3><p>线程池是对线程的一个管理，它到底管理什么东西</p><ul><li>使用什么线程执行任务</li><li>任务执行顺序</li><li>有多少任务可以同时处理</li><li>能够有多少任务等待，如果需要执行的任务超过这个上限如何处理</li><li>任务运行时出现异常怎么处理</li><li>任务前后有哪些动作</li></ul><h3 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h3><p>我们使用的绝大部分线程池最终的实现类都是ThreadPoolExecutor，我们可以通过这个对象来真正了解线程池，首先是ThreadPoolExecutor的构造方法</p><pre><code>public ThreadPoolExecutor(int corePoolSize,                         int maximumPoolSize,                         long keepAliveTime,                         TimeUnit unit,                         BlockingQueue&lt;Runnable&gt; workQueue,                         ThreadFactory threadFactory,                         RejectedExecutionHandler handler)</code></pre><p>从构造方法可以看出很多内容，ThreadPoolExecutor中的线程分为普通线程和核心线程，有线程存活时间，任务等待队列，线程工厂，任务拒绝的handler。</p><h3 id="核心线程数和最大线程数"><a href="#核心线程数和最大线程数" class="headerlink" title="核心线程数和最大线程数"></a>核心线程数和最大线程数</h3><p>关于核心线程和最大线程可以看一下execute方法的一段代码</p><pre><code>//线程数小于核心线程直接添加新线程执行int c = ctl.get();if (workerCountOf(c) &lt; corePoolSize) {        if (addWorker(command, true))            return;        c = ctl.get();}//将任务放入等待队列，同时检测线程池运行状态并处理if (isRunning(c) &amp;&amp; workQueue.offer(command)) {    int recheck = ctl.get();    //线程池状态改变（不是运行状态）直接打回任务    if (! isRunning(recheck) &amp;&amp; remove(command))        reject(command);    else if (workerCountOf(recheck) == 0)        addWorker(null, false);//等待队列满了，试图添加新线程，如果失败打回任务//（当线程数以达到最大线程数则会失败）}else if (!addWorker(command, false))    reject(command);</code></pre><p>ctl是一个AtomicInteger类型，它用前3位标示线程池运行状态，后面位数表示已有的线程数量，当线程池新增一个任务时，会有四种情况</p><ol><li>当前线程数小于核心线程数，直接新建线程执行任务</li><li>大于核心线程数，等待队列未满，直接进入队列</li><li>等待队列已满，且小于最大线程数，直接新建线程执行任务</li><li>都不满足，打回任务</li></ol><p>可以看出即使等待队列时FIFO，任务也不一定会完成按照我们添加的顺序执行，当等待队列满的时候，一部分任务会优先执行。</p><h3 id="线程复用与回收"><a href="#线程复用与回收" class="headerlink" title="线程复用与回收"></a>线程复用与回收</h3><p>线程池最大的特点就是线程的复用，同时还有上一节中的非核心线程的回收，本质上来说核心线程和非核心线程没有去吧，他们都存储在一个集合中</p><pre><code>private final HashSet&lt;Worker&gt; workers = new HashSet&lt;&gt;();</code></pre><p>线程池中的线程都使用Worker进行封装，线程复用的过程也是借助Workder来进行的，Worker的主要代码如下</p><pre><code> private final class Worker extends AbstractQueuedSynchronizer    implements Runnable{    ......    final Thread thread;    Runnable firstTask;    ......    Worker(Runnable firstTask) {        setState(-1); // inhibit interrupts until runWorker        this.firstTask = firstTask;        this.thread = getThreadFactory().newThread(this);    }    /** Delegates main run loop to outer runWorker. */    public void run() {        runWorker(this);    }    ......}</code></pre><p>我们可以看到Worker本身就是Runnable，他在创建内部线程的同时只是把自己作为参数传递进去，最终thread.start运行时执行的就是Worker的run方法，同时这里会调用ThreadPoolExecutor的runWorker方法以完成最终的线程调度。</p><pre><code>final void runWorker(Worker w) {    Thread wt = Thread.currentThread();    Runnable task = w.firstTask;    ......    try {        //getTask从等待队列中获取下一个task        while (task != null || (task = getTask()) != null) {            ......            try {                beforeExecute(wt, task);                Throwable thrown = null;                try {                    task.run();                } catch (RuntimeException x) {                    thrown = x; throw x;                } catch (Error x) {                    thrown = x; throw x;                } catch (Throwable x) {                    thrown = x; throw new Error(x);                } finally {                    afterExecute(task, thrown);                }            } finally {                task = null;                w.completedTasks++;                w.unlock();            }        }        completedAbruptly = false;    } finally {        processWorkerExit(w, completedAbruptly);    }}</code></pre><p>可以看到在runWorker方法里，Worker内的task为空，会从等待队列中获取一个新的task并执行，同时会调用beforeExecute和afterExecute这两个生命周期方法，同时当任务队列没有清空或者没有异常发生时，这是一个死循环，如果跳出循环，则说明要么任务队列被清空，要么线程异常结束，processWorkerExit会处理这些情况，如果是异常结束会起一个新的线程，否则则会移除大于核心线程数的线程，到此线程的复用过程基本清楚了</p><p>我们可以看到ThreadPoolExecutor还有一个keepAliveTime的参数用于空闲时回收非核心线程的时机，这个过程事实上是在getTask获取下一个任务时进行的</p><pre><code>​private Runnable getTask() {    boolean timedOut = false; // Did the last poll() time out?    for (;;) {        int c = ctl.get();        ......        int wc = workerCountOf(c);        // Are workers subject to culling?        boolean timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;        ......        try {            Runnable r = timed ?                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :                workQueue.take();            if (r != null)                return r;            timedOut = true;        } catch (InterruptedException retry) {            timedOut = false;        }    }}</code></pre><p>可以看到当目前的线程数大于核心线程数时，获取任务时会执行workQueue.poll方法，这个方法在队列空时会等待给定的时间然后才会返回，如果在规定的时间仍然没有新的任务，则会在上面的processWorkerExit回收线程。</p><p>除此之外线程池还有等待队列、线程工厂、任务拒绝的handler等要点，由于时间有限，这里暂时不一一说明，以后有时间再做补充，大家也可自行探索。</p><h2 id="需要注意的问题"><a href="#需要注意的问题" class="headerlink" title="需要注意的问题"></a>需要注意的问题</h2><p>线程池十分好用，但是使用中也有些需要注意的点，这里我稍稍列举一些，希望大家使用中可以注意</p><ul><li>不要使用线程池执行可能会相互依赖的任务，因为线程池不一定能保证执行顺序，很有可能会发生线程死锁</li><li>任务需要考虑可能出现的同步问题，因为任务不是在单线程环境下运行</li><li>对时间敏感的任务，不要使用线程池，因为线程池可以保证执行但是无法保证执行的时间</li><li>运行时间较长的任务尽量不要和时间较短的任务一起执行，这会严重影响短耗时任务的执行效率</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;为什么使用线程池&quot;&gt;&lt;a href=&quot;#为什么使用线程池&quot; class=&quot;headerlink&quot; title=&quot;为什么使用线程池&quot;&gt;&lt;/a&gt;为什么使用线程池&lt;/h2&gt;&lt;p&gt;线程是操作系统能进行运算调度的最小单元，在Java 中直接使用线程，给我们带来了很多便利，但
      
    
    </summary>
    
    
      <category term="Android" scheme="http://haojen.github.io/tags/Android/"/>
    
      <category term="线程" scheme="http://haojen.github.io/tags/%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Android权限管理</title>
    <link href="http://haojen.github.io/2018/07/11/Android%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/"/>
    <id>http://haojen.github.io/2018/07/11/Android权限管理/</id>
    <published>2018-07-11T06:26:22.000Z</published>
    <updated>2018-07-19T02:25:27.302Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Android动态权限"><a href="#Android动态权限" class="headerlink" title="Android动态权限"></a>Android动态权限</h2><p>Android6.0（API23）开始，系统权限出现了很大的变化，此前在权限的检查和获取只发生在app安装时，同时获取后可以一直享有权限。在6.0以后，一些敏感的权限需要动态的获取，同时每次用户可以随时关闭权限，因此需要在每次使用前进行权限检查和获取。</p><h2 id="权限等级"><a href="#权限等级" class="headerlink" title="权限等级"></a>权限等级</h2><p>6.0以后也不是所有权限的获取都需要动态的申请，权限被分成了几个等级，权限的等级主要有四种，分别是Normal、Signature、Dangerous和SignatureOrSystem。</p><ul><li>Normal等级：任何应用都可以申请，直接在manifest声明，安装时提示用户，之后会自动获取此类权限。</li><li>Dangerous等级：任何应用都可以申请，需要在manifest中声明，同时在使用时需要动态的获取权限。</li><li>Signature等级：只有与声明权限的apk使用相同的签名私钥才能申请权限。</li><li>SignatureOrSystem:只有与声明权限的apk使用相同的签名私钥或者在/system/app目录下的应用才能申请权限。</li></ul><p>这四种权限都是在manifest中声明权限时指定的，在普通的应用开发中我们一般需要关注的只有Normal和Dangerous两种，其中需要动态申请权限的只有Dangerous权限。</p><h2 id="Dangerous权限"><a href="#Dangerous权限" class="headerlink" title="Dangerous权限"></a>Dangerous权限</h2><p>Android下所有的Dangerous权限都被分成权限组，在动态申请权限时，申请的时提示给用户的信息都以组为单位的，比如如果app申请<code>READ_CONTACTS</code>权限,那么系统仅仅提示用户申请联系人权限，如果用户允许，在8.0以下的版本中同组的<code>WRITE_CONTACTS</code>也会一并被获取到，而在8.0及以上<code>WRITE_CONTACTS</code>权限还需要我们去动态的申请，但是系统会立即授予该权限而不会提示用户。</p><p>Dangerous权限分组</p><table><thead><tr><th>权限组</th><th>权限</th></tr></thead><tbody><tr><td>CALENDAR</td><td>READ_CALENDAR<br>WRITE_CALENDAR</td></tr><tr><td>CAMERA</td><td>CAMERA</td></tr><tr><td>CONTACTS</td><td>READ_CONTACTS<br>WRITE_CONTACTS<br>GET_ACCOUNTS</td></tr><tr><td>LOCATION</td><td>ACCESS_FINE_LOCATION<br>ACCESS_COARSE_LOCATION</td></tr><tr><td>MICROPHONE</td><td>RECORD_AUDIO</td></tr><tr><td>PHONE</td><td>READ_PHONE_STATE<br>READ_PHONE_NUMBERS<br>CALL_PHONE<br>ANSWER_PHONE_CALLS<br>READ_CALL_LOG<br>WRITE_CALL_LOG<br>ADD_VOICEMAIL<br>USE_SIP<br>PROCESS_OUTGOING_CALLS</td></tr><tr><td>SENSORS</td><td>BODY_SENSORS</td></tr><tr><td>SMS</td><td>SEND_SMS<br>RECEIVE_SMS<br>READ_SMS<br>RECEIVE_WAP_PUSH<br>RECEIVE_MMS</td></tr><tr><td>STORAGE</td><td>READ_EXTERNAL_STORAGE<br>WRITE_EXTERNAL_STORAGE</td></tr></tbody></table><h2 id="动态权限申请"><a href="#动态权限申请" class="headerlink" title="动态权限申请"></a>动态权限申请</h2><h3 id="申明权限"><a href="#申明权限" class="headerlink" title="申明权限"></a>申明权限</h3><p>对于Dangerous的权限，我们首先也需要在manifest中申请，这里以联系人权限为例</p><pre><code>&lt;uses-permission android:name=&quot;android.permission.READ_CONTACTS&quot;/&gt;&lt;uses-permission android:name=&quot;android.permission.WRITE_CONTACTS&quot;/&gt;</code></pre><h3 id="权限检查"><a href="#权限检查" class="headerlink" title="权限检查"></a>权限检查</h3><p>在使用试图操作联系人前需要首先确认有没有这个权限</p><pre><code>if(ContextCompat.checkSelfPermission(this, Manifest.permission.READ_CONTACTS)            != PackageManager.PERMISSION_GRANTED){    //申请权限    }else{      //读取联系人}</code></pre><p><code>ContextCompat.checkSelfPermission(Context context,  String permission)</code>方法用于检查App是否拥有参数指定的权限，方法的返回值为int，可能的取值如下</p><ul><li><p><code>PERMISSION_GRANTED</code> 已经获取权限</p></li><li><p><code>PERMISSION_DENIED</code> 还没有获取权限</p></li></ul><h3 id="权限申请"><a href="#权限申请" class="headerlink" title="权限申请"></a>权限申请</h3><p>如果尚未获取权限则在使用之前需要先申请权限</p><pre><code>ActivityCompat.requestPermissions(this,                new String[]{Manifest.permission.READ_CONTACTS},CODE_REQUEST_CONTACTS);</code></pre><p>一般情况下，<code>ActivityCompat.requestPermissions</code>方法会使用一个标准的对话框提示用户，但是有些机型则会跳转到一个新的页面做这件事（会导致Activity声明周期变化，甚至重启）。</p><p>申请之后则需要等待用户选择，如果如果你的<code>Activity</code>不是继承自<code>AppCompatActivity</code>，则需要实现<code>OnRequestPermissionsResultCallback</code>用于接收权限请求的结果回掉。</p><pre><code>public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {    super.onRequestPermissionsResult(requestCode, permissions, grantResults);    if(requestCode==CODE_REQUEST_CONTACTS){        if(grantResults[0]==PackageManager.PERMISSION_GRANTED){            //读取联系人        }else{            //权限获取失败        }    }}</code></pre><h3 id="合理的权限申请"><a href="#合理的权限申请" class="headerlink" title="合理的权限申请"></a>合理的权限申请</h3><p>用户首次拒绝授予权限之后，当第二次进行权限请求时，会出现“不再提示”的选项，如果用户勾选，则后续对此权限的申请将不再提示用户，直接失败。因此我们需要在合适的时机解释获取权限的原因，我们可以使用<code>ActivityCompat.shouldShowRequestPermissionRationale</code>方法来确定是否需要告知用户，这个方法默认情况下返回false，当用户拒绝过授予此权限后，这个返回值为true（用户勾选不再提示后返回值为false）。</p><pre><code>if (ContextCompat.checkSelfPermission(this, Manifest.permission.READ_CONTACTS)            != PackageManager.PERMISSION_GRANTED) {    if (ActivityCompat.shouldShowRequestPermissionRationale(this,                Manifest.permission.READ_CONTACTS)) {        //提示用户后申请权限    } else {        //申请权限        ActivityCompat.requestPermissions(this,                new String[]{Manifest.permission.READ_CONTACTS}, CODE_REQUEST_CONTACTS);    }} else {    //读取联系人}</code></pre><h3 id="权限被拒绝"><a href="#权限被拒绝" class="headerlink" title="权限被拒绝"></a>权限被拒绝</h3><p>权限被拒绝后，再次申请会继续弹出，但是当用户勾选“不再提示”后，下次权限申请系统将不再提示用户，而是直接拒绝，这种情况下，我们只能引导用户到设置里自己打开权限，我们可以在<code>onRequestPermissionsResult</code>中通过<code>ActivityCompat.shouldShowRequestPermissionRationale</code>来判断用户是否选择了不再提示。</p><pre><code>public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {    if (requestCode == CODE_REQUEST_CONTACTS) {        if (grantResults[0] == PackageManager.PERMISSION_GRANTED) {            //读取联系人        } else {            if(!ActivityCompat.shouldShowRequestPermissionRationale(this,                    Manifest.permission.READ_CONTACTS)){               //引导用户到设置页面开启权限            }        }    }}//跳转到设置页面相关代码Intent intent = new Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS);Uri uri = Uri.fromParts(&quot;package&quot;,getApplicationContext().getPackageName(), null);intent.setData(uri);startActivity(intent);</code></pre><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://blog.csdn.net/u013553529/article/details/53167072" target="_blank" rel="noopener">Android 权限的一些细节</a> </li><li><a href="https://blog.csdn.net/jltxgcy/article/details/48288467" target="_blank" rel="noopener">Android中的权限管理</a></li><li><a href="https://blog.csdn.net/lmj623565791/article/details/50709663" target="_blank" rel="noopener">Android 6.0 运行时权限处理完全解析</a></li><li><a href="https://www.jianshu.com/p/a51593817825" target="_blank" rel="noopener">Android6.0动态权限申请步骤以及需要注意的一些坑</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Android动态权限&quot;&gt;&lt;a href=&quot;#Android动态权限&quot; class=&quot;headerlink&quot; title=&quot;Android动态权限&quot;&gt;&lt;/a&gt;Android动态权限&lt;/h2&gt;&lt;p&gt;Android6.0（API23）开始，系统权限出现了很大的变化，此
      
    
    </summary>
    
    
      <category term="Android" scheme="http://haojen.github.io/tags/Android/"/>
    
      <category term="permission" scheme="http://haojen.github.io/tags/permission/"/>
    
  </entry>
  
  <entry>
    <title>AndrodUI测试入门</title>
    <link href="http://haojen.github.io/2018/03/05/AndrodUI%E6%B5%8B%E8%AF%95%E5%85%A5%E9%97%A8/"/>
    <id>http://haojen.github.io/2018/03/05/AndrodUI测试入门/</id>
    <published>2018-03-05T09:11:28.000Z</published>
    <updated>2018-07-19T02:25:31.985Z</updated>
    
    <content type="html"><![CDATA[<h2 id="UI测试"><a href="#UI测试" class="headerlink" title="UI测试"></a>UI测试</h2><p>UI 测试是为了确保对于用户的UI动作，app能返回正确的UI输出。根据实际实现方案大体可以分为两种：</p><ul><li>End-To-End（E2E）UI测试，直接通过客户端和后台服务器的交互测试整个系统，普通操作UI，通过网络获取数据，验证UI数据。实现简单，但是存在测试速度缓慢，可能因为网络导致测试用例不通过的问题。</li><li>封闭UI测试，测试方法使得测试不需要外部依赖和网络请求，使用Mock Server或者其他方式替代真实的网络请求，只验证UI输出的正确性。</li></ul><h2 id="UI测试框架"><a href="#UI测试框架" class="headerlink" title="UI测试框架"></a>UI测试框架</h2><p>Android之前比较流行的UI测试框架有<a href="https://github.com/RobotiumTech/robotium" target="_blank" rel="noopener">robotium</a>、<a href="http://appium.io/?yyue=a21bo.50862.201879" target="_blank" rel="noopener">Appium</a>、<a href="">uiautomator</a>、<a href="http://calaba.sh/?yyue=a21bo.50862.201879" target="_blank" rel="noopener">Calabash</a>、<a href="https://developer.android.com/training/testing/espresso/index.html" target="_blank" rel="noopener">Espresso</a>,但是其中Espresso作为Google官方开源的UI测试框架，以其官方的身份、完整的使用文档以及简单的使用方法，快速成为UI测试框架中的主流，本文就是以Espresso框架为主要测试框架。</p><h2 id="Espresso"><a href="#Espresso" class="headerlink" title="Espresso"></a>Espresso</h2><h3 id="介绍及集成"><a href="#介绍及集成" class="headerlink" title="介绍及集成"></a>介绍及集成</h3><p>Espresso 测试框架提供了一组 API 来构建 UI 测试，用于测试应用中的用户流。利用这些 API，您可以编写简洁、运行可靠的自动化 UI 测试。Espresso 非常适合编写白盒自动化测试，其中测试代码将利用所测试应用的实现代码详情。<br>目前Espresso最新的版本已经出道3.0.1，使用AS创建的工程，默认已经集成了2.2.2版本的Espresso，但是如果要集成最新版本的Espresso库，需要在仓库配置中添加对应仓库地址：</p><pre><code>allprojects {    repositories {        jcenter()        maven {            url &quot;https://maven.google.com&quot;            //Espresso3.0.1所在仓库地址        }    }}</code></pre><p>默认集成的Espresso包espresso-core及其相关依赖包，足以完成一般性的UI测试，除此之外Espresso还有一些扩展包，用于完成一些特殊的测试场景:</p><ul><li>espresso-web 提供了对WebView测试的相关支持</li><li>espresso-contrib 提供了对DatePicker, RecyclerView 和 Drawer等控件的特有动作、无障碍以及CountingIdlingResource的支持</li><li>espresso-intents 用于校验多app测试中intent的正确性</li><li>espresso-idling-resource（已经包含在core的依赖中）用于处理异步线程同步问题</li></ul><p>如果测试过程中不需要上述的扩展功能，则只需要添加core的依赖</p><pre><code>dependencies {    androidTestCompile(&apos;com.android.support.test.espresso:espresso-core:3.0.1&apos;, {        exclude group: &apos;com.android.support&apos;, module: &apos;support-annotations&apos;        //不导入依赖中的support-annotations，避免出现依赖冲突，会使用用户自己导入的包    })}</code></pre><p>其余诸如runner，rules包都被core依赖，会自动导入，没有必要手动导入，以免导入版本不正确引起其他问题，除了上面描述的相关库，Espresso还依赖了JUnit和Hamcrest等其他测试辅助框架。</p><h3 id="EspressoUI测试的重要对象"><a href="#EspressoUI测试的重要对象" class="headerlink" title="EspressoUI测试的重要对象"></a>EspressoUI测试的重要对象</h3><ul><li><strong><a href="https://developer.android.com/reference/android/support/test/espresso/Espresso.html" target="_blank" rel="noopener"><code>Espresso</code></a></strong> Espresso框架的入口类，提供了一些静态方法，便于开始整个测试代码，它提供了类似onView和onData这种方法获取一个可交互的对象ViewInteraction，或者直接进行一个例如页面返回的顶层操作。</li><li><strong><a href="https://developer.android.com/reference/android/support/test/espresso/matcher/ViewMatchers.html" target="_blank" rel="noopener"><code>ViewMatchers</code></a></strong> 定义了一系列静态方法用于根据不同条件返回Matcher&lt;? super View&gt;对象，作为参数传递给onView()。</li><li><strong><a href="https://developer.android.com/reference/android/support/test/espresso/action/ViewActions.html" target="_blank" rel="noopener"><code>ViewActions</code></a></strong> view的操作行为例如click()，最为ViewInteraction.perform()的参数用于对指定View的进行对应操作。</li><li><strong><a href="https://developer.android.com/reference/android/support/test/espresso/assertion/ViewAssertions.html" target="_blank" rel="noopener"><code>ViewAssertions</code></a></strong> 作为ViewInteraction.check()的参数，判断view的输出是否正确</li><li><strong><a href="https://developer.android.com/reference/android/support/test/rule/ActivityTestRule.html" target="_blank" rel="noopener"><code>ActivityTestRule</code></a></strong> 提供了测试单个Activity的功能，当它的launchActivity设置为true时，它会在每个使用<code>@Test</code>注释的方法前和所有注释者<code>@Before</code>的方法前启动。同时可以通过ActivityTestRule对象获取对应Activity的对象。</li></ul><p>一个简单的代码示例如下：</p><pre><code>@RunWith(AndroidJUnit4.class)public class LoginTest {    @Rule    public ActivityTestRule&lt;LoginActivity&gt; mActivityRule =            new ActivityTestRule(LoginActivity.class);    @Test    public void login() throws Exception {        onView(withId(R.id.et_login_number)).perform(click(),replaceText(&quot;17720380994&quot;),closeSoftKeyboard());        onView(withId(R.id.btn_login_next)).perform(click());        onView(withId(R.id.et_password)).perform(click(),replaceText(&quot;aa123456&quot;),closeSoftKeyboard());        onView(withId(R.id.btn_login)).perform(click());        onView(withId(R.id.toolbar)).check(matches(isDisplayed()));        onView(allOf(instanceOf(ImageButton.class),withParent(withId(R.id.toolbar)),isDisplayed())).perform(click());        onView(withId(R.id.tv_phone_number)).check(matches(withText(&quot;17720380994&quot;)));        onView(IsInstanceOf.&lt;View&gt;instanceOf(ScrollView.class)).perform(swipeUp());        onView(withId(R.id.tv_exit)).perform(click());        onView(withText(R.string.exit_login_confirm)).check(matches(isDisplayed()));        onView(withId(R.id.tv_ok)).perform(click());        onView(withId(R.id.et_login_number)).check(matches(isDisplayed()));    }}</code></pre><p>总体来说UI测试的过程就是：<strong>找到某个元素，做一些操作，检查结果</strong>。</p><h3 id="寻找View"><a href="#寻找View" class="headerlink" title="寻找View"></a>寻找View</h3><p>Espresso中定位View主要有两种，通过页面显示的View特征（onView）和通过数据内容（onData），其中onView用于普通场景，onData用于adapterView这种可能没有渲染的view，但是两者都是基于hamcrest的matcher来进行，本质是相同的不同的是匹配规则</p><h4 id="ViewMathcer"><a href="#ViewMathcer" class="headerlink" title="ViewMathcer"></a>ViewMathcer</h4><p><code>ViewMathcer</code>实质上提供了很多Matcher对象，主要用于配合OnView匹配控件，这些Matcher同时可以配合hamcrest中的matcher一起使用，效果更好。常用的Matcher如下</p><ul><li><code>withId()</code> <code>onView(withId(R.id.tv_ok))</code><br>直接通过id定位指定的的View，简单粗暴，但是非常实用。</li><li><code>isAssignableFrom()</code> <code>onView(isAssignableFrom(ScrollView.class))</code>通过对象类型判断</li><li><code>isDisplayed()</code>  <code>onView(allOf(isDisplayed(),isAssignableFrom(ScrollView.class)))</code> 通过是否显示判断，通常和其他matcher配合(<code>allOf</code>是hamcrest库重的方法，用于匹配多个matcher，类似的还有<code>anyOf</code>)</li><li><code>isEnabled()</code></li><li><code>isFocusable()</code><br>……</li></ul><p><code>ViewMathcer</code>中几乎把所有的View属性都定义了对应的matcher，需要的可以自行查阅源码或文档。</p><h4 id="DataInteraction"><a href="#DataInteraction" class="headerlink" title="DataInteraction"></a>DataInteraction</h4><p><code>DataInteraction</code> 是onData方法的返回值，因为onData方法匹配出的不直接就是View，它匹配的是一个数据集合，只有我们想要进行具体的View操作时，Espresso才会把它转化为View。<br>​<br>     onData(instanceOf(Account.class))<br>Espresso没有为<code>onData</code>定义Matcher，基本都是使用hamcrest中定义的matcher或者自定义matcher</p><h5 id="自定义Matcher"><a href="#自定义Matcher" class="headerlink" title="自定义Matcher"></a>自定义Matcher</h5><p>一般自定义Matcher都继承<code>TypeSafeMatcher</code>，需要实现的方法如下</p><pre><code>public class CallInfoMatcher extends TypeSafeMatcher&lt;CallInfo&gt; {    @Override    public void describeTo(Description description) {        //匹配失败时的描述，用于描述具体的匹配失败信息    }    @Override    protected boolean matchesSafely(CallInfo item) {        //具体的匹配过程        return false;    }}</code></pre><h3 id="对View的操作"><a href="#对View的操作" class="headerlink" title="对View的操作"></a>对View的操作</h3><p>View的操作都是在<code>ViewInteraction</code>上进行的。<code>ViewInteraction</code>也就是<code>onView</code>的返回值对象，用于对于具体的View进行操作（<code>DataInteraction</code>的操作也是转换为ViewInteraction后进行的），<code>ViewInteraction</code>提供了如下方法来对相应的元素做操作：</p><pre><code>public ViewInteraction perform(final ViewAction... viewActions) {}</code></pre><p>具体的操作通过<code>ViewAction</code>定义，连续操作可以链式调用或者作为参数顺序排列。</p><h4 id="ViewAction"><a href="#ViewAction" class="headerlink" title="ViewAction"></a>ViewAction</h4><p><code>ViewAction</code>是espresso中定义的针对View操作的接口类型。<code>ViewAction</code>中实现主要在ViewActions类中通过静态方法提供。常见的action如下</p><ul><li><code>click()</code></li><li><code>closeSoftKeyboard()</code></li><li><code>replaceText()</code><br>……</li></ul><p>除去ViewActions提供的较为通用的操作方法，Espresso还提供了很多ViewAction的子类用于完成不同View的特定操作。     </p><blockquote><p>ViewAction是在View匹配成功的基础上进行的匹配失败或者匹配不唯一都会导致测试不通过，同时Action与View类型不匹配也会失败</p></blockquote><h3 id="校验结果"><a href="#校验结果" class="headerlink" title="校验结果"></a>校验结果</h3><p>测试最重要的一步就是校验结果的正确性，<code>ViewInteraction</code>提供了<code>check()</code>方法用于校验正确性</p><pre><code>public ViewInteraction check(final ViewAssertion viewAssert) {    ......}</code></pre><p>和<code>perform()</code>方法类似，<code>check()</code>也是可以链式调用多次校验。</p><h4 id="ViewAssertion"><a href="#ViewAssertion" class="headerlink" title="ViewAssertion"></a>ViewAssertion</h4><p><code>ViewAssertion</code>是espresso中定义的用于校验View状态的接口类型，同样<code>ViewAssertion</code>也主要由<code>ViewAssertions</code>中的静态方法提供。其中主要使用的就是<code>matches()</code>方法</p><pre><code>public static ViewAssertion matches(final Matcher&lt;? super View&gt; viewMatcher) {    return new MatchesViewAssertion(checkNotNull(viewMatcher));}</code></pre><p>其中参数viewMatcher就是前面用于匹配View的<code>ViewMatcher</code>。</p><h3 id="异步问题"><a href="#异步问题" class="headerlink" title="异步问题"></a>异步问题</h3><p>Espresso提供了大量的同步机制，这些机制主要针对于主线层的MQ，但是Espresso对于其他的异步操作是无感知的，如果View的显示依赖于网络数据，很有可能就会导致测试用例不通过，因此需要使用前面使用的<code>espresso-idling-resource</code>来保证Espresso在异步线程的可靠性。</p><p><code>espresso-idling-resource</code>依赖添加如下</p><pre><code>compile(&quot;com.android.support.test.espresso:espresso-idling-resource:3.0.1&quot;) {    exclude module: &apos;support-annotations&apos;}androidTestCompile(&quot;com.android.support.test.espresso:espresso-idling-resource:3.0.1&quot;) {    exclude module: &apos;support-annotations&apos;}//由于Espresso对与异步线程无感知，我们需要在代码中主动使用IdlingResource，因此需要使用compile依赖。</code></pre><h3 id="IdlingResource"><a href="#IdlingResource" class="headerlink" title="IdlingResource"></a>IdlingResource</h3><p>Espresso主要通过<code>IdlingResource</code>这个接口类型完成对异步资源的感知，主要方法如下</p><pre><code>public interface IdlingResource {    //用于标识对于的异步资源    public String getName();    //返回目前资源是否可用(闲置)，    public boolean isIdleNow();    //Espresso会注册此回掉，需要判断资源可用时主动调用    public void registerIdleTransitionCallback(ResourceCallback callback);    public interface ResourceCallback {        public void onTransitionToIdle();    }}</code></pre><p>Espresso提供了几个<code>IdlingResource</code>的实现类，可以直接使用：</p><ul><li><a href="https://developer.android.com/reference/android/support/test/espresso/idling/CountingIdlingResource.html" target="_blank" rel="noopener">CountingIdlingResource</a> 为资源提供了一个简单的使用计数，当count为0时资源为闲置状态。</li><li><a href="https://developer.android.com/reference/android/support/test/espresso/idling/net/UriIdlingResource.html" target="_blank" rel="noopener">UriIdlingResource</a> 类似<code>CountingIdlingResource</code>,但是count为0时资源不会立即为闲置状态。</li><li><a href="https://developer.android.com/reference/android/support/test/espresso/idling/concurrent/IdlingThreadPoolExecutor.html" target="_blank" rel="noopener">IdlingThreadPoolExecutor</a>  一个有<code>IdlingResource</code>功能的<code>ThreadPoolExecutor</code>。</li><li><a href="https://developer.android.com/reference/android/support/test/espresso/idling/concurrent/IdlingScheduledThreadPoolExecutor.html" target="_blank" rel="noopener">IdlingScheduledThreadPoolExecutor</a> em.. 同上</li></ul><p>我们借<code>CountingIdlingResource</code>来了解下<code>IdlingResource</code>的主要用法，<code>CountingIdlingResource</code>主要提供的两个共有方法供我们使用</p><ul><li><code>increment()</code>计数加一</li><li><code>decrement()</code>计数减一，为0时调用<code>onTransitionToIdle()</code></li></ul><p>例如使用网络请求的场景，发起请求时<code>increment()</code>表示资源被占用，请求结束时<code>decrement()</code>，表示资源被释放。同时还需要在测试代码中注册对应资源</p><pre><code>IdlingRegistry.getInstance().register(idlingResource);</code></pre><p><code>IdlingResource</code>解决了异步代码的问题，但是依旧存在问题，我们在业务逻辑代码中创建<code>IdlingResource</code>对象，同时在需要的地方去改变它的状态，然后在测试代码中使用。这无疑是为了测试而给正常的业务代码增加了不必要的逻辑。</p><p>未完待续～</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;UI测试&quot;&gt;&lt;a href=&quot;#UI测试&quot; class=&quot;headerlink&quot; title=&quot;UI测试&quot;&gt;&lt;/a&gt;UI测试&lt;/h2&gt;&lt;p&gt;UI 测试是为了确保对于用户的UI动作，app能返回正确的UI输出。根据实际实现方案大体可以分为两种：&lt;/p&gt;
&lt;ul&gt;
&lt;
      
    
    </summary>
    
    
      <category term="Android" scheme="http://haojen.github.io/tags/Android/"/>
    
      <category term="Test" scheme="http://haojen.github.io/tags/Test/"/>
    
  </entry>
  
</feed>
