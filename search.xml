<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Handler解析]]></title>
    <url>%2F2018%2F08%2F16%2FHandler%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[Handler介绍Handler 是 Android 下异步线程通讯的主要机制，关于 Handler 的简单介绍如下图所示 在 Handler 机制中，主要的参与对象以及关系在上图中已经很清晰了，我这里在简单介绍一下： Handler 异步消息的发送者，也是消息的处理者，但是值得注意的是发送的处理可以在不同线程 MessageQueue 线程安全的消息队列，线程的变换主要是在 MessageQueue 中完成 Messager 异步通信内容的载体 Looper 通过循环不断的从 MessageQueue 中获取消息，然后分发给 Handler 处理，和MessageQueue 是一一对应的关系 简单的介绍到此为止，下面开始详细介绍整个消息发送过程。 Handler消息机制Handler创建针对 Handler 消息机制，我这边直接从 Handler 构造函数开始解析 public Handler(Callback callback, boolean async) &#123; //内存泄漏警告 ...... //获取Looper mLooper = Looper.myLooper(); if (mLooper == null) &#123; throw new RuntimeException( "Can't create handler inside thread that has not called Looper.prepare()"); &#125; mQueue = mLooper.mQueue; mCallback = callback; mAsynchronous = async;&#125;//Looper是通过ThreadLocal获取的线程私有的变量，但是默认为nullpublic static @Nullable Looper myLooper() &#123; return sThreadLocal.get();&#125;//创建Looper对象并设置给ThreadLocalprivate static void prepare(boolean quitAllowed) &#123; if (sThreadLocal.get() != null) &#123; throw new RuntimeException("Only one Looper may be created per thread"); &#125; sThreadLocal.set(new Looper(quitAllowed));&#125;//创建MessageQueue对象private Looper(boolean quitAllowed) &#123; mQueue = new MessageQueue(quitAllowed); mThread = Thread.currentThread();&#125; 上面这一段代码看似很多，其实就是告诉我们如果想要创建 Handler 就得先有一个 Looper , Looper 是跟线程绑定的，创建 Looper 的同时它也会把 MessageQueue 也一起创建好，我们平时在主线程中的用的时候不要 Looper ,是因为主线程以及帮我们干了。 public final class ActivityThread &#123; public static void main(String[] args) &#123; ..... Looper.prepareMainLooper(); ...... Looper.loop(); throw new RuntimeException("Main thread loop unexpectedly exited"); &#125;&#125; 到现在可以确定线程、Looper 、Handler 、MessageQueue 的关系如下 graph TB subgraph 线程 MessageQueue --&gt; Looper Looper --&gt; Handler1 Looper --&gt; Handler2 end 消息发送使用 Handler 发送消息可以有多种形式，Handler.sendMessage() 、Message.sendToTarget() 以及类似的一些方法都可以发送消息，但是不管是哪种方法最终都会调用Handler.enqueueMessage() 方法。 private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123; msg.target = this; if (mAsynchronous) &#123; //发送异步消息 msg.setAsynchronous(true); &#125; return queue.enqueueMessage(msg, uptimeMillis);&#125; 这个方法也没有做太多逻辑处理，直接调用了 MessageQueue 的 enqueueMessage 方法 boolean enqueueMessage(Message msg, long when) &#123; ...... synchronized (this) &#123; ...... msg.markInUse(); msg.when = when; Message p = mMessages; boolean needWake; if (p == null || when == 0 || when &lt; p.when) &#123; // New head, wake up the event queue if blocked. msg.next = p; mMessages = msg; needWake = mBlocked; &#125; else &#123; // Inserted within the middle of the queue. Usually we don't have to wake // up the event queue unless there is a barrier at the head of the queue // and the message is the earliest asynchronous message in the queue. needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; for (;;) &#123; prev = p; p = p.next; if (p == null || when &lt; p.when) &#123; break; &#125; if (needWake &amp;&amp; p.isAsynchronous()) &#123; needWake = false; &#125; &#125; msg.next = p; // invariant: p == prev.next prev.next = msg; &#125; // We can assume mPtr != 0 because mQuitting is false. if (needWake) &#123; nativeWake(mPtr); &#125; &#125; return true;&#125; 这一段事实上就是一个单链表插入，mMessages 为链表头，如果链表为空则直接把 msg 赋给表头，否则通过循环找到链表最后进行插入。MessageQueue 的消息在 Looper.loop() 来获取并处理的。 public static void loop() &#123; final Looper me = myLooper(); if (me == null) &#123; throw new RuntimeException("No Looper; Looper.prepare() wasn't called on this thread."); &#125; final MessageQueue queue = me.mQueue; // Make sure the identity of this thread is that of the local process, // and keep track of what that identity token actually is. Binder.clearCallingIdentity(); final long ident = Binder.clearCallingIdentity(); for (;;) &#123; Message msg = queue.next(); // might block if (msg == null) &#123; // No message indicates that the message queue is quitting. return; &#125; // This must be in a local variable, in case a UI event sets the logger final Printer logging = me.mLogging; if (logging != null) &#123; logging.println("&gt;&gt;&gt;&gt;&gt; Dispatching to " + msg.target + " " + msg.callback + ": " + msg.what); &#125; final long slowDispatchThresholdMs = me.mSlowDispatchThresholdMs; final long traceTag = me.mTraceTag; if (traceTag != 0 &amp;&amp; Trace.isTagEnabled(traceTag)) &#123; Trace.traceBegin(traceTag, msg.target.getTraceName(msg)); &#125; final long start = (slowDispatchThresholdMs == 0) ? 0 :SystemClock.uptimeMillis(); final long end; try &#123; msg.target.dispatchMessage(msg); end = (slowDispatchThresholdMs == 0) ? 0 : SystemClock.uptimeMillis(); &#125; finally &#123; if (traceTag != 0) &#123; Trace.traceEnd(traceTag); &#125; &#125; if (slowDispatchThresholdMs &gt; 0) &#123; final long time = end - start; if (time &gt; slowDispatchThresholdMs) &#123; Slog.w(TAG, "Dispatch took " + time + "ms on " + Thread.currentThread().getName() + ", h=" + msg.target + " cb=" + msg.callback + " msg=" + msg.what); &#125; &#125; if (logging != null) &#123; logging.println("&lt;&lt;&lt;&lt;&lt; Finished to " + msg.target + " " + msg.callback); &#125; // Make sure that during the course of dispatching the // identity of the thread wasn't corrupted. final long newIdent = Binder.clearCallingIdentity(); if (ident != newIdent) &#123; Log.wtf(TAG, "Thread identity changed from 0x" + Long.toHexString(ident) + " to 0x" + Long.toHexString(newIdent) + " while dispatching to " + msg.target.getClass().getName() + " " + msg.callback + " what=" + msg.what); &#125; msg.recycleUnchecked(); &#125;&#125; loop() 方法主要就是在一个无限循环中不断的通过 next 获取消息，然后使用 dispatchMessage 把消息交回给Handler处理。现在我们回头来看 next 方法是如何获取消息的。 Message next() &#123; ...... int pendingIdleHandlerCount = -1; // -1 only during first iteration int nextPollTimeoutMillis = 0; for (;;) &#123; if (nextPollTimeoutMillis != 0) &#123; Binder.flushPendingCommands(); &#125; nativePollOnce(ptr, nextPollTimeoutMillis); synchronized (this) &#123; // Try to retrieve the next message. Return if found. final long now = SystemClock.uptimeMillis(); Message prevMsg = null; Message msg = mMessages; if (msg != null &amp;&amp; msg.target == null) &#123; // Stalled by a barrier. Find the next asynchronous message in the queue. do &#123; prevMsg = msg; msg = msg.next; &#125; while (msg != null &amp;&amp; !msg.isAsynchronous()); &#125; if (msg != null) &#123; if (now &lt; msg.when) &#123; // Next message is not ready. Set a timeout to wake up when it is ready. nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE); &#125; else &#123; // Got a message. mBlocked = false; if (prevMsg != null) &#123; prevMsg.next = msg.next; &#125; else &#123; mMessages = msg.next; &#125; msg.next = null; if (DEBUG) Log.v(TAG, "Returning message: " + msg); msg.markInUse(); return msg; &#125; &#125; else &#123; // No more messages. nextPollTimeoutMillis = -1; &#125; &#125;&#125; next 方法的主要逻辑都在一个无限循环内，知道获取到消息才会返回，同时把消息从链表中移除。同时默认获取的是链表头，只有当 msg.target == null 时才会获取链表后第一个同步消息，但是要知道我们通过 Handler 发送的消息 target 都是 Handler 本身，事实上这是消息屏障机制 同步屏障事实上消息分为同步和异步两种，通过 isAsynchronous 来判断，我们平时使用的一般是异步消息 ,同步消息主要用于页面绘制等对时间敏感的地方，但是在通常情况下即使我们使用 setAsynchronous(true) 来手动设置一个同步消息它也不会生效，MessageQueue 还是会把他当作普通消息处理，只有配合 postSyncBarrier 添加一个同步屏障之后才能使用。 public int postSyncBarrier() &#123; return postSyncBarrier(SystemClock.uptimeMillis());&#125;private int postSyncBarrier(long when) &#123; // Enqueue a new sync barrier token. // We don't need to wake the queue because the purpose of a barrier is to stall it. synchronized (this) &#123; final int token = mNextBarrierToken++; final Message msg = Message.obtain(); msg.markInUse(); msg.when = when; msg.arg1 = token; Message prev = null; Message p = mMessages; if (when != 0) &#123; while (p != null &amp;&amp; p.when &lt;= when) &#123; prev = p; p = p.next; &#125; &#125; if (prev != null) &#123; // invariant: p == prev.next msg.next = p; prev.next = msg; &#125; else &#123; msg.next = p; mMessages = msg; &#125; return token; &#125;&#125; postSyncBarrier 是一个隐藏 Api，我们无法调用，但这不妨碍我们分析它，它直接向 MessageQueue 的单链表中头插入了一个 target==null 的消息，也就是上一节 next 方法中的逻辑，当这种情况下，MessageQueue 会忽略所有的异步消息，只获取同步消息，需要调用 removeSyncBarrier(int token) 才能取消这个同步屏障，目前同步屏障主要是在 ViewRootImpl 绘制时使用。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Handler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RecyclerView源码详解]]></title>
    <url>%2F2018%2F07%2F30%2FRecyclerView%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[[TOC] 免责声明： 这篇文章还没有写完，发布的原因是因为我懒的放到草稿箱了，如有错误或者以后请勿怪 RecyclerView介绍RecyclerView 是Google support-v7包中的控件，用于提供一个列表的显示，和 ListView 类似，但是比 ListView 更高级也更具扩展性，它更倾向于使用一个模块化的方式来使用多个模块共同实现一个复杂的列表控件，RecyclerView主要由如下几个组件构成 LayoutManager 用于控制List子View的测量和布局 Adapter 和 ListView 中的Adapter功能类似，但是已经预先添加了 ViewHolder ,不需要我们手动添加 ItemDecoration 用于控制和显示分割线 ItemAnimator 用于实现Item显示消失时动画效果 当然除了上面所说的这些模块之外，RecyclerView 还把很多其他的功能也都拆分了出来，这里就不一一列举，文中遇到了在做说明。 LayoutManagerLayoutManager 相当于把本身View应该完成的测量和布局过程抽离出来单独处理，而这两个步骤也是决定一个View显示效果的重要步骤，因此同一个 RecyclerView 完全可以通过不同的 LayoutManager 实现不同的显示效果，而不是使用不同的控件。 目前Google已经预先提供好了几种 LayoutManager ,分别如下所示 LinearLayoutManager 实现类似 ListView 列表样式的布局 GridLayoutManager 实现类似 GridView 网格样式的布局 StaggeredGridLayoutManager 实现了瀑布流样式的布局 我们以 LinearLayoutManager 为例来说明 LayoutManager 在 RecyclerView 中的重要作用，首先先说明一下 LinearLayoutManager 中的两个辅助类，这两个类在 LinearLayoutManager 的工作中也起着一定作用 AnchorInfo 布局的锚点，在测量和布局过程中 LinearLayoutManager 都是先确定一个锚点位置，然后根据锚点，分别向上和向下去测量和布局子 View LayoutState 是 LinearLayoutManager 在填充整体布局的帮助类，他可以通过一个给定的方向获取下一个需要填充的 View onMeasure我们都知道控件的展示主要分为测量、布局、绘制等三个阶段进行，我们首先关注 RecyclerView 的测量过程。代码片段会省略部分代码和注释 @Overrideprotected void onMeasure(int widthSpec, int heightSpec) &#123; if (mLayout == null) &#123; defaultOnMeasure(widthSpec, heightSpec); return; &#125; //isAutoMeasureEnabled方法返回false，表示必须要重写LayoutManager的onMeasure方法，完成测量 //如果设置为true，则表示由RecyclerView的AutoMeasure机制完成测量 //LinearLayoutManager已经重写了这个方法，永久返回true if (mLayout.isAutoMeasureEnabled()) &#123; final int widthMode = MeasureSpec.getMode(widthSpec); final int heightMode = MeasureSpec.getMode(heightSpec); //这里看似调用了LayoutManager的onMeasure，但是LinearLayoutManager没有重写这个方法， //因此这个最终是调用了RecyclerView自己默认的方法 mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec); //RecyclerView固定宽高或者Match_Parent的情况下measureSpecModeIsExactly为true final boolean measureSpecModeIsExactly = widthMode == MeasureSpec.EXACTLY &amp;&amp; heightMode == MeasureSpec.EXACTLY; //即如果RecyclerView的宽高不是Wrap_Content，到这里测量过程就结束了 if (measureSpecModeIsExactly || mAdapter == null) &#123; return; &#125; //mState是RecyclerView的State对象，这个对象存储了当前RecyclerView的各种状态 //在RecyclerView中各个组件的交互也是通过State对象来进行的 //mState初始mLayoutStep为STEP_START if (mState.mLayoutStep == State.STEP_START) &#123; //dispatchLayoutStep1主要对RecyclerView的动画做了处理，没有绘制流程 //后续在动画中在做说明 dispatchLayoutStep1(); &#125; // 这里widthSpec和heightSpec是RecyclerView默认测量的结果 mLayout.setMeasureSpecs(widthSpec, heightSpec); mState.mIsMeasuring = true; //实际的测量，会测量childView dispatchLayoutStep2(); // now we can get the width and height from the children. mLayout.setMeasuredDimensionFromChildren(widthSpec, heightSpec); // if RecyclerView has non-exact width and height and if there is at least one child // which also has non-exact width &amp; height, we have to re-measure. if (mLayout.shouldMeasureTwice()) &#123; mLayout.setMeasureSpecs( MeasureSpec.makeMeasureSpec(getMeasuredWidth(), MeasureSpec.EXACTLY), MeasureSpec.makeMeasureSpec(getMeasuredHeight(), MeasureSpec.EXACTLY)); mState.mIsMeasuring = true; dispatchLayoutStep2(); // now we can get the width and height from the children. mLayout.setMeasuredDimensionFromChildren(widthSpec, heightSpec); &#125; &#125; else &#123; ...... &#125;&#125; 可以看到在 onMeasure 方法中，如果我们给 RecyclerView 设置了不是 Wrap_Content 的宽高，那么 RecyclerView 的测量过程很简单，直接使用父控件给定的宽高即可，只有当我们设置为 Wrap_Content 时，才需要先去测量子 View 。 测量子 View 的过程事实上是在 dispatchLayoutStep2 方法中进行的，这个方法事实上是 Layout 时调用的方法，这个不难理解，因为只有在确定了 Layout 的方式时，才能真正确定子 View 需要多少的屏幕空间 private void dispatchLayoutStep2() &#123; startInterceptRequestLayout(); onEnterLayoutOrScroll(); mState.assertLayoutStep(State.STEP_LAYOUT | State.STEP_ANIMATIONS); mAdapterHelper.consumeUpdatesInOnePass(); mState.mItemCount = mAdapter.getItemCount(); mState.mDeletedInvisibleItemCountSincePreviousLayout = 0; // Step 2: Run layout mState.mInPreLayout = false; //上述代码基本上就是在往mState中填充RecyclerView的信息，上段代码的注释中也提到State的 //主要功能就是在RecyclerView各组件间传递信息 mLayout.onLayoutChildren(mRecycler, mState); ......&#125; dispatchLayoutStep2 主要的功能就是为 mState 的更新了一些 RecyclerView 的最新状态，然后调用了 LayoutManager 的 onLayoutChildren 方法，值得注意的是这个方法和上个方法一样是用于布局的，所以后面还会调用，这里暂时只说明测量的部分。 public void onLayoutChildren(RecyclerView.Recycler recycler, RecyclerView.State state) &#123; //计算锚点信息以及获取边缘的extraSpace，锚点初始化时一般是方向上的第一个View（反转的列表则为最后） //细节代码有兴趣可以自行研究 ...... if (mAnchorInfo.mLayoutFromEnd) &#123; // fill towards start //通过锚点更新LayoutState信息,更新后LayoutState.next会向上寻找View updateLayoutStateToFillStart(mAnchorInfo); mLayoutState.mExtra = extraForStart; fill(recycler, mLayoutState, state, false); startOffset = mLayoutState.mOffset; final int firstElement = mLayoutState.mCurrentPosition; if (mLayoutState.mAvailable &gt; 0) &#123; extraForEnd += mLayoutState.mAvailable; &#125; // fill towards end //通过锚点更新LayoutState信息,更新后LayoutState.next会向下寻找View updateLayoutStateToFillEnd(mAnchorInfo); mLayoutState.mExtra = extraForEnd; mLayoutState.mCurrentPosition += mLayoutState.mItemDirection; fill(recycler, mLayoutState, state, false); endOffset = mLayoutState.mOffset; if (mLayoutState.mAvailable &gt; 0) &#123; // end could not consume all. add more items towards start extraForStart = mLayoutState.mAvailable; updateLayoutStateToFillStart(firstElement, startOffset); mLayoutState.mExtra = extraForStart; fill(recycler, mLayoutState, state, false); startOffset = mLayoutState.mOffset; &#125; &#125; else &#123; //这段代码几乎和上段一样，只是填充的方向不同 ...... &#125; ......&#125; 上面的代码中可以看出在 onLayoutChildren 过程中，LinearLayoutManager 是首先确定一个锚点，然后从锚点位置开始向不同方向填充布局。真正的填充部分代码在 fill 方法中 int fill(RecyclerView.Recycler recycler, LayoutState layoutState, RecyclerView.State state, boolean stopOnFocusable) &#123; // bug修复代码 ...... //mAvailable是上面的方法中由锚点更新给layoutState的，为指定指定方向上需要填充的距离 //mExtra也是前面计算的边缘的extraSpace， int remainingSpace = layoutState.mAvailable + layoutState.mExtra; LayoutChunkResult layoutChunkResult = mLayoutChunkResult; //由于最开始onMeasure的时候先调用了RecyclerView默认的onMeasure方法，所以这里remainingSpace //就是能Recycler能取到的最大值 while ((layoutState.mInfinite || remainingSpace &gt; 0) &amp;&amp; layoutState.hasMore(state)) &#123; ...... //核心代码，用于计算子View需要的空间 layoutChunk(recycler, state, layoutState, layoutChunkResult); ...... //根据layoutChunkResult缩减remainingSpace大小 &#125; ...... return start - layoutState.mAvailable;&#125; 可以看到在 fill 方法中起着比较核心作用的是 layoutChunk 方法 void layoutChunk(RecyclerView.Recycler recycler, RecyclerView.State state, LayoutState layoutState, LayoutChunkResult result) &#123; View view = layoutState.next(recycler); ...... //测量ChildView measureChildWithMargins(view, 0, 0); result.mConsumed = mOrientationHelper.getDecoratedMeasurement(view); int left, top, right, bottom; ...... //布局ChildView layoutDecoratedWithMargins(view, left, top, right, bottom); ......&#125; 上面的代码其实很清楚了，layoutChunk 方法首先获取的 ChildView ，对它进行测量，然后布局。恩，你没有看错就是布局 Layout ，通过布局方法确定 ChildView 的具体位置，dispatchLayoutStep2方法的深入展开到此结束，让我们回到 onMeasure 的地方在看一下我们没有看完的代码 @Overrideprotected void onMeasure(int widthSpec, int heightSpec) &#123; ...... if (mLayout.isAutoMeasureEnabled()) &#123; ...... //上次的代码到这了 dispatchLayoutStep2(); // 通过ChildView的位置综合父控件给的widthSpec和heightSpec选择合适的宽高 mLayout.setMeasuredDimensionFromChildren(widthSpec, heightSpec); //重新进行测量，对于LinearLayoutManager来说中如果本身是WARP_CONTENT， //同时至少有一个ChildView有不确定（WRAP_CONTENT或者MATCH_PARENT）的宽和高 if (mLayout.shouldMeasureTwice()) &#123; //重新走一遍上面的测量 ...... &#125; &#125; else &#123; ...... &#125;&#125;void setMeasuredDimensionFromChildren(int widthSpec, int heightSpec) &#123; ...... //遍历ChildView，选出坐上右下四个值 for (int i = 0; i &lt; count; i++) &#123; View child = getChildAt(i); final Rect bounds = mRecyclerView.mTempRect; getDecoratedBoundsWithMargins(child, bounds); if (bounds.left &lt; minX) &#123; minX = bounds.left; &#125; if (bounds.right &gt; maxX) &#123; maxX = bounds.right; &#125; if (bounds.top &lt; minY) &#123; minY = bounds.top; &#125; if (bounds.bottom &gt; maxY) &#123; maxY = bounds.bottom; &#125; &#125; mRecyclerView.mTempRect.set(minX, minY, maxX, maxY); //根据获得的Rect范围综合父控件给的值综合获取最终的宽高 setMeasuredDimension(mRecyclerView.mTempRect, widthSpec, heightSpec);&#125; 好了到此为止，整个测量过程基本上清楚了，下面我们根据一张时序图回顾一下整个流程 participant RecyclerView as Aparticipant LinearLayoutManager as BA-&gt;A:onMeasureA-&gt;B:isAutoMeasureEnabledA-&gt;A:dispatchLayoutStep2A-&gt;B:onLayoutChildrenB-&gt;B:fillB-&gt;B:layoutChunkB-&gt;B:measureChildWithMarginsB-&gt;B:layoutDecoratedWithMarginsA-&gt;B:setMeasuredDimensionFromChildrenA-&gt;B:shouldMeasureTwiceB-&gt;B:calculate measurezise......B-&gt;A:setMeasuredDimension 可以看出 RecyclerView 在整个测量过程还是整个流程的主导，LayoutManager 更多像是一个提供具体配置参数的。这个表可以作为我们自定义 LayoutManager 时的一个参考。 onLayout继续看布局的相关方法，首先从 RecyclerView 的 onLayout 方法开始 protected void onLayout(boolean changed, int l, int t, int r, int b) &#123; TraceCompat.beginSection(TRACE_ON_LAYOUT_TAG); //直接调用了dispatchLayout dispatchLayout(); TraceCompat.endSection(); mFirstLayoutComplete = true;&#125;void dispatchLayout() &#123; if (mAdapter == null) &#123; return; &#125; if (mLayout == null) &#123; return; &#125; mState.mIsMeasuring = false; //mLayoutStep初始为STEP_START，然后会在dispatchLayoutStep1方法修改为STEP_LAYOUT //然后在dispatchLayoutStep2方法中修改为STEP_ANIMATIONS //除非若RecyclerView宽高为Wrap_Content，否则此处为STEP_START if (mState.mLayoutStep == State.STEP_START) &#123; //完成一次完整的测量布局 dispatchLayoutStep1(); mLayout.setExactMeasureSpecsFrom(this); dispatchLayoutStep2(); &#125; else if (mAdapterHelper.hasUpdates() || mLayout.getWidth() != getWidth() || mLayout.getHeight() != getHeight()) &#123; //测量布局已经但是，种种原因，大小改变了，需要重新测量布局 //这个方法把RecyclerView的测量宽高以一EXACTLY的形式给了LayoutManager mLayout.setExactMeasureSpecsFrom(this); dispatchLayoutStep2(); &#125; else &#123; // always make sure we sync them (to ensure mode is exact) mLayout.setExactMeasureSpecsFrom(this); &#125; dispatchLayoutStep3();&#125; 在 onLayout 中 RecyclerView 并没有做什么多余的操作，而是直接调用了 dispatchLayout 方法，这个方法会根据我们在 onMeasure 中的行为判断是否需要调用 dispatchLayoutStep1 和 dispatchLayoutStep2 ，但是无论哪种情况都会通过 setExactMeasureSpecsFrom 给 LayoutManager 设置一个确切的宽高，最后调用 dispatchLayoutStep3 方法。 private void dispatchLayoutStep3() &#123; //STEP_ANIMATIONS状态就可以看出来，这个方法主要是完成前面dispatchLayoutStep1中 //设置好的动画 mState.assertLayoutStep(State.STEP_ANIMATIONS); startInterceptRequestLayout(); onEnterLayoutOrScroll(); mState.mLayoutStep = State.STEP_START; if (mState.mRunSimpleAnimations) &#123; //这个整段代码全都是动画相关的 ...... &#125; // 一些状态的置位和资源的释放 ...... if (mLayout.mPrefetchMaxObservedInInitialPrefetch) &#123; // Initial prefetch has expanded cache, so reset until next prefetch. // This prevents initial prefetches from expanding the cache permanently. mLayout.mPrefetchMaxCountObserved = 0; mLayout.mPrefetchMaxObservedInInitialPrefetch = false; mRecycler.updateViewCacheSize(); &#125; //这里也是一样，部分状态的初始化 mLayout.onLayoutCompleted(mState); onExitLayoutOrScroll(); stopInterceptRequestLayout(false); mViewInfoStore.clear(); if (didChildRangeChange(mMinMaxLayoutPositions[0], mMinMaxLayoutPositions[1])) &#123; dispatchOnScrolled(0, 0); &#125; recoverFocusFromState(); resetFocusInfo();&#125; ￼ 这就结束了？，没错到此为止 LinearLayoutManager 或者说 RecyclerView 的 auto measure 就是这样的，当然 LayoutManager 还有一些其他功能这里还没有涉及到或者没有展开，后面遇到再进行说明。 Recycler按照顺序这里应该是本应该是 Adapter ，但是我发现如果没有 Recycler 存在 Adapter 根本玩不下去，看名字 Recycler 就感觉像是 RecyclerView 的核心，确实它也掌管了所有 ChildView 的生成、复用、回收，确实也是核心，首先我们介绍一下 Recycler 中的几个缓存队列 mChangedScrap item被标记为更新、有动画且动画支持变化 mAttachedScrap mCachedViews Recycler 也还是得从测量过程中的 LayoutChunk 说起，虽然这个 Recycler 对象在一开始 onLayoutChildren 就作为参数传递到了 LayoutManager ，但是一直没有正经的使用它。 void layoutChunk(RecyclerView.Recycler recycler, RecyclerView.State state, LayoutState layoutState, LayoutChunkResult result) &#123; //从LayoutState中获取下一个View View view = layoutState.next(recycler); if (view == null) &#123; //说明已经没有更多的View，到底或者到顶了 result.mFinished = true; return; &#125; LayoutParams params = (LayoutParams) view.getLayoutParams(); //mScrapList一般情况下都为null，只有在为动画做准备时才会有内存 if (layoutState.mScrapList == null) &#123; if (mShouldReverseLayout == (layoutState.mLayoutDirection == LayoutState.LAYOUT_START)) &#123; addView(view); &#125; else &#123; addView(view, 0); &#125; &#125; else &#123; //暂时可以不考虑 ...... &#125; measureChildWithMargins(view, 0, 0); ......&#125;View next(RecyclerView.Recycler recycler) &#123; //mScrapList一般情况下都为null，这里暂不考虑 if (mScrapList != null) &#123; return nextViewFromScrapList(); &#125; //调用了getViewForPosition来获取真正View final View view = recycler.getViewForPosition(mCurrentPosition); mCurrentPosition += mItemDirection; return view;&#125;public View getViewForPosition(int position) &#123; return getViewForPosition(position, false);&#125;View getViewForPosition(int position, boolean dryRun) &#123; return tryGetViewHolderForPositionByDeadline(position, dryRun, FOREVER_NS).itemView;&#125; layoutChunk 根本意义上说也还没有使用 Recycler 对象，但是这里算上获取 childView 的一个起点，所以我们从这里开始分析，后续的几个方法也都没有做太多工作。到了 tryGetViewHolderForPositionByDeadline 真正的逻辑开始了。代码之前我们先整理一下逻辑，这个方法的的主要工作如下 如果进行了 PreLayout 则会优先从 mChangedScrap 中查找 ViewHolder , PreLayout 这个行为发生在 dispatchLayoutStep1 中，虽然是 PreLayout 但是终究还是会去 onLayoutChildren ，然后最后还是会调用 tryGetViewHolderForPositionByDeadline ，所以本质上来说第一次来步骤1肯定会跳过 ViewHolder tryGetViewHolderForPositionByDeadline(int position, boolean dryRun, long deadlineNs) &#123; if (position &lt; 0 || position &gt;= mState.getItemCount()) &#123; throw new IndexOutOfBoundsException(...); &#125; boolean fromScrapOrHiddenOrCache = false; ViewHolder holder = null; // 0) If there is a changed scrap, try to find from there if (mState.isPreLayout()) &#123; holder = getChangedScrapViewForPosition(position); fromScrapOrHiddenOrCache = holder != null; &#125; // 1) Find by position from scrap/hidden list/cache if (holder == null) &#123; holder = getScrapOrHiddenOrCachedHolderForPosition(position, dryRun); if (holder != null) &#123; if (!validateViewHolderForOffsetPosition(holder)) &#123; // recycle holder (and unscrap if relevant) since it can't be used if (!dryRun) &#123; // we would like to recycle this but need to make sure it is not used by // animation logic etc. holder.addFlags(ViewHolder.FLAG_INVALID); if (holder.isScrap()) &#123; removeDetachedView(holder.itemView, false); holder.unScrap(); &#125; else if (holder.wasReturnedFromScrap()) &#123; holder.clearReturnedFromScrapFlag(); &#125; recycleViewHolderInternal(holder); &#125; holder = null; &#125; else &#123; fromScrapOrHiddenOrCache = true; &#125; &#125; &#125; if (holder == null) &#123; final int offsetPosition = mAdapterHelper.findPositionOffset(position); if (offsetPosition &lt; 0 || offsetPosition &gt;= mAdapter.getItemCount()) &#123; throw new IndexOutOfBoundsException(...); &#125; final int type = mAdapter.getItemViewType(offsetPosition); // 2) Find from scrap/cache via stable ids, if exists if (mAdapter.hasStableIds()) &#123; holder = getScrapOrCachedViewForId(mAdapter.getItemId(offsetPosition), type, dryRun); if (holder != null) &#123; // update position holder.mPosition = offsetPosition; fromScrapOrHiddenOrCache = true; &#125; &#125; if (holder == null &amp;&amp; mViewCacheExtension != null) &#123; // We are NOT sending the offsetPosition because LayoutManager does not // know it. final View view = mViewCacheExtension .getViewForPositionAndType(this, position, type); if (view != null) &#123; holder = getChildViewHolder(view); if (holder == null) &#123; throw new IllegalArgumentException(...); &#125; else if (holder.shouldIgnore()) &#123; throw new IllegalArgumentException(...); &#125; &#125; &#125; if (holder == null) &#123; // fallback to pool holder = getRecycledViewPool().getRecycledView(type); if (holder != null) &#123; holder.resetInternal(); if (FORCE_INVALIDATE_DISPLAY_LIST) &#123; invalidateDisplayListInt(holder); &#125; &#125; &#125; if (holder == null) &#123; long start = getNanoTime(); if (deadlineNs != FOREVER_NS &amp;&amp; !mRecyclerPool.willCreateInTime(type, start, deadlineNs)) &#123; // abort - we have a deadline we can't meet return null; &#125; holder = mAdapter.createViewHolder(RecyclerView.this, type); if (ALLOW_THREAD_GAP_WORK) &#123; // only bother finding nested RV if prefetching RecyclerView innerView = findNestedRecyclerView(holder.itemView); if (innerView != null) &#123; holder.mNestedRecyclerView = new WeakReference&lt;&gt;(innerView); &#125; &#125; long end = getNanoTime(); mRecyclerPool.factorInCreateTime(type, end - start); &#125; &#125; // This is very ugly but the only place we can grab this information // before the View is rebound and returned to the LayoutManager for post layout ops. // We don't need this in pre-layout since the VH is not updated by the LM. if (fromScrapOrHiddenOrCache &amp;&amp; !mState.isPreLayout() &amp;&amp; holder .hasAnyOfTheFlags(ViewHolder.FLAG_BOUNCED_FROM_HIDDEN_LIST)) &#123; holder.setFlags(0, ViewHolder.FLAG_BOUNCED_FROM_HIDDEN_LIST); if (mState.mRunSimpleAnimations) &#123; int changeFlags = ItemAnimator .buildAdapterChangeFlagsForAnimations(holder); changeFlags |= ItemAnimator.FLAG_APPEARED_IN_PRE_LAYOUT; final ItemHolderInfo info = mItemAnimator.recordPreLayoutInformation(mState, holder, changeFlags, holder.getUnmodifiedPayloads()); recordAnimationInfoIfBouncedHiddenView(holder, info); &#125; &#125; boolean bound = false; if (mState.isPreLayout() &amp;&amp; holder.isBound()) &#123; // do not update unless we absolutely have to. holder.mPreLayoutPosition = position; &#125; else if (!holder.isBound() || holder.needsUpdate() || holder.isInvalid()) &#123; if (DEBUG &amp;&amp; holder.isRemoved()) &#123; throw new IllegalStateException(...); &#125; final int offsetPosition = mAdapterHelper.findPositionOffset(position); bound = tryBindViewHolderByDeadline(holder, offsetPosition, position, deadlineNs); &#125; final ViewGroup.LayoutParams lp = holder.itemView.getLayoutParams(); final LayoutParams rvLayoutParams; if (lp == null) &#123; rvLayoutParams = (LayoutParams) generateDefaultLayoutParams(); holder.itemView.setLayoutParams(rvLayoutParams); &#125; else if (!checkLayoutParams(lp)) &#123; rvLayoutParams = (LayoutParams) generateLayoutParams(lp); holder.itemView.setLayoutParams(rvLayoutParams); &#125; else &#123; rvLayoutParams = (LayoutParams) lp; &#125; rvLayoutParams.mViewHolder = holder; rvLayoutParams.mPendingInvalidate = fromScrapOrHiddenOrCache &amp;&amp; bound; return holder;&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ThreadLocal详解]]></title>
    <url>%2F2018%2F07%2F19%2FThreadLocal%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[ThreadLocal是什么ThreadLocal是java中处理并发问题的一种方式，但是和Synchronized、volatile等进程同步关键字不同，ThreadLocal主要用于进程隔离，即每一个线程都有一个自己的ThreadLocal，访问时访问的都是线程持有的对象，无法访问其他线程的ThreadLocal,也就不存在并发的问题。 ThreadLocal使用ThreadLocal使用起来类似一个数据封装类，使用set和get方法设置和获取存储的内容 //创建ThreadLocal对象，使用泛型制定类型ThreadLocal&lt;Integer&gt; localInt = new ThreadLocal&lt;&gt;();//写入内容localInt.set(10);//获取内容assert locaInt.get()==10; ThreadLocal特殊的地方就在于不同线程间是无法获取到其它线程的相应对象的，在多线程场景中对ThreadLocal的使用实例如下 ThreadLocal&lt;Integer&gt; localInt = new ThreadLocal&lt;&gt;();Thread threadA = new Thread() &#123; @Override public void run() &#123; for(int i=100;i&lt;200;i++)&#123; try &#123; localInt.set(i); sleep(10); assert localInt.get()==i; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; super.run(); &#125;&#125;;Thread threadB = new Thread() &#123; @Override public void run() &#123; for(int i=0;i&lt;100;i++)&#123; try &#123; localInt.set(i); sleep(10); assert localInt.get()==i; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; super.run(); &#125;&#125;;threadA.start();threadB.start(); ThreadA和ThreadB中ThreadLocal是不会相互影响的，他们每次从ThreadLocal中获取的都是线程内部的相应数据。 在上面的例子中我们只是用ThreadLocal存储了一个变量，如果想要同时拥有多个线程私有的变量就只能创建多个TreadLocal对象。 ThreadLocal实现原理ThreadLocal看上去很神奇，原理其实并不难，它只是把我们的变量关联到了线程的Thread对象上，我们借助ThreadLocal的set方法来说明这点。 public void set(T value) &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value);&#125;ThreadLocalMap getMap(Thread t) &#123; return t.threadLocals;&#125; 在我们通过set方法设置ThreadLocal的内容是，它首先获取当前的Thread对象，同时获取Thread上的ThreadLocalMap，ThreadLocalMap事实上是hash表的一种实现，set事实上是把ThreadLocal对象和相应的value分别作为key和value保证在了这个map中，也就是说我们的value保存在Thread对象内。 get方法也是类似的，我们使用get方法获取值的时候，首先是获取currentThread，然后通过Thread的ThreadLocalMap用ThreadLocal作为key获取对应的value。 public T get() &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) &#123; @SuppressWarnings("unchecked") T result = (T)e.value; return result; &#125; &#125; return setInitialValue();&#125; 如果没有创建过ThreadLocalMap，setInitialValue会创建ThreadLocalMap同时返回null。 ThreadLocal内存泄漏正常来说ThreadLocal的对象和其保存的value持有在一个普通的对象内，而在保存时他们会作为key和value保存在Thread对象的map内，线程一般拥有比普通对象更长的生命周期，特别是对于线程池中的线程。 这种情况下作为key的ThreadLocal和value就有泄漏的风险，ThreadLocal的设计上自然也考虑到了这点，因此ThreadLocalMap中Key都是作为弱引用存在的 static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123; /** The value associated with this ThreadLocal. */ Object value; Entry(ThreadLocal&lt;?&gt; k, Object v) &#123; super(k); value = v; &#125;&#125; 这样当持有ThreadLocal的对象销毁后，没有强引用的ThreadLocal也会很快被回收，但是与之对应的value却没法被自动回收。 事实上ThreadLocalMap对于这样的情况也是有所处理，即ThreadLocalMap在每次set或者get时发现有key为空的元素，都会把它清理掉 private void set(ThreadLocal&lt;?&gt; key, Object value) &#123; ...... for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) &#123; ThreadLocal&lt;?&gt; k = e.get(); if (k == key) &#123; e.value = value; return; &#125; //清理掉key==null的元素 if (k == null) &#123; replaceStaleEntry(key, value, i); return; &#125; &#125; ......&#125; 但是即使这样光靠ThreadLocalMap也没有办法完全避免value的内存泄漏，最好的就是每次使用完ThreadLocal后都调用它的remove方法，清除数据。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android线程池]]></title>
    <url>%2F2018%2F07%2F16%2FAndroid%E7%BA%BF%E7%A8%8B%E6%B1%A0%2F</url>
    <content type="text"><![CDATA[为什么使用线程池线程是操作系统能进行运算调度的最小单元，在Java 中直接使用线程，给我们带来了很多便利，但是线程的使用同时也存在一些问题 线程生命周期的开销非常高，即在线程的创建和销毁过程都会消耗较大的cpu资源 资源消耗，线程的存在期间会消耗系统资源，尤其是内存（短时间内高并发任务尤其需要注意） 线程池线程池就是一种线程复用的手段，它通过缓存已有线程，来减小线程创建过程的消耗，它通过控制线程数量来控制线程存在的系统消耗，同时他把任务和任务的执行进行了解耦，把任务本身和任务的执行过程分离。这一点从Executor就可以看出 public interface Executor { void execute(Runnable command); } 任务封装成Runnable，通过execute在内部通过缓存的线程对任务进行处理，对于Runnable这个任务而言，具体的执行策略它毫不知晓，同时我们可以有极大的空间来制定执行策略。 构造线程池线程池给我们创造了极大扩展空间用于管理线程资源和定义任务的执行策略，同时为了更加方便我们使用，Java定义了一些配置成型的线程池供我们使用，这些线程池可以通过Executors这样一个工厂类获取 newFixedThreadPool。newFixedThreadPool会创建一个固定长度的线程池，每当提交一个任务时，就会创建一个线程（即使有空闲的线程），直到达到线程最大值。 newCachedThreadPool。newCachedThreadPool会创建一个可缓存的线程池，任务提交时没有空闲的线程就会创建新的线程，且这个过程没有上线，当线程执行完成后60s内没有被其他任务复用就会被销毁。 newSingleThreadExecutor。newSingleThreadExecutor是一个单线程的Executor，一般按照FIFO的顺序执行（不同于我们自己创建的单线程Thread，如果Thread不慎挂掉，会创建一个新的线程保证运行过程） newSingleThreadExecutor。创建一个固定长度线程池，会使用延迟或者定时的方式来执行任务。 上面列举了几个Java中提供好的线程策略，类似的在Executors中还有很多，这里不一一列举，本质上来说，这些方法是对现有的几个线程池实现类的一种配置方式，具体线程池的复用以及调度的方式是怎么样的呢？ 线程池调度策略调度内容线程池是对线程的一个管理，它到底管理什么东西 使用什么线程执行任务 任务执行顺序 有多少任务可以同时处理 能够有多少任务等待，如果需要执行的任务超过这个上限如何处理 任务运行时出现异常怎么处理 任务前后有哪些动作 ThreadPoolExecutor我们使用的绝大部分线程池最终的实现类都是ThreadPoolExecutor，我们可以通过这个对象来真正了解线程池，首先是ThreadPoolExecutor的构造方法 public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) 从构造方法可以看出很多内容，ThreadPoolExecutor中的线程分为普通线程和核心线程，有线程存活时间，任务等待队列，线程工厂，任务拒绝的handler。 核心线程数和最大线程数关于核心线程和最大线程可以看一下execute方法的一段代码 //线程数小于核心线程直接添加新线程执行 int c = ctl.get(); if (workerCountOf(c) &lt; corePoolSize) { if (addWorker(command, true)) return; c = ctl.get(); } //将任务放入等待队列，同时检测线程池运行状态并处理 if (isRunning(c) &amp;&amp; workQueue.offer(command)) { int recheck = ctl.get(); //线程池状态改变（不是运行状态）直接打回任务 if (! isRunning(recheck) &amp;&amp; remove(command)) reject(command); else if (workerCountOf(recheck) == 0) addWorker(null, false); //等待队列满了，试图添加新线程，如果失败打回任务 //（当线程数以达到最大线程数则会失败） }else if (!addWorker(command, false)) reject(command); ctl是一个AtomicInteger类型，它用前3位标示线程池运行状态，后面位数表示已有的线程数量，当线程池新增一个任务时，会有四种情况 当前线程数小于核心线程数，直接新建线程执行任务 大于核心线程数，等待队列未满，直接进入队列 等待队列已满，且小于最大线程数，直接新建线程执行任务 都不满足，打回任务 可以看出即使等待队列时FIFO，任务也不一定会完成按照我们添加的顺序执行，当等待队列满的时候，一部分任务会优先执行。 线程复用与回收线程池最大的特点就是线程的复用，同时还有上一节中的非核心线程的回收，本质上来说核心线程和非核心线程没有去吧，他们都存储在一个集合中 private final HashSet&lt;Worker&gt; workers = new HashSet&lt;&gt;(); 线程池中的线程都使用Worker进行封装，线程复用的过程也是借助Workder来进行的，Worker的主要代码如下 private final class Worker extends AbstractQueuedSynchronizer implements Runnable{ ...... final Thread thread; Runnable firstTask; ...... Worker(Runnable firstTask) { setState(-1); // inhibit interrupts until runWorker this.firstTask = firstTask; this.thread = getThreadFactory().newThread(this); } /** Delegates main run loop to outer runWorker. */ public void run() { runWorker(this); } ...... } 我们可以看到Worker本身就是Runnable，他在创建内部线程的同时只是把自己作为参数传递进去，最终thread.start运行时执行的就是Worker的run方法，同时这里会调用ThreadPoolExecutor的runWorker方法以完成最终的线程调度。 final void runWorker(Worker w) { Thread wt = Thread.currentThread(); Runnable task = w.firstTask; ...... try { //getTask从等待队列中获取下一个task while (task != null || (task = getTask()) != null) { ...... try { beforeExecute(wt, task); Throwable thrown = null; try { task.run(); } catch (RuntimeException x) { thrown = x; throw x; } catch (Error x) { thrown = x; throw x; } catch (Throwable x) { thrown = x; throw new Error(x); } finally { afterExecute(task, thrown); } } finally { task = null; w.completedTasks++; w.unlock(); } } completedAbruptly = false; } finally { processWorkerExit(w, completedAbruptly); } } 可以看到在runWorker方法里，Worker内的task为空，会从等待队列中获取一个新的task并执行，同时会调用beforeExecute和afterExecute这两个生命周期方法，同时当任务队列没有清空或者没有异常发生时，这是一个死循环，如果跳出循环，则说明要么任务队列被清空，要么线程异常结束，processWorkerExit会处理这些情况，如果是异常结束会起一个新的线程，否则则会移除大于核心线程数的线程，到此线程的复用过程基本清楚了 我们可以看到ThreadPoolExecutor还有一个keepAliveTime的参数用于空闲时回收非核心线程的时机，这个过程事实上是在getTask获取下一个任务时进行的 ​private Runnable getTask() { boolean timedOut = false; // Did the last poll() time out? for (;;) { int c = ctl.get(); ...... int wc = workerCountOf(c); // Are workers subject to culling? boolean timed = allowCoreThreadTimeOut || wc &gt; corePoolSize; ...... try { Runnable r = timed ? workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) : workQueue.take(); if (r != null) return r; timedOut = true; } catch (InterruptedException retry) { timedOut = false; } } } 可以看到当目前的线程数大于核心线程数时，获取任务时会执行workQueue.poll方法，这个方法在队列空时会等待给定的时间然后才会返回，如果在规定的时间仍然没有新的任务，则会在上面的processWorkerExit回收线程。 除此之外线程池还有等待队列、线程工厂、任务拒绝的handler等要点，由于时间有限，这里暂时不一一说明，以后有时间再做补充，大家也可自行探索。 需要注意的问题线程池十分好用，但是使用中也有些需要注意的点，这里我稍稍列举一些，希望大家使用中可以注意 不要使用线程池执行可能会相互依赖的任务，因为线程池不一定能保证执行顺序，很有可能会发生线程死锁 任务需要考虑可能出现的同步问题，因为任务不是在单线程环境下运行 对时间敏感的任务，不要使用线程池，因为线程池可以保证执行但是无法保证执行的时间 运行时间较长的任务尽量不要和时间较短的任务一起执行，这会严重影响短耗时任务的执行效率]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android权限管理]]></title>
    <url>%2F2018%2F07%2F11%2FAndroid%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[Android动态权限Android6.0（API23）开始，系统权限出现了很大的变化，此前在权限的检查和获取只发生在app安装时，同时获取后可以一直享有权限。在6.0以后，一些敏感的权限需要动态的获取，同时每次用户可以随时关闭权限，因此需要在每次使用前进行权限检查和获取。 权限等级6.0以后也不是所有权限的获取都需要动态的申请，权限被分成了几个等级，权限的等级主要有四种，分别是Normal、Signature、Dangerous和SignatureOrSystem。 Normal等级：任何应用都可以申请，直接在manifest声明，安装时提示用户，之后会自动获取此类权限。 Dangerous等级：任何应用都可以申请，需要在manifest中声明，同时在使用时需要动态的获取权限。 Signature等级：只有与声明权限的apk使用相同的签名私钥才能申请权限。 SignatureOrSystem:只有与声明权限的apk使用相同的签名私钥或者在/system/app目录下的应用才能申请权限。 这四种权限都是在manifest中声明权限时指定的，在普通的应用开发中我们一般需要关注的只有Normal和Dangerous两种，其中需要动态申请权限的只有Dangerous权限。 Dangerous权限Android下所有的Dangerous权限都被分成权限组，在动态申请权限时，申请的时提示给用户的信息都以组为单位的，比如如果app申请READ_CONTACTS权限,那么系统仅仅提示用户申请联系人权限，如果用户允许，在8.0以下的版本中同组的WRITE_CONTACTS也会一并被获取到，而在8.0及以上WRITE_CONTACTS权限还需要我们去动态的申请，但是系统会立即授予该权限而不会提示用户。 Dangerous权限分组 权限组 权限 CALENDAR READ_CALENDARWRITE_CALENDAR CAMERA CAMERA CONTACTS READ_CONTACTSWRITE_CONTACTSGET_ACCOUNTS LOCATION ACCESS_FINE_LOCATIONACCESS_COARSE_LOCATION MICROPHONE RECORD_AUDIO PHONE READ_PHONE_STATEREAD_PHONE_NUMBERSCALL_PHONEANSWER_PHONE_CALLSREAD_CALL_LOGWRITE_CALL_LOGADD_VOICEMAILUSE_SIPPROCESS_OUTGOING_CALLS SENSORS BODY_SENSORS SMS SEND_SMSRECEIVE_SMSREAD_SMSRECEIVE_WAP_PUSHRECEIVE_MMS STORAGE READ_EXTERNAL_STORAGEWRITE_EXTERNAL_STORAGE 动态权限申请申明权限对于Dangerous的权限，我们首先也需要在manifest中申请，这里以联系人权限为例 &lt;uses-permission android:name=&quot;android.permission.READ_CONTACTS&quot;/&gt; &lt;uses-permission android:name=&quot;android.permission.WRITE_CONTACTS&quot;/&gt; 权限检查在使用试图操作联系人前需要首先确认有没有这个权限 if(ContextCompat.checkSelfPermission(this, Manifest.permission.READ_CONTACTS) != PackageManager.PERMISSION_GRANTED){ //申请权限 }else{ //读取联系人 } ContextCompat.checkSelfPermission(Context context, String permission)方法用于检查App是否拥有参数指定的权限，方法的返回值为int，可能的取值如下 PERMISSION_GRANTED 已经获取权限 PERMISSION_DENIED 还没有获取权限 权限申请如果尚未获取权限则在使用之前需要先申请权限 ActivityCompat.requestPermissions(this, new String[]{Manifest.permission.READ_CONTACTS},CODE_REQUEST_CONTACTS); 一般情况下，ActivityCompat.requestPermissions方法会使用一个标准的对话框提示用户，但是有些机型则会跳转到一个新的页面做这件事（会导致Activity声明周期变化，甚至重启）。 申请之后则需要等待用户选择，如果如果你的Activity不是继承自AppCompatActivity，则需要实现OnRequestPermissionsResultCallback用于接收权限请求的结果回掉。 public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) { super.onRequestPermissionsResult(requestCode, permissions, grantResults); if(requestCode==CODE_REQUEST_CONTACTS){ if(grantResults[0]==PackageManager.PERMISSION_GRANTED){ //读取联系人 }else{ //权限获取失败 } } } 合理的权限申请用户首次拒绝授予权限之后，当第二次进行权限请求时，会出现“不再提示”的选项，如果用户勾选，则后续对此权限的申请将不再提示用户，直接失败。因此我们需要在合适的时机解释获取权限的原因，我们可以使用ActivityCompat.shouldShowRequestPermissionRationale方法来确定是否需要告知用户，这个方法默认情况下返回false，当用户拒绝过授予此权限后，这个返回值为true（用户勾选不再提示后返回值为false）。 if (ContextCompat.checkSelfPermission(this, Manifest.permission.READ_CONTACTS) != PackageManager.PERMISSION_GRANTED) { if (ActivityCompat.shouldShowRequestPermissionRationale(this, Manifest.permission.READ_CONTACTS)) { //提示用户后申请权限 } else { //申请权限 ActivityCompat.requestPermissions(this, new String[]{Manifest.permission.READ_CONTACTS}, CODE_REQUEST_CONTACTS); } } else { //读取联系人 } 权限被拒绝权限被拒绝后，再次申请会继续弹出，但是当用户勾选“不再提示”后，下次权限申请系统将不再提示用户，而是直接拒绝，这种情况下，我们只能引导用户到设置里自己打开权限，我们可以在onRequestPermissionsResult中通过ActivityCompat.shouldShowRequestPermissionRationale来判断用户是否选择了不再提示。 public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) { if (requestCode == CODE_REQUEST_CONTACTS) { if (grantResults[0] == PackageManager.PERMISSION_GRANTED) { //读取联系人 } else { if(!ActivityCompat.shouldShowRequestPermissionRationale(this, Manifest.permission.READ_CONTACTS)){ //引导用户到设置页面开启权限 } } } } //跳转到设置页面相关代码 Intent intent = new Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS); Uri uri = Uri.fromParts(&quot;package&quot;,getApplicationContext().getPackageName(), null); intent.setData(uri); startActivity(intent); 参考文章 Android 权限的一些细节 Android中的权限管理 Android 6.0 运行时权限处理完全解析 Android6.0动态权限申请步骤以及需要注意的一些坑]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>permission</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AndrodUI测试入门]]></title>
    <url>%2F2018%2F03%2F05%2FAndrodUI%E6%B5%8B%E8%AF%95%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[UI测试UI 测试是为了确保对于用户的UI动作，app能返回正确的UI输出。根据实际实现方案大体可以分为两种： End-To-End（E2E）UI测试，直接通过客户端和后台服务器的交互测试整个系统，普通操作UI，通过网络获取数据，验证UI数据。实现简单，但是存在测试速度缓慢，可能因为网络导致测试用例不通过的问题。 封闭UI测试，测试方法使得测试不需要外部依赖和网络请求，使用Mock Server或者其他方式替代真实的网络请求，只验证UI输出的正确性。 UI测试框架Android之前比较流行的UI测试框架有robotium、Appium、uiautomator、Calabash、Espresso,但是其中Espresso作为Google官方开源的UI测试框架，以其官方的身份、完整的使用文档以及简单的使用方法，快速成为UI测试框架中的主流，本文就是以Espresso框架为主要测试框架。 Espresso介绍及集成Espresso 测试框架提供了一组 API 来构建 UI 测试，用于测试应用中的用户流。利用这些 API，您可以编写简洁、运行可靠的自动化 UI 测试。Espresso 非常适合编写白盒自动化测试，其中测试代码将利用所测试应用的实现代码详情。目前Espresso最新的版本已经出道3.0.1，使用AS创建的工程，默认已经集成了2.2.2版本的Espresso，但是如果要集成最新版本的Espresso库，需要在仓库配置中添加对应仓库地址： allprojects { repositories { jcenter() maven { url &quot;https://maven.google.com&quot; //Espresso3.0.1所在仓库地址 } } } 默认集成的Espresso包espresso-core及其相关依赖包，足以完成一般性的UI测试，除此之外Espresso还有一些扩展包，用于完成一些特殊的测试场景: espresso-web 提供了对WebView测试的相关支持 espresso-contrib 提供了对DatePicker, RecyclerView 和 Drawer等控件的特有动作、无障碍以及CountingIdlingResource的支持 espresso-intents 用于校验多app测试中intent的正确性 espresso-idling-resource（已经包含在core的依赖中）用于处理异步线程同步问题 如果测试过程中不需要上述的扩展功能，则只需要添加core的依赖 dependencies { androidTestCompile(&apos;com.android.support.test.espresso:espresso-core:3.0.1&apos;, { exclude group: &apos;com.android.support&apos;, module: &apos;support-annotations&apos; //不导入依赖中的support-annotations，避免出现依赖冲突，会使用用户自己导入的包 }) } 其余诸如runner，rules包都被core依赖，会自动导入，没有必要手动导入，以免导入版本不正确引起其他问题，除了上面描述的相关库，Espresso还依赖了JUnit和Hamcrest等其他测试辅助框架。 EspressoUI测试的重要对象 Espresso Espresso框架的入口类，提供了一些静态方法，便于开始整个测试代码，它提供了类似onView和onData这种方法获取一个可交互的对象ViewInteraction，或者直接进行一个例如页面返回的顶层操作。 ViewMatchers 定义了一系列静态方法用于根据不同条件返回Matcher&lt;? super View&gt;对象，作为参数传递给onView()。 ViewActions view的操作行为例如click()，最为ViewInteraction.perform()的参数用于对指定View的进行对应操作。 ViewAssertions 作为ViewInteraction.check()的参数，判断view的输出是否正确 ActivityTestRule 提供了测试单个Activity的功能，当它的launchActivity设置为true时，它会在每个使用@Test注释的方法前和所有注释者@Before的方法前启动。同时可以通过ActivityTestRule对象获取对应Activity的对象。 一个简单的代码示例如下： @RunWith(AndroidJUnit4.class) public class LoginTest { @Rule public ActivityTestRule&lt;LoginActivity&gt; mActivityRule = new ActivityTestRule(LoginActivity.class); @Test public void login() throws Exception { onView(withId(R.id.et_login_number)).perform(click(),replaceText(&quot;17720380994&quot;),closeSoftKeyboard()); onView(withId(R.id.btn_login_next)).perform(click()); onView(withId(R.id.et_password)).perform(click(),replaceText(&quot;aa123456&quot;),closeSoftKeyboard()); onView(withId(R.id.btn_login)).perform(click()); onView(withId(R.id.toolbar)).check(matches(isDisplayed())); onView(allOf(instanceOf(ImageButton.class),withParent(withId(R.id.toolbar)),isDisplayed())).perform(click()); onView(withId(R.id.tv_phone_number)).check(matches(withText(&quot;17720380994&quot;))); onView(IsInstanceOf.&lt;View&gt;instanceOf(ScrollView.class)).perform(swipeUp()); onView(withId(R.id.tv_exit)).perform(click()); onView(withText(R.string.exit_login_confirm)).check(matches(isDisplayed())); onView(withId(R.id.tv_ok)).perform(click()); onView(withId(R.id.et_login_number)).check(matches(isDisplayed())); } } 总体来说UI测试的过程就是：找到某个元素，做一些操作，检查结果。 寻找ViewEspresso中定位View主要有两种，通过页面显示的View特征（onView）和通过数据内容（onData），其中onView用于普通场景，onData用于adapterView这种可能没有渲染的view，但是两者都是基于hamcrest的matcher来进行，本质是相同的不同的是匹配规则 ViewMathcerViewMathcer实质上提供了很多Matcher对象，主要用于配合OnView匹配控件，这些Matcher同时可以配合hamcrest中的matcher一起使用，效果更好。常用的Matcher如下 withId() onView(withId(R.id.tv_ok))直接通过id定位指定的的View，简单粗暴，但是非常实用。 isAssignableFrom() onView(isAssignableFrom(ScrollView.class))通过对象类型判断 isDisplayed() onView(allOf(isDisplayed(),isAssignableFrom(ScrollView.class))) 通过是否显示判断，通常和其他matcher配合(allOf是hamcrest库重的方法，用于匹配多个matcher，类似的还有anyOf) isEnabled() isFocusable()…… ViewMathcer中几乎把所有的View属性都定义了对应的matcher，需要的可以自行查阅源码或文档。 DataInteractionDataInteraction 是onData方法的返回值，因为onData方法匹配出的不直接就是View，它匹配的是一个数据集合，只有我们想要进行具体的View操作时，Espresso才会把它转化为View。​ onData(instanceOf(Account.class))Espresso没有为onData定义Matcher，基本都是使用hamcrest中定义的matcher或者自定义matcher 自定义Matcher一般自定义Matcher都继承TypeSafeMatcher，需要实现的方法如下 public class CallInfoMatcher extends TypeSafeMatcher&lt;CallInfo&gt; { @Override public void describeTo(Description description) { //匹配失败时的描述，用于描述具体的匹配失败信息 } @Override protected boolean matchesSafely(CallInfo item) { //具体的匹配过程 return false; } } 对View的操作View的操作都是在ViewInteraction上进行的。ViewInteraction也就是onView的返回值对象，用于对于具体的View进行操作（DataInteraction的操作也是转换为ViewInteraction后进行的），ViewInteraction提供了如下方法来对相应的元素做操作： public ViewInteraction perform(final ViewAction... viewActions) {} 具体的操作通过ViewAction定义，连续操作可以链式调用或者作为参数顺序排列。 ViewActionViewAction是espresso中定义的针对View操作的接口类型。ViewAction中实现主要在ViewActions类中通过静态方法提供。常见的action如下 click() closeSoftKeyboard() replaceText()…… 除去ViewActions提供的较为通用的操作方法，Espresso还提供了很多ViewAction的子类用于完成不同View的特定操作。 ViewAction是在View匹配成功的基础上进行的匹配失败或者匹配不唯一都会导致测试不通过，同时Action与View类型不匹配也会失败 校验结果测试最重要的一步就是校验结果的正确性，ViewInteraction提供了check()方法用于校验正确性 public ViewInteraction check(final ViewAssertion viewAssert) { ...... } 和perform()方法类似，check()也是可以链式调用多次校验。 ViewAssertionViewAssertion是espresso中定义的用于校验View状态的接口类型，同样ViewAssertion也主要由ViewAssertions中的静态方法提供。其中主要使用的就是matches()方法 public static ViewAssertion matches(final Matcher&lt;? super View&gt; viewMatcher) { return new MatchesViewAssertion(checkNotNull(viewMatcher)); } 其中参数viewMatcher就是前面用于匹配View的ViewMatcher。 异步问题Espresso提供了大量的同步机制，这些机制主要针对于主线层的MQ，但是Espresso对于其他的异步操作是无感知的，如果View的显示依赖于网络数据，很有可能就会导致测试用例不通过，因此需要使用前面使用的espresso-idling-resource来保证Espresso在异步线程的可靠性。 espresso-idling-resource依赖添加如下 compile(&quot;com.android.support.test.espresso:espresso-idling-resource:3.0.1&quot;) { exclude module: &apos;support-annotations&apos; } androidTestCompile(&quot;com.android.support.test.espresso:espresso-idling-resource:3.0.1&quot;) { exclude module: &apos;support-annotations&apos; } //由于Espresso对与异步线程无感知，我们需要在代码中主动使用IdlingResource，因此需要使用compile依赖。 IdlingResourceEspresso主要通过IdlingResource这个接口类型完成对异步资源的感知，主要方法如下 public interface IdlingResource { //用于标识对于的异步资源 public String getName(); //返回目前资源是否可用(闲置)， public boolean isIdleNow(); //Espresso会注册此回掉，需要判断资源可用时主动调用 public void registerIdleTransitionCallback(ResourceCallback callback); public interface ResourceCallback { public void onTransitionToIdle(); } } Espresso提供了几个IdlingResource的实现类，可以直接使用： CountingIdlingResource 为资源提供了一个简单的使用计数，当count为0时资源为闲置状态。 UriIdlingResource 类似CountingIdlingResource,但是count为0时资源不会立即为闲置状态。 IdlingThreadPoolExecutor 一个有IdlingResource功能的ThreadPoolExecutor。 IdlingScheduledThreadPoolExecutor em.. 同上 我们借CountingIdlingResource来了解下IdlingResource的主要用法，CountingIdlingResource主要提供的两个共有方法供我们使用 increment()计数加一 decrement()计数减一，为0时调用onTransitionToIdle() 例如使用网络请求的场景，发起请求时increment()表示资源被占用，请求结束时decrement()，表示资源被释放。同时还需要在测试代码中注册对应资源 IdlingRegistry.getInstance().register(idlingResource); IdlingResource解决了异步代码的问题，但是依旧存在问题，我们在业务逻辑代码中创建IdlingResource对象，同时在需要的地方去改变它的状态，然后在测试代码中使用。这无疑是为了测试而给正常的业务代码增加了不必要的逻辑。 未完待续～]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Test</tag>
      </tags>
  </entry>
</search>
