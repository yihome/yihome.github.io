<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[记一次网络请求全过程]]></title>
    <url>%2F2019%2F10%2F27%2F%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E5%85%A8%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[一次网络请求目前我们的网络框架采用RxJava+Retrofit+OkHttp，使用起来非常简单，只需要简单几行代码便能完成整个网络请求 retrofit.create(serviceClass) .getNoticeInfo(CommonConstant.COURSE_TYPE_FACE) .subscribeOn(Schedulers.io()) .unsubscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new BJYNetObserver&lt;JsonObject&gt;() &#123; ...... &#125;); 这些高度封装的第三方库内部却不是这么简单，我们就跟随一条简单的网络一起探索一下这个全过程。 Retrofit网络请求的开始从Retrofit开始，Retrofit的核心是动态代理，通过注解和返回值来创建Restful的网络请求。所以Retrofit的核心代码不算太多，从我们通过create创建了网络请求的代理类开始 public &lt;T&gt; T create(final Class&lt;T&gt; service) &#123; Utils.validateServiceInterface(service); if (validateEagerly) &#123; eagerlyValidateMethods(service); &#125; //创建接口的代理对象 return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[] &#123; service &#125;, new InvocationHandler() &#123; private final Platform platform = Platform.get(); @Override public Object invoke(Object proxy, Method method, Object... args) throws Throwable &#123; ...... //解析接口方法，根据方法参数、返回值和注解生成需要的参数 ServiceMethod serviceMethod = loadServiceMethod(method); OkHttpCall okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args); return serviceMethod.callAdapter.adapt(okHttpCall); &#125; &#125;); &#125; 在loadServiceMethod中有大量逻辑都是处理Retrofit的注解生成相应网络请求Request的过程（这个不是本文的重点），同时还会获得两个比较重要的对象 CallAdapter 和 Converter ,这两个对象都是用于在请求过程中对于网络请求的结果进行转换，但是两者的作用不同 Converter 主要用于值转换，可以自定义将原始的ResponseBody转换成String或者其他对象，一般用于Gson解析 CallAdapter 用于将Call转换成其他对象，Call对象本身是一个接口，Retrofit的主要实现类是OkHttpCall，这个是OkHttp中RealCall的封装类 这个两个对象在实际流程中的关系如下 ResponseBody -&gt; Converter -&gt; TCall&lt;T&gt; -&gt; CallAdapter -&gt; Other ResponseBody 经过 Converter 转换后的类型回作为Call对象范型类型，然后通过 CallAdapter 转换成其他类型。 这两个对象都是通过抽象工厂模式来创建，我们可以添加抽象工厂来自定义这两个对象，Converter 和CallAdapter 中具体工厂都是根据他们的返回值类型来确定的，首先确定是 CallAdapter 的工厂，然后根据 CallAdapter.adapt 方法的入参Call的范型类型确定 Converter ##OkHttp OkHttpClient 的创建和RealCall 的创建过程就不多做介绍了，我们从RealCall的execute 和 enqueue 两个方法开始。 @Override public Response execute() throws IOException &#123; ...... try &#123; client.dispatcher().executed(this);//1 Response result = getResponseWithInterceptorChain();//2 if (result == null) throw new IOException("Canceled"); return result; &#125; finally &#123; client.dispatcher().finished(this); &#125;&#125;@Override public void enqueue(Callback responseCallback) &#123; ...... client.dispatcher().enqueue(new AsyncCall(responseCallback));//3&#125; 可以看到这两个方法一个是同步请求，一个是异步请求，但是在1和3处都使用到了 Dispatcher 这个对象，同时同步请求回在2处直接调用 getResponseWithInterceptorChain 执行请求，我们先看一下 Dispatcher 这个对象的几个重要成员。 /** Executes calls. Created lazily. */private @Nullable ExecutorService executorService;/** Ready async calls in the order they'll be run. */private final Deque&lt;AsyncCall&gt; readyAsyncCalls = new ArrayDeque&lt;&gt;();/** Running asynchronous calls. Includes canceled calls that haven't finished yet. */private final Deque&lt;AsyncCall&gt; runningAsyncCalls = new ArrayDeque&lt;&gt;();/** Running synchronous calls. Includes canceled calls that haven't finished yet. */private final Deque&lt;RealCall&gt; runningSyncCalls = new ArrayDeque&lt;&gt;(); 可以看到 Dispatcher 中有三个队列以及一个 Executor ，而这个 Executor 事实上是一个线程池,从变量命名上看 Dispatcher 的实现已经很明显了 一个异步请求的等待队列 一个异步请求的执行队列 一个同步请求的执行队列 一个异步请求的线程池 在前面的代码中我看到在执行异步请求时会把 RealCall 封装在 AsyncCall 内，我们看一下 AsyncCall 的execute方法 @Override protected void execute() &#123; boolean signalledCallback = false; try &#123; Response response = getResponseWithInterceptorChain(); if (retryAndFollowUpInterceptor.isCanceled()) &#123; signalledCallback = true; responseCallback.onFailure(RealCall.this, new IOException("Canceled")); &#125; else &#123; signalledCallback = true; responseCallback.onResponse(RealCall.this, response); &#125; &#125; catch (IOException e) &#123; ...... &#125; finally &#123; client.dispatcher().finished(this); &#125;&#125; 可以看到异步请求最终也是调用了 getResponseWithInterceptorChain 方法来执行最终的请求，OkHttp可以分为两段，而这个方法是下半段的开始，也是OkHttp请求的核心。 Response getResponseWithInterceptorChain() throws IOException &#123; // Build a full stack of interceptors. List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;(); interceptors.addAll(client.interceptors()); interceptors.add(retryAndFollowUpInterceptor); interceptors.add(new BridgeInterceptor(client.cookieJar())); interceptors.add(new CacheInterceptor(client.internalCache())); interceptors.add(new ConnectInterceptor(client)); if (!forWebSocket) &#123; interceptors.addAll(client.networkInterceptors()); &#125; interceptors.add(new CallServerInterceptor(forWebSocket)); Interceptor.Chain chain = new RealInterceptorChain( interceptors, null, null, null, 0, originalRequest); return chain.proceed(originalRequest); &#125; 在OkHttp中使用拦截器链来进行网络请求，且内置了五个拦截器，在查看这五个拦截器之前，我们先看一下拦截器链的结构 //RealInterceptorChain.javapublic Response proceed(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec, RealConnection connection) throws IOException &#123; if (index &gt;= interceptors.size()) throw new AssertionError(); calls++; ...... // Call the next interceptor in the chain. RealInterceptorChain next = new RealInterceptorChain( interceptors, streamAllocation, httpCodec, connection, index + 1, request); Interceptor interceptor = interceptors.get(index); Response response = interceptor.intercept(next); ...... return response; &#125; 可以看到 RealInterceptorChain 每执行一个拦截器都会创建一个新的 RealInterceptorChain 对象，同时通过index控制目前使用的拦截器，并调用拦截器的 intercept 方法。 RetryAndFollowUpInterceptor在这个拦截器内主要做了两件事 创建了StreamAllocation对象，这个对象在后面再详细介绍 根据网络请求的相应错误码比如301、408，进行重试 @Override public Response intercept(Chain chain) throws IOException &#123; Request request = chain.request(); ..... int followUpCount = 0; while (true) &#123; ..... try &#123; response = ((RealInterceptorChain) chain).proceed(request, streamAllocation, null, null); releaseConnection = false; &#125; catch (RouteException e) &#123; ...... &#125; finally &#123; ...... &#125; ...... //根据相应码获取下一次请求的Request Request followUp = followUpRequest(response); if (followUp == null) &#123; if (!forWebSocket) &#123; streamAllocation.release(); &#125; return response; &#125; closeQuietly(response.body()); if (++followUpCount &gt; MAX_FOLLOW_UPS) &#123; streamAllocation.release(); throw new ProtocolException("Too many follow-up requests: " + followUpCount); &#125; ...... &#125; &#125; BridgeInterceptor主要是对请求头和响应头的处理，比如添加一些Content-Length,Content-Type 等通用的请求头，同时cookie、请求体和响应体gzip压缩和解压的处理也是在这个拦截器 @Override public Response intercept(Chain chain) throws IOException &#123; //添加必要的请求头 ....... List&lt;Cookie&gt; cookies = cookieJar.loadForRequest(userRequest.url()); if (!cookies.isEmpty()) &#123; requestBuilder.header("Cookie", cookieHeader(cookies)); &#125; ....... Response networkResponse = chain.proceed(requestBuilder.build()); HttpHeaders.receiveHeaders(cookieJar, userRequest.url(), networkResponse.headers()); Response.Builder responseBuilder = networkResponse.newBuilder() .request(userRequest); if (transparentGzip &amp;&amp; "gzip".equalsIgnoreCase(networkResponse.header("Content-Encoding")) &amp;&amp; HttpHeaders.hasBody(networkResponse)) &#123; GzipSource responseBody = new GzipSource(networkResponse.body().source()); Headers strippedHeaders = networkResponse.headers().newBuilder() .removeAll("Content-Encoding") .removeAll("Content-Length") .build(); responseBuilder.headers(strippedHeaders); String contentType = networkResponse.header("Content-Type"); responseBuilder.body(new RealResponseBody(contentType, -1L, Okio.buffer(responseBody))); &#125; return responseBuilder.build(); &#125; 这个地方第一次出现了Source，这个是OkIo中定义的对象，是IO流的封装类，后面详细介绍 CacheInterceptorCacheInterceptor 的意义从名称上来看来已经很明显了，但是这个Okhttp的实现可能和我们想象中的不一 样，CacheInterceptor 主要针对的是304 HTTP_NOT_MODIFIED 响应码，一般正常的网络请求都会正常进行，但是会在后台返回304时，使用本地缓存 CacheInterceptor 主要关注什么样的请求响应需要被缓存和缓存的时常（这往往取决于Http的头部信息），具体的缓存使用 DiskLruCache 来实现，但是OkHttp对于 DiskLruCache 底层IO使用OkIO重写了，有兴趣的可以自行研究 Okhttp中前三个拦截器都是相对比较容易理解的，但是从第四个拦截器开始，负责度就开始提升了，这个原因主要有两个 从第四个拦截器开始，OkIO的相关代码开始大量出现，提高了代码复杂度 OkHttp实现了Http2.0协议，从这里开始有很多Http2.0的实现代码（这个也是OkHttp相较于早期其他比如HttpClient和HttpUrlConnection网络请求框架一个巨大的提升，不过目前HttpUrlConnection底层已经替换为OkHttp了） OkioOkio 是对于JavaIO的一次封装，主要整合了家族庞大的JavaIO，使用统一的Sink(相当于OutputStream)和Source(相当于InputStream)来处理各种不同类型的输入和输出，同时提供Buffer缓存机制。 这个为了OkHttp整体流程的连贯性，作为OkHttp的一节，但是OkIO是一个独立的框架，我们完全可以使用把它用于各种的IO场景中。 Buffer缓存机制整个Buffer缓存机制主要有三个对象组成 Segment Buffer缓存的最小单位 Buffer 由Segment组成的双向链表，使用链表结构可以大量避免 System.arraycopy SegmentPool Segment缓存池，回收复用Segment内存，避免内存分配的消耗 SegmentSegment 本质上就是一个定长的字节数组，包括一个指向数据头部的指针，一个指向数据尾部的指针，同时定义了一些在这个结构上的方法，比如split 、 compact 、writeTo BufferBuffer 同时实现了BufferedSink 和 BufferedSource ，也就是说Buffer 既可以作为输入流从中获取数据，也可以作为输出流向外输出数据，本质上它就是一个缓冲区，同时它内部使用Segment 的双向链表来存储数量，使得在 Buffer 间传递数据时可以直接通过修改Segment 的链表指针来完成，大量减少了 System.arraycopy 的消耗，我们可以通过几个代表性的方法来了解一下 Buffer 将Buffer写入到输出流public Buffer writeTo(OutputStream out, long byteCount) throws IOException &#123; if (out == null) throw new IllegalArgumentException("out == null"); checkOffsetAndCount(size, 0, byteCount); Segment s = head; while (byteCount &gt; 0) &#123; int toCopy = (int) Math.min(byteCount, s.limit - s.pos); out.write(s.data, s.pos, toCopy); s.pos += toCopy; size -= toCopy; byteCount -= toCopy; if (s.pos == s.limit) &#123; Segment toRecycle = s; head = s = toRecycle.pop(); SegmentPool.recycle(toRecycle); &#125; &#125; return this;&#125; 可以看到将 Buffer 写入到OutputStream 时，事实上就是将每一个 Segment 的内容写入到 OutputStream 中，同理将其他数据写入 Buffer 时也是类似的，就是将数据写入到 Segment 中。 在 Buffer 中提供了很多中不同的读和写的方法，同时还提供了内置的加密方式。 SegmentPool由 Segment 组成的单链表缓存区，对外提供两个静态方法take ，recycle 用于回收和获取 Segment 。 Okio的家族体系 Okio 中的主要对象只有上面几个，其中的缓存都以Buffer为核心，除了上述几个对象外还有很多其他是以内部类的形式存在的 Sink 和 Buffer ，例如在 Okio 这个入口类中提供了很多 sink 和 Buffer 的方法用于将Okio 对接到传统IO上，这个实现也是通过创建 Sink 和 Buffer 的内部类来完成的 private static Source source(final InputStream in, final Timeout timeout) &#123; if (in == null) throw new IllegalArgumentException("in == null"); if (timeout == null) throw new IllegalArgumentException("timeout == null"); return new Source() &#123; @Override public long read(Buffer sink, long byteCount) throws IOException &#123; if (byteCount &lt; 0) throw new IllegalArgumentException("byteCount &lt; 0: " + byteCount); if (byteCount == 0) return 0; try &#123; timeout.throwIfReached(); Segment tail = sink.writableSegment(1); int maxToCopy = (int) Math.min(byteCount, Segment.SIZE - tail.limit); int bytesRead = in.read(tail.data, tail.limit, maxToCopy); if (bytesRead == -1) return -1; tail.limit += bytesRead; sink.size += bytesRead; return bytesRead; &#125; catch (AssertionError e) &#123; if (isAndroidGetsocknameError(e)) throw new IOException(e); throw e; &#125; &#125; @Override public void close() throws IOException &#123; in.close(); &#125; @Override public Timeout timeout() &#123; return timeout; &#125; @Override public String toString() &#123; return "source(" + in + ")"; &#125; &#125;;&#125; Http2.0http2.0协议标准于2015年5月以RFC 7540正式发表, 在介绍http2.0之前我们先看下http协议的发展的几个阶段 http/1.x 一次只允许在一个TCP连接上发起一个请求，单向，只能由客户端发起，数据未压缩 SPDY 支持多路复用（Tcp连接复用），header压缩，强制使用https加密传输，服务端推送 http/2.0 支持明文和加密传输，优化了header压缩算法，支持SDPY现有功能 Quic 基于UDP的稳定传输协议 Http2.0连接过程HTTP/2协议在TCP连接之初进行协商通信，只有协商成功，才会涉及到后续的请求-响应等具体的业务型数据交换。 Http2.0明文连接的主要过程如下: 客户端发起请求，只有请求报头，携带Upgrade 相关头部信息，用于试探服务器是否支持Http2.0 GET / HTTP/1. 1Host: server. example. comConnection: Upgrade, HTTP2-SettingsUpgrade: h2cHTTP2-Settings: &lt;base64url encoding of HTTP/2 SETTINGS payload&gt; 服务器支持HTTP/2，则通知客户端切换到HTTP/2 HTTP/1. 1 101 Switching ProtocolsConnection: UpgradeUpgrade: h2c[ HTTP/2 connection . . . 101响应空行之后，服务器必须发送的第一个帧为SETTINGS帧（其负载可能为空）作为连接序言 客户端接收到101响应后，也必须发送一个序言作为响应，其逻辑结构如下 PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n // 纯字符串表示，翻译成字节数为24个字节SETTINGS帧 // 其负载可能为空 服务器端和客户端所发送的连接序言有所不同。 客户端可以马上发送请求帧或其它帧过去，不用等待来自服务器端的SETTINGS帧 任一端接收到SETTINGS帧之后，都需要返回一个包含确认标志位SETTIGN作为确认 其它帧的正常传输 其他连接建立过程大家可以自行查阅。 HTTP/2 帧HTTP/2下终端之间使用帧的数据形式进行数据交换，一个标准的帧的格式如下 +-----------------------------------------------+| Length (24) |+---------------+---------------+---------------+| Type (8) | Flags (8) |+-+-------------+---------------+-------------------------------+|R| Stream Identifier (31) |+=+=============================================================+| Frame Payload (0...) ...+---------------------------------------------------------------+ HTTP/2下有多种类型的帧，帧的类型由Type指定，具体类型下的一些标志位由Flags指定，我们上文提到的SETTINGS帧则是HTTP/2所支持的帧的一种。对HTTP/2有兴趣的可以查阅RFC 7540 以及相关技术文档 ConnectInterceptorConnectInterceptor 主要用于创建和复用TCP连接，拦截器中的主要代码就一行 HttpCodec httpCodec = streamAllocation.newStream(client, chain, doExtensiveHealthChecks); 最终的核心代码在 StreamAllocation 中 private RealConnection findConnection(int connectTimeout, int readTimeout, int writeTimeout, int pingIntervalMillis, boolean connectionRetryEnabled) throws IOException &#123; boolean foundPooledConnection = false; ...... synchronized (connectionPool) &#123; ...... if (result == null) &#123; // Attempt to get a connection from the pool. Internal.instance.get(connectionPool, address, this, null);//1 if (connection != null) &#123; foundPooledConnection = true; result = connection; &#125; else &#123; selectedRoute = route; &#125; &#125; &#125; ...... if (result != null) &#123; // If we found an already-allocated or pooled connection, we're done. return result; &#125; // If we need a route selection, make one. This is a blocking operation. boolean newRouteSelection = false; if (selectedRoute == null &amp;&amp; (routeSelection == null || !routeSelection.hasNext())) &#123; newRouteSelection = true; routeSelection = routeSelector.next();//2 &#125; synchronized (connectionPool) &#123; if (canceled) throw new IOException("Canceled"); if (newRouteSelection) &#123; // Now that we have a set of IP addresses, make another attempt at getting a connection from // the pool. This could match due to connection coalescing. List&lt;Route&gt; routes = routeSelection.getAll(); for (int i = 0, size = routes.size(); i &lt; size; i++) &#123; Route route = routes.get(i); Internal.instance.get(connectionPool, address, this, route);//3 if (connection != null) &#123; foundPooledConnection = true; result = connection; this.route = route; break; &#125; &#125; &#125; if (!foundPooledConnection) &#123; if (selectedRoute == null) &#123; selectedRoute = routeSelection.next(); &#125; // Create a connection and assign it to this allocation immediately. This makes it possible // for an asynchronous cancel() to interrupt the handshake we're about to do. route = selectedRoute; refusedStreamCount = 0; result = new RealConnection(connectionPool, selectedRoute);//4 acquire(result, false); &#125; &#125; // If we found a pooled connection on the 2nd time around, we're done. if (foundPooledConnection) &#123; eventListener.connectionAcquired(call, result); return result; &#125; // Do TCP + TLS handshakes. This is a blocking operation. result.connect(connectTimeout, readTimeout, writeTimeout, pingIntervalMillis, connectionRetryEnabled, call, eventListener);//5 routeDatabase().connected(result.route()); ...... return result;&#125; 获取TCP连接的部分比较复杂，核心代码有5处，1和3都是尝试从 ConnectionPool 连接池中获取连接，4是在没有可复用的连接情况下创建了一个新的 RealConnection 对象，5是使用 RealConnection 进行网络连接，我们先看一下1和3到底有什么区别，他们最大的区别就在于第一次没有Route参数，第二次遍历了一个Route列表，传入Route参数。 RouteRoute 从命名上看起来很像IP层中的路由，其实不然，它可能代表了代理或者一个IP。 通常我们都是通过域名访问网络，但是事实上我们无法直接通过域名访问到服务器，首先需要通过DNS将域名解析到IP之后我们通过IP来访问资源，在 OkHttp 中这个过程通过DNS这个类来完成 Dns SYSTEM = new Dns() &#123; @Override public List&lt;InetAddress&gt; lookup(String hostname) throws UnknownHostException &#123; if (hostname == null) throw new UnknownHostException("hostname == null"); try &#123; return Arrays.asList(InetAddress.getAllByName(hostname)); &#125; catch (NullPointerException e) &#123; UnknownHostException unknownHostException = new UnknownHostException("Broken system behaviour for dns lookup of " + hostname); unknownHostException.initCause(e); throw unknownHostException; &#125; &#125;&#125;; OkHttp 默认使用 InetAddress 来完成域名解析，这个类是java网络包下用于完成DNS解析的类，具体DNS解析过程大家有兴趣可以自行查阅。域名通过DNS解析之后会返回一个列表，因为可能域名对应了多个ip，随后这些ip会被封装成一个个Route 对象，这个过程由上节2处的 routeSelector.next 触发。 public Selection next() throws IOException &#123; ...... // Compute the next set of routes to attempt. List&lt;Route&gt; routes = new ArrayList&lt;&gt;(); while (hasNextProxy()) &#123; Proxy proxy = nextProxy(); for (int i = 0, size = inetSocketAddresses.size(); i &lt; size; i++) &#123; Route route = new Route(address, proxy, inetSocketAddresses.get(i)); if (routeDatabase.shouldPostpone(route)) &#123; postponedRoutes.add(route); &#125; else &#123; routes.add(route); &#125; &#125; ....... return new Selection(routes); &#125;private void resetNextInetSocketAddress(Proxy proxy) throws IOException &#123; // Clear the addresses. Necessary if getAllByName() below throws! inetSocketAddresses = new ArrayList&lt;&gt;(); ...... if (proxy.type() == Proxy.Type.SOCKS) &#123; inetSocketAddresses.add(InetSocketAddress.createUnresolved(socketHost, socketPort)); &#125; else &#123; // Try each address for best behavior in mixed IPv4/IPv6 environments. List&lt;InetAddress&gt; addresses = address.dns().lookup(socketHost); for (int i = 0, size = addresses.size(); i &lt; size; i++) &#123; InetAddress inetAddress = addresses.get(i); inetSocketAddresses.add(new InetSocketAddress(inetAddress, socketPort)); &#125; &#125; nextInetSocketAddressIndex = 0; &#125; 了解完Route的概念我们再回头来看 ConnectionPool 的get方法 @Nullable RealConnection get(Address address, StreamAllocation streamAllocation, Route route) &#123; assert (Thread.holdsLock(this)); for (RealConnection connection : connections) &#123; if (connection.isEligible(address, route)) &#123; streamAllocation.acquire(connection); return connection; &#125; &#125; return null;&#125; 方法会遍历所有空闲的 RealConnection ，通过 isEligible 判断连接可用之后则会复用连接。 public boolean isEligible(Address address, @Nullable Route route) &#123; // If this connection is not accepting new streams, we're done. if (allocations.size() &gt;= allocationLimit || noNewStreams) return false; // If the non-host fields of the address don't overlap, we're done. if (!Internal.instance.equalsNonHost(this.route.address(), address)) return false; // If the host exactly matches, we're done: this connection can carry the address. if (address.url().host().equals(this.route().address().url().host())) &#123; return true; // This connection is a perfect match. &#125; // At this point we don't have a hostname match. But we still be able to carry the request if // our connection coalescing requirements are met. See also: // https://hpbn.co/optimizing-application-delivery/#eliminate-domain-sharding // https://daniel.haxx.se/blog/2016/08/18/http2-connection-coalescing/ // 1. This connection must be HTTP/2. if (http2Connection == null) return false; // 2. The routes must share an IP address. This requires us to have a DNS address for both // hosts, which only happens after route planning. We can't coalesce connections that use a // proxy, since proxies don't tell us the origin server's IP address. if (route == null) return false; if (route.proxy().type() != Proxy.Type.DIRECT) return false; if (this.route.proxy().type() != Proxy.Type.DIRECT) return false; if (!this.route.socketAddress().equals(route.socketAddress())) return false; // 3. This connection's server certificate's must cover the new host. if (route.address().hostnameVerifier() != OkHostnameVerifier.INSTANCE) return false; if (!supportsUrl(address.url())) return false; // 4. Certificate pinning must match the host. try &#123; address.certificatePinner().check(address.url().host(), handshake().peerCertificates()); &#125; catch (SSLPeerUnverifiedException e) &#123; return false; &#125; return true; // The caller's address can be carried by this connection.&#125; 复用连接的条件在注释写的很清楚了 当前连接承载已经到了上限或者noNewStreams ，则无法复用 当Address中除了域名外其他信息比如协议、端口等相关信息有不相同的则无法复用 通过上述条件后，域名相同可以直接复用 域名不同情况，需要满足如下条件才能复用 当前连接和要创建的连接代理类型均为直接连接 ip地址相同 当前连接的ssl证书必须包括新的ip ssl-Pinner验证要通过 连接复用的部分到此结束。 连接过程当无法复用连接时，会创建新的 RealConnection 并开始连接过程 public void connect(int connectTimeout, int readTimeout, int writeTimeout, int pingIntervalMillis, boolean connectionRetryEnabled, Call call, EventListener eventListener) &#123; //SSLFactory和传输协议的校验 ..... while (true) &#123; try &#123; if (route.requiresTunnel()) &#123; //使用ssl加密传输，但是使用了HTTP代理，需要使用隧道 ...... &#125; else &#123; connectSocket(connectTimeout, readTimeout, call, eventListener);//1 &#125; establishProtocol(connectionSpecSelector, pingIntervalMillis, call, eventListener);//2 eventListener.connectEnd(call, route.socketAddress(), route.proxy(), protocol); break; &#125; catch (IOException e) &#123; ...... &#125; &#125; //根据服务器返回的settins帧确定连接最大承载量 ......&#125; 核心代码主要有两处： 建立socket连接 private void connectSocket(int connectTimeout, int readTimeout, Call call, EventListener eventListener) throws IOException &#123; Proxy proxy = route.proxy(); Address address = route.address(); rawSocket = proxy.type() == Proxy.Type.DIRECT || proxy.type() == Proxy.Type.HTTP ? address.socketFactory().createSocket() : new Socket(proxy); eventListener.connectStart(call, route.socketAddress(), proxy); //设置连接超时长 rawSocket.setSoTimeout(readTimeout); try &#123; //连接socket Platform.get().connectSocket(rawSocket, route.socketAddress(), connectTimeout); &#125; catch (ConnectException e) &#123; ConnectException ce = new ConnectException("Failed to connect to " + route.socketAddress()); ce.initCause(e); throw ce; &#125; try &#123; //获取输入输出流，使用Okio进行封装 source = Okio.buffer(Okio.source(rawSocket)); sink = Okio.buffer(Okio.sink(rawSocket)); &#125; catch (NullPointerException npe) &#123; if (NPE_THROW_WITH_NULL.equals(npe.getMessage())) &#123; throw new IOException(npe); &#125; &#125;&#125; 确定传输协议（HTTP/1.1或者HTTP/2） establishProtocol 这里会确认传输协议，具体有三种情况 HTTP/1.1协议 HTTP/2明文传输(h2c) HTTP/2加密传输(h2) 如果是HTTP/1.1协议则连接建立完成，如果是HTTP/2协议，则会开始HTTP/2 的连接建立过程，如果是HTTP/2加密传输还会先开始TLS握手过程 private void connectTls(ConnectionSpecSelector connectionSpecSelector) throws IOException &#123; Address address = route.address(); SSLSocketFactory sslSocketFactory = address.sslSocketFactory(); boolean success = false; SSLSocket sslSocket = null; try &#123; // Create the wrapper over the connected socket. sslSocket = (SSLSocket) sslSocketFactory.createSocket( rawSocket, address.url().host(), address.url().port(), true /* autoClose */); // Configure the socket's ciphers, TLS versions, and extensions. ConnectionSpec connectionSpec = connectionSpecSelector.configureSecureSocket(sslSocket); if (connectionSpec.supportsTlsExtensions()) &#123; Platform.get().configureTlsExtensions( sslSocket, address.url().host(), address.protocols()); &#125; // Force handshake. This can throw! sslSocket.startHandshake(); // block for session establishment SSLSession sslSocketSession = sslSocket.getSession(); Handshake unverifiedHandshake = Handshake.get(sslSocketSession); // Verify that the socket's certificates are acceptable for the target host. if (!address.hostnameVerifier().verify(address.url().host(), sslSocketSession)) &#123; X509Certificate cert = (X509Certificate) unverifiedHandshake.peerCertificates().get(0); throw new SSLPeerUnverifiedException("Hostname " + address.url().host() + " not verified:" + "\n certificate: " + CertificatePinner.pin(cert) + "\n DN: " + cert.getSubjectDN().getName() + "\n subjectAltNames: " + OkHostnameVerifier.allSubjectAltNames(cert)); &#125; // Check that the certificate pinner is satisfied by the certificates presented. address.certificatePinner().check(address.url().host(), unverifiedHandshake.peerCertificates()); // Success! Save the handshake and the ALPN protocol. String maybeProtocol = connectionSpec.supportsTlsExtensions() ? Platform.get().getSelectedProtocol(sslSocket) : null; //ssl验证通过，使用sslSocket替代当前socket ...... &#125; catch (AssertionError e) &#123; ...... &#125; finally &#123; ...... &#125;&#125; 整个握手过程可以分为如下几个步骤 通过sslSocketFactory获取sslSocket，这个是使用TLS加密层封装过的socket 设置参数TSL参数 TSL握手和hostnameVerifier校验，这个是标准的TLS验证过程 ssl-pinner校验 TLS和SSL其实是两种协议，但是TLS建立在SSL3.0之上，是SSL3.0的后续版本，甚至TLS1.0在某种意义上都可以为称为SSL3.1，目前SSL协议已经基本被废弃，转而使用TLS，但是习惯上会使用TLS/SSL协议 之后便正式开始HTTP/2的连接过程,此时会创建一个 Http2Connection 对象，并调用它的start方法 void start(boolean sendConnectionPreface) throws IOException &#123; if (sendConnectionPreface) &#123; writer.connectionPreface(); writer.settings(okHttpSettings); int windowSize = okHttpSettings.getInitialWindowSize(); if (windowSize != Settings.DEFAULT_INITIAL_WINDOW_SIZE) &#123; writer.windowUpdate(0, windowSize - Settings.DEFAULT_INITIAL_WINDOW_SIZE); &#125; &#125; new Thread(readerRunnable).start(); // Not a daemon thread.&#125; 前面在介绍HTTP/2协议在开始会发送 Upgrade 试探服务器是否支持HTTP/2，但上述代码中其实没有这个步骤，这个是因为此时已经确定使用 HTTP/2协议，所以省略了这个步骤，直接开始发送连接序言，而后发送SETTINS帧，同时会开启线程接受服务端的连接序言以及后续帧。 CallServerInterceptor在理解HTTP/2和OKIO的前提下，CallServerInterceptor 的内容其实已经不难理解了，首先在 CallServerInterceptor 时，HTTP/2的连接已经完成，开始正式的数据交换 @Override public Response intercept(Chain chain) throws IOException &#123; ...... //写入头部信息 httpCodec.writeRequestHeaders(request); realChain.eventListener().requestHeadersEnd(realChain.call(), request); Response.Builder responseBuilder = null; if (HttpMethod.permitsRequestBody(request.method()) &amp;&amp; request.body() != null) &#123; //100-continue 头部的处理， ...... if (responseBuilder == null) &#123; // Write the request body if the "Expect: 100-continue" expectation was met. realChain.eventListener().requestBodyStart(realChain.call()); long contentLength = request.body().contentLength(); CountingSink requestBodyOut = new CountingSink(httpCodec.createRequestBody(request, contentLength)); BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut); request.body().writeTo(bufferedRequestBody); bufferedRequestBody.close(); realChain.eventListener() .requestBodyEnd(realChain.call(), requestBodyOut.successfulCount); &#125; else if (!connection.isMultiplexed()) &#123; // If the "Expect: 100-continue" expectation wasn't met, prevent the HTTP/1 connection // from being reused. Otherwise we're still obligated to transmit the request body to // leave the connection in a consistent state. streamAllocation.noNewStreams(); &#125; &#125; httpCodec.finishRequest(); if (responseBuilder == null) &#123; realChain.eventListener().responseHeadersStart(realChain.call()); responseBuilder = httpCodec.readResponseHeaders(false); &#125; Response response = responseBuilder .request(request) .handshake(streamAllocation.connection().handshake()) .sentRequestAtMillis(sentRequestMillis) .receivedResponseAtMillis(System.currentTimeMillis()) .build(); int code = response.code(); //非200其他错误码的处理 ...... if ("close".equalsIgnoreCase(response.request().header("Connection")) || "close".equalsIgnoreCase(response.header("Connection"))) &#123; streamAllocation.noNewStreams(); &#125; ...... return response;&#125; 整个过程可以分为几个部分 请求头发送 请求体的发送 响应头的读取 响应体的读取 Header的封装和传输头部的传输从 httpCodec.writeRequestHeaders 开始，这里针对HTTP/1.1和HTTP/2有一定的区分，HTTP/1.1会直接将头部信息写入Sink ，也就是Okio的输出流中，对于HTTP/2中这个行为将有所不同，在HTTP/2会调用 Http2Connection.newStream 方法 public Http2Stream newStream(List&lt;Header&gt; requestHeaders, boolean out) throws IOException &#123; return newStream(0, requestHeaders, out);&#125;private Http2Stream newStream( int associatedStreamId, List&lt;Header&gt; requestHeaders, boolean out) throws IOException &#123; boolean outFinished = !out; boolean inFinished = false; boolean flushHeaders; Http2Stream stream; int streamId; synchronized (writer) &#123; synchronized (this) &#123; if (nextStreamId &gt; Integer.MAX_VALUE / 2) &#123; shutdown(REFUSED_STREAM); &#125; if (shutdown) &#123; throw new ConnectionShutdownException(); &#125; streamId = nextStreamId; nextStreamId += 2; stream = new Http2Stream(streamId, this, outFinished, inFinished, requestHeaders); flushHeaders = !out || bytesLeftInWriteWindow == 0L || stream.bytesLeftInWriteWindow == 0L; if (stream.isOpen()) &#123; streams.put(streamId, stream); &#125; &#125; if (associatedStreamId == 0) &#123; writer.synStream(outFinished, streamId, associatedStreamId, requestHeaders); &#125; else if (client) &#123; throw new IllegalArgumentException("client streams shouldn't have associated stream IDs"); &#125; else &#123; // HTTP/2 has a PUSH_PROMISE frame. writer.pushPromise(associatedStreamId, streamId, requestHeaders); &#125; &#125; if (flushHeaders) &#123; writer.flush(); &#125; return stream;&#125; 这里会创建一个 Http2Stream ，这个其实是一个抽象的概念，内部封装了HTTP/2请求中双向流的概念，同时会调用 writer.synStream ，最终会调用 Http2Writer.headers 方法， void headers(boolean outFinished, int streamId, List&lt;Header&gt; headerBlock) throws IOException &#123; if (closed) throw new IOException("closed"); hpackWriter.writeHeaders(headerBlock); long byteCount = hpackBuffer.size(); int length = (int) Math.min(maxFrameSize, byteCount); byte type = TYPE_HEADERS; byte flags = byteCount == length ? FLAG_END_HEADERS : 0; if (outFinished) flags |= FLAG_END_STREAM; frameHeader(streamId, length, type, flags); sink.write(hpackBuffer, length); if (byteCount &gt; length) writeContinuationFrames(streamId, byteCount - length); &#125; 这里有两个关键的点 HTTP/2头部压缩，hpackWriter所在Hpack类就是HTTP用于头部压缩的类 HTTP帧的概念，这个也在前面有提过，这里开始真正应用了 HpackHpack就是HTTP/2引入的新的头部压缩方案，在此之前主要的头部压缩算法是deflate算法（一种主要基于哈夫曼编码和 LZ77压缩的算法），主要做的还是单纯的字符串压缩，Hpack压缩主要有三种压缩方法 静态字典：一个有着 61 个通用头部字段，并且部分字段是有预定义值的预定义字典。 动态字典：在连接中，一系列实际的头部会被添加进去。因为字典有限制大小，所以当新项被增加，旧项会被去除。 Huffman 编码： 一种可以被用来对任何字符串：键或者值（译者注：下文 name 对应键，value 对应值），进行编码的静态 Huffman 编码。这种编码方式是专门为 HTTP 响应或者响应头部设计的——ASCII 里的数字和小写字母可以编码地更短，最短可以编码为 5 个比特（bits）。因此最高压缩比可以达到 8:5 (也就是最多可以降低 37.5%)。 OkHttp中的Hpack类就是这个算法的实现类，最终压缩之后的头部会写入到一个Buffer缓冲区中，然后通过 frameHeader 方法来为Header信息添加帧的头部信息，同时确定Header的长度是否需要分帧，因为在HTTP/2中帧的大小是有限制的，这个限制由服务端的SETTINGS帧和默认的帧大小（如果还没有收到SETTINGS帧）来确定。 到此 为止 CallServerInterceptor 也没有太多陌生的东西的，剩余的基本就是对 Source 和 Sink 的封装以及各种IO操作了。 Title:网络连接过程StreamAllocation-&gt;StreamAllocation:newStreamStreamAllocation-&gt;StreamAllocation:findHealthyConnectionStreamAllocation-&gt;StreamAllocation:findConnectionStreamAllocation-&gt;ConnectionPool:get：尝试复用连接Note left of ConnectionPool:复用成功ConnectionPool-&gt;StreamAllocation:RealConnectionNote right of StreamAllocation:复用不成功StreamAllocation-&gt;RealConnection:创建新连接 RealConnection-&gt;RealConnection:connectRealConnection-&gt;RealConnection:connectSocketRealConnection-&gt;RealConnection:establishProtocolRealConnection-&gt;Http2Connection:创建Http2连接Http2Connection-&gt;Http2Connection:start：开始连接Http2Connection-&gt;RealConnection:RealConnection-&gt;RealConnection:通过socket获取Sink和SourceRealConnection-&gt;StreamAllocation:StreamAllocation-&gt;RealConnection:newCodecRealConnection-&gt;Http2Codec:创建Codec Title:网络请求过程Http2Codec-&gt;Http2Codec:writeRequestHeadersHttp2Codec-&gt;Http2Connection:newStream RxJavarxjava在网络请求的过程中主要两个地方： 前面说到过的Retrofit 中的 CallAdapter ，这里我们有一个Rxjava专用的 CallAdapter Rxjava强大现场转换功能 我们关注的也仅限于这两点，其他操作符，大家可以自行研究 RxJava2CallAdapterFactory前面说到 CallAdapter 是通过抽象工厂模式创建的，RxJava2CallAdapterFactory 就是一个CallAdapter 的具体工厂。 在开始之前我们先了解反射的相关知识，此处对于 Class 对象以及相关操作就不多做介绍，这里主要针对有泛型的情况。 泛型擦除与反射我们知道Java有泛型擦除的机制，但是编译之后真的就没有泛型的概念了吗？考虑如下代码 public class Test&lt;T extends String&gt;&#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); public List&lt;String&gt; addItems(List&lt;String&gt; list)&#123; List&lt;String&gt; newList = new ArrayList&lt;&gt;(); newList.addAll(list); return newList; &#125;&#125; 上述代码经过编译和反编译还会保留什么信息？下面是编译完再反编译之后的代码 public class Test&lt;T extends String&gt; extends Object &#123; List&lt;String&gt; list = new ArrayList(); public List&lt;String&gt; addItems(List&lt;String&gt; paramList) &#123; ArrayList arrayList = new ArrayList(); arrayList.addAll(paramList); return arrayList; &#125;&#125; 可以看到部分泛型确实以及被擦除了，但是定义在类上，成员变量以及方法上的泛型都保留了，我们回头看一下 Class 类的定义 public final class Class&lt;T&gt; implements java.io.Serializable, GenericDeclaration, Type, AnnotatedElement 可以看到 Class 实现了Type 接口，反射包下的 Type 接口就是类型的抽象，除了 Class 他还有几个其他的实现 ParameterizedType 带参数的类型，即泛型，如：List&lt;T&gt;、Map&lt;Integer, String&gt; GenericArrayType (泛型)数组类型,比如 List&lt;T&gt;[]，T[] 这种 WildcardType 代表通配符表达式，或泛型表达式，比如 ?, ? super T TypeVariable 类型变量，描述类型，表示泛指任意或相关一类类型，比如 K、V、E 等 抽象工厂CallAdapter.Factory 作为 CallAdapter 工厂的抽象类，它定义获取创建 CallAdapter 的抽象方法 public abstract CallAdapter&lt;?&gt; get(Type returnType, Annotation[] annotations, Retrofit retrofit); 可以看到第一个入参就是我们上节提到的 Type 类型，这个对象通过 Method.getGenericReturnType 返回，这个是一个携带范型信息的类型。 RxJava2CallAdapterFactory 实现的get方法如下 public CallAdapter&lt;?&gt; get(Type returnType, Annotation[] annotations, Retrofit retrofit) &#123; Class&lt;?&gt; rawType = getRawType(returnType); if (rawType == Completable.class) &#123; return new RxJava2CallAdapter(Void.class, scheduler, false, true, false, false, false, true); &#125; boolean isFlowable = rawType == Flowable.class; boolean isSingle = rawType == Single.class; boolean isMaybe = rawType == Maybe.class; if (rawType != Observable.class &amp;&amp; !isFlowable &amp;&amp; !isSingle &amp;&amp; !isMaybe) &#123; return null; &#125; boolean isResult = false; boolean isBody = false; Type responseType; if (!(returnType instanceof ParameterizedType)) &#123; String name = isFlowable ? "Flowable" : isSingle ? "Single" : "Observable"; throw new IllegalStateException(name + " return type must be parameterized" + " as " + name + "&lt;Foo&gt; or " + name + "&lt;? extends Foo&gt;"); &#125; Type observableType = getParameterUpperBound(0, (ParameterizedType) returnType); Class&lt;?&gt; rawObservableType = getRawType(observableType); if (rawObservableType == Response.class) &#123; if (!(observableType instanceof ParameterizedType)) &#123; throw new IllegalStateException("Response must be parameterized" + " as Response&lt;Foo&gt; or Response&lt;? extends Foo&gt;"); &#125; responseType = getParameterUpperBound(0, (ParameterizedType) observableType); &#125; else if (rawObservableType == Result.class) &#123; if (!(observableType instanceof ParameterizedType)) &#123; throw new IllegalStateException("Result must be parameterized" + " as Result&lt;Foo&gt; or Result&lt;? extends Foo&gt;"); &#125; responseType = getParameterUpperBound(0, (ParameterizedType) observableType); isResult = true; &#125; else &#123; responseType = observableType; isBody = true; &#125; return new RxJava2CallAdapter(responseType, scheduler, isResult, isBody, isFlowable, isSingle, isMaybe, false); &#125; 整段代码逻辑基本上可以分为2个部分 获取原始类型，过滤掉非RxJava支持的原始类型 获取范型类型，过滤掉没有上界的范型类型 RxJava2CallAdapter 的实现相对就比较简单了，就是将 Call 封装成 Observable ，这里根据上面范型类型的不同会有三种 Observable ，但是没有本质的区别，只是对结果的不同封装，有兴趣可以自行了解。 线程变换Scheduler调度器在Rxjava的线程变换中 Scheduler 占据的很大分量，在Rxjava中的几个线程变换的方法也是基于Scheduler来完成的，我们首先来看下 Scheduler 的定义。 可以看到 Scheduler 下的方法不多，还有一个内部类，这些方法基本可以分为三类 工具方法，没有太多逻辑，这里不多做介绍 模版方法，入参都以Runnable 为主 scheduleDirect 直接在Scheduler指定的线程在对Runnable调度 schedulePeriodicallyDirect 在 Scheduler 所指定线程周期性的执行Runnable 需要子类实现的方法 createWorker 用于创建 Worker ， Worker 继承自 Disposable ，熟悉RxJava的同学应该知道，这个用于表示一次性用品，当dispose调用后Disposable 的工作就终止了 ，而Worker 主要是Runnable的执行体 start 一般用于以线程池实现的Scheduler , 用于开始线程池 shutdown 一般用于结束线程池 首先我们先看下 Scheduler 下的主要模版方法 scheduleDirect public Disposable scheduleDirect(Runnable run, long delay, TimeUnit unit) &#123; final Worker w = createWorker(); //RxJavaPlugins算是RxJava中一个全局的配置类，配置一些关键的代理点，也就是Hook点， //我们可以通过它的参数实现全局的配置 //此处没有配置的情况下decoratedRun还是run本身 final Runnable decoratedRun = RxJavaPlugins.onSchedule(run); w.schedule(new Runnable() &#123; @Override public void run() &#123; try &#123; decoratedRun.run(); &#125; finally &#123; w.dispose(); &#125; &#125; &#125;, delay, unit); return w;&#125; 可以看到scheduleDirect 的主要工作是通过 Worker 来完成的，而 Worker 的实现主要又依赖于它的实现类。接下来我们以IoScheduler 为例，来了解 Scheduler 实现。 static &#123; //NONE为一个空的 NONE = new CachedWorkerPool(0, null);&#125;@Overridepublic void start() &#123; //CachedWorkerPool是一个WorkerPool CachedWorkerPool update = new CachedWorkerPool(KEEP_ALIVE_TIME, KEEP_ALIVE_UNIT, threadFactory); //pool为AtomicReferencel类，compareAndSet可以用于实现原子操作 if (!pool.compareAndSet(NONE, update)) &#123; update.shutdown(); &#125;&#125;@Overridepublic void shutdown() &#123; for (;;) &#123; CachedWorkerPool curr = pool.get(); if (curr == NONE) &#123; return; &#125; if (pool.compareAndSet(curr, NONE)) &#123; curr.shutdown(); return; &#125; &#125;&#125;@NonNull@Overridepublic Worker createWorker() &#123; return new EventLoopWorker(pool.get());&#125; 可以看到IoScheduler类中本身也没有太多的逻辑，核心的逻辑主要还是由 EventLoopWorker 这个 Worker 的实现类来完成的，在开始之前我们需要先了解一下 IoScheduler 的特点，它主要为 IO 密集型设计，IO 密集型的特点就是大量时间在等待磁盘，一定范围内，任务越多，性能越好。 EventLoopWorker 在构造函数中会从 CachedWorkerPool 中获取 Worker ThreadWorker get() &#123; if (allWorkers.isDisposed()) &#123; return SHUTDOWN_THREAD_WORKER; &#125; while (!expiringWorkerQueue.isEmpty()) &#123; ThreadWorker threadWorker = expiringWorkerQueue.poll(); if (threadWorker != null) &#123; return threadWorker; &#125; &#125; // No cached worker found, so create a new one. ThreadWorker w = new ThreadWorker(threadFactory); allWorkers.add(w); return w;&#125; 可以看到CachedWorkerPool 其实就是一个 Worker 池，他会回收和复用 Worker ，ThreadWorker 继承自NewThreadWorker ，主要扩展了超时的概念，实际的逻辑在父类中实现 public NewThreadWorker(ThreadFactory threadFactory) &#123; executor = SchedulerPoolFactory.create(threadFactory);&#125; NewThreadWorker 的构造函数会创建一个线程池，创建的线程池是ScheduledThreadPoolExecutor ，这个是一个线程数量无限制，且可以执行延迟任务和周期任务的线程池，具体实现大家自行查阅，NewThreadWorker 的 schedule 主要也是依赖这个线程池 public Disposable scheduleDirect(final Runnable run, long delayTime, TimeUnit unit) &#123; ScheduledDirectTask task = new ScheduledDirectTask(RxJavaPlugins.onSchedule(run)); try &#123; Future&lt;?&gt; f; if (delayTime &lt;= 0L) &#123; f = executor.submit(task); &#125; else &#123; f = executor.schedule(task, delayTime, unit); &#125; task.setFuture(f); return task; &#125; catch (RejectedExecutionException ex) &#123; RxJavaPlugins.onError(ex); return EmptyDisposable.INSTANCE; &#125;&#125; 线程变换方法我们首先以 subscribeOn 为例来了解这个过程 public final Observable&lt;T&gt; subscribeOn(Scheduler scheduler) &#123; ObjectHelper.requireNonNull(scheduler, "scheduler is null"); return RxJavaPlugins.onAssembly(new ObservableSubscribeOn&lt;T&gt;(this, scheduler));&#125; subscribeOn 主要是创建了一个新的Observable ，我们主要来看一下它的subscribeActual ，这个是我们订阅时最终调用的方法。也就是当subscribeOn 生成的Observable 方法的subscribe 被调用时调用的方法 @Overridepublic void subscribeActual(final Observer&lt;? super T&gt; observer) &#123; //创建了一个Observer，其实大部分RxJava的操作符都会创建一个Observable和一个Observer final SubscribeOnObserver&lt;T&gt; parent = new SubscribeOnObserver&lt;T&gt;(observer); //onSubscribe回调 observer.onSubscribe(parent); //调度任务 parent.setDisposable(scheduler.scheduleDirect(new SubscribeTask(parent)));&#125; 可以看到核心代码在最后一行我们使用Scheduler去调度一个Runnable ,以IOScheduler 为例，他会使用一个ScheduledThreadPoolExecutor的线程池来执行这个Runnable，也就是这个Runable 最终是在一个线程池中运行的。 final class SubscribeTask implements Runnable &#123; private final SubscribeOnObserver&lt;T&gt; parent; SubscribeTask(SubscribeOnObserver&lt;T&gt; parent) &#123; this.parent = parent; &#125; @Override public void run() &#123; source.subscribe(parent); &#125;&#125; 这个 Runnable 的实现也非常简单，但是也是 Rxjava 操作符的核心，链式操作。 参考OKio - 重新定义了“短小精悍”的IO框架 HTTP/2 - 维基百科 HTTP/2笔记之连接建立 HTTP/2笔记之帧 HPACK：http2中沉默的杀手 数据压缩算法-DEFLATE Java 如何在运行时获取被擦除的泛型参数类型 关于RxJava最友好的文章——背压（Backpressure）]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Glidle杂记]]></title>
    <url>%2F2019%2F07%2F09%2Fgilde%2F</url>
    <content type="text"><![CDATA[[TOC] Glide杂记Glide使用过程加载过程主要有如下几个步骤 with ReqestManager （Lifecycle，RequestTracker）管理关联在同一个Activity（不包括子Activity）或者说关联在统一Fragment上的所有Request load RequestBuilder 设置请求的各种参数，用于创建请求 into Request.begin 开始请求 总体来说Glide的使用可以分为Request构造和Request运行两个部分 Reqest构造过程Reqest的构造过程主要完成了两件事： 宿主（Activity、Fragment等）生命周期的绑定 Request参数的创建的管理 生命周期绑定 Request参数设置Request参数除了我们手动设置的url、placeHolder、transform等参数之外在创建真正的Request之前还会确定几个重要的策略，这些策略在Glide的不同版本可能会有不同的组合，但整体结构没有太大变化 ModelLoader DataLoadProvider ModelLoader Glide请求过程Glide的请求过程主要分为 构造请求 DrawableTypeRequest GifTypeRequest BitmapTypeRequest 获取数据源 loadProvider 加载解码成可用的数据 显示 loadProvider可扩展的LoaderProvider FixedLoadProvider集成了DataLoadProvider、ModelLoader和ResourceTranscoder ModelLoader定义了数据源（从Uri、文件、String等获取原始的输入流或着其封装类） DataLoadProvider定义了输入流到目标资源以及缓存文件三者之间的转换关系 ResourceTranscoder定义了一种资源格式到另一种资源格式（Drawable、Bitmap、gif）的转码方式 ChildLoadProvider DataLoadProvider DataFetcher获取的数据源(InputSream等) 目标资源Resourse&lt;?&gt;（Bitmap，Drawable，Gif等） File 文件缓存 预设的DataLoadProvider dataLoadProviderRegistry = new DataLoadProviderRegistry(); StreamBitmapDataLoadProvider streamBitmapLoadProvider = new StreamBitmapDataLoadProvider(bitmapPool, decodeFormat); dataLoadProviderRegistry.register(InputStream.class, Bitmap.class, streamBitmapLoadProvider); FileDescriptorBitmapDataLoadProvider fileDescriptorLoadProvider = new FileDescriptorBitmapDataLoadProvider(bitmapPool, decodeFormat); dataLoadProviderRegistry.register(ParcelFileDescriptor.class, Bitmap.class, fileDescriptorLoadProvider); ImageVideoDataLoadProvider imageVideoDataLoadProvider = new ImageVideoDataLoadProvider(streamBitmapLoadProvider, fileDescriptorLoadProvider); dataLoadProviderRegistry.register(ImageVideoWrapper.class, Bitmap.class, imageVideoDataLoadProvider); GifDrawableLoadProvider gifDrawableLoadProvider = new GifDrawableLoadProvider(context, bitmapPool); dataLoadProviderRegistry.register(InputStream.class, GifDrawable.class, gifDrawableLoadProvider); dataLoadProviderRegistry.register(ImageVideoWrapper.class, GifBitmapWrapper.class, new ImageVideoGifDrawableLoadProvider(imageVideoDataLoadProvider, gifDrawableLoadProvider, bitmapPool)); dataLoadProviderRegistry.register(InputStream.class, File.class, new StreamFileDataLoadProvider()); ModelLoader 装饰者+适配器将我们通过load传入的参入转换成特定的DataFetcher输出（InputStream或者其封装类）Glide(Engine engine, MemoryCache memoryCache, BitmapPool bitmapPool, Context context, DecodeFormat decodeFormat) &#123; ...... //Model class ,Resource class, LoaderFactory register(File.class, ParcelFileDescriptor.class, new FileDescriptorFileLoader.Factory()); register(File.class, InputStream.class, new StreamFileLoader.Factory()); register(int.class, ParcelFileDescriptor.class, new FileDescriptorResourceLoader.Factory()); register(int.class, InputStream.class, new StreamResourceLoader.Factory()); register(Integer.class, ParcelFileDescriptor.class, new FileDescriptorResourceLoader.Factory()); register(Integer.class, InputStream.class, new StreamResourceLoader.Factory()); register(String.class, ParcelFileDescriptor.class, new FileDescriptorStringLoader.Factory()); register(String.class, InputStream.class, new StreamStringLoader.Factory()); register(Uri.class, ParcelFileDescriptor.class, new FileDescriptorUriLoader.Factory()); register(Uri.class, InputStream.class, new StreamUriLoader.Factory()); register(URL.class, InputStream.class, new StreamUrlLoader.Factory()); register(GlideUrl.class, InputStream.class, new HttpUrlGlideUrlLoader.Factory()); register(byte[].class, InputStream.class, new StreamByteArrayLoader.Factory()); ......&#125; DataFetcher 装饰者+适配器通过网络或者文件、资源等方式获取数据源 BitmapPoolLruPoolStrategySizeConfigStrategy GroupedLinkedMap&lt;Key, Bitmap&gt; groupedMap 自定义的LruCache，使用链表和HashMap实现 Map&lt;Bitmap.Config, NavigableMap&lt;Integer, Integer&gt;&gt; sortedSizes 以Bitmap的Config为纬度存储了对象池中每种对象大小的数量，用于快速判断是否存在可用的Bitmap对象缓存，这里使用的NavigableMap为TreeMap,key的存储方式为红黑树结构（使用红黑树是因为在复用时可能没有完全大小相同的Bitmap对象，所以会遍历整个map按大小顺序找到第一个比需要的Bitmap大的复用） Glide 缓存Key的构造EngineKey key = keyFactory.buildKey(id, signature, width, height, loadProvider.getCacheDecoder(), loadProvider.getSourceDecoder(), transformation, loadProvider.getEncoder(), transcoder, loadProvider.getSourceEncoder()); 从EngineKey的构造可以看出，即使是同一个Url下的不同尺寸或者不同的transformation、transcoder，也会产生不同的Key 缓存Glide的内存缓存中存在两种内存缓存机制、LruCache（使用LikedHashMap结构存储的强引用内存缓存，默认的缓存大小为两个整屏幕的图片大小）和使用弱引用存储的activeResources 优先从强引用中获取图片 其次试图从弱引用中获取图片 最后再考虑磁盘 LruCache的大小固定，即使内存情况良好，也不会缓存更多图片，使用弱引用就是为了在内存环境良好的情况下在内存中缓存更多的图片，从而提升缓存的加载速度。 EngineResource&lt;?&gt; cached = loadFromCache(key, isMemoryCacheable);if (cached != null) &#123; cb.onResourceReady(cached); if (Log.isLoggable(TAG, Log.VERBOSE)) &#123; logWithTimeAndKey("Loaded resource from cache", startTime, key); &#125; return null;&#125;EngineResource&lt;?&gt; active = loadFromActiveResources(key, isMemoryCacheable);if (active != null) &#123; cb.onResourceReady(active); if (Log.isLoggable(TAG, Log.VERBOSE)) &#123; logWithTimeAndKey("Loaded resource from active resources", startTime, key); &#125; return null;&#125;EngineJob current = jobs.get(key);if (current != null) &#123; current.addCallback(cb); if (Log.isLoggable(TAG, Log.VERBOSE)) &#123; logWithTimeAndKey("Added to existing load", startTime, key); &#125; return new LoadStatus(cb, current);&#125;EngineJob engineJob = engineJobFactory.build(key, isMemoryCacheable);DecodeJob&lt;T, Z, R&gt; decodeJob = new DecodeJob&lt;T, Z, R&gt;(key, width, height, fetcher, loadProvider, transformation, transcoder, diskCacheProvider, diskCacheStrategy, priority);EngineRunnable runnable = new EngineRunnable(engineJob, decodeJob, priority);jobs.put(key, engineJob);engineJob.addCallback(cb);engineJob.start(runnable); 代码中可以看出从内存缓存中获取Resource文件时，只使用原始的EngineKey，这样获取的Resource时是指定宽高且经过Transform和transcoder转换后的，由此也可以看出，内存缓存中只会有经过各种转换之后的图片资源 磁盘缓存过程在无法从内存中获取指定的图片资源之后，会尝试从磁盘或者网络获取，这个过程在EngineRunnable中完成private Resource&lt;?&gt; decode() throws Exception &#123; if (isDecodingFromCache()) &#123; return decodeFromCache(); &#125; else &#123; return decodeFromSource(); &#125; private Resource&lt;?&gt; decodeFromCache() throws Exception &#123; Resource&lt;?&gt; result = null; try &#123; result = decodeJob.decodeResultFromCache(); &#125; catch (Exception e) &#123; if (Log.isLoggable(TAG, Log.DEBUG)) &#123; Log.d(TAG, "Exception decoding result from cache: " + e); &#125; &#125; if (result == null) &#123; result = decodeJob.decodeSourceFromCache(); &#125; return result; &#125;&#125; 当从磁盘缓存中获取图片时会有两个过程 试图使用完整的EngineKey（包括宽、高、Transform和transcoder）获取指定的文件，当然DataLoadProvider只提供从File到指定中间资源类型的转化，这里从磁盘获取资源之后还是会使用transcoder进行转化 当无法通过完整的EngineKey获取到资源时，会尝试使用OriginalKey获取资源，OriginalKey只包含请求id和签名，只能查找原始没有经过任何大小或者其他转换前的资源文件public Resource&lt;Z&gt; decodeSourceFromCache() throws Exception &#123; if (!diskCacheStrategy.cacheSource()) &#123; return null; &#125; long startTime = LogTime.getLogTime(); Resource&lt;T&gt; decoded = loadFromCache(resultKey.getOriginalKey()); if (Log.isLoggable(TAG, Log.VERBOSE)) &#123; logWithTimeAndKey("Decoded source from cache", startTime); &#125; return transformEncodeAndTranscode(decoded);&#125;private Resource&lt;Z&gt; transformEncodeAndTranscode(Resource&lt;T&gt; decoded) &#123; long startTime = LogTime.getLogTime(); Resource&lt;T&gt; transformed = transform(decoded); if (Log.isLoggable(TAG, Log.VERBOSE)) &#123; logWithTimeAndKey("Transformed resource from source", startTime); &#125; writeTransformedToCache(transformed); startTime = LogTime.getLogTime(); Resource&lt;Z&gt; result = transcode(transformed); if (Log.isLoggable(TAG, Log.VERBOSE)) &#123; logWithTimeAndKey("Transcoded transformed from source", startTime); &#125; return result;&#125; 在第二次尝试从磁盘获取资源成功后会先通过transform来对中间的资源类型进行转换后，并把转换后同时宽高以及变换的图片写入磁盘缓存，最后进行transcode 网络请求在无法通过磁盘缓存获取到数据时，会进入一个异常处理流程，同时会判断异常是否是由于磁盘没有文件导致的 private void onLoadFailed(Exception e) &#123; if (isDecodingFromCache()) &#123; stage = Stage.SOURCE; manager.submitForSource(this); &#125; else &#123; manager.onException(e); &#125;&#125; 纵观全局在整个Glide的源码阅读过程中最大的印象就是缓存，图片有LRUcache，weakRefence、DiskLruCache，key有KeyPool，Bitmap有BitmapPool，ModelLoader有ModelLoaderCache 其次就是 储备知识ReferenceQueue FinalReference SoftReference WeakReference PhantomReference ReferenceQueue 主要适用于追踪后三种引用类型的被系统回收的情况，可以作为构造入参传入他们的构造函数中，系统会自动把被系统回收的对象添加到这个ReferenceQueue中。 ``````cppcollector::GcType Heap::CollectGarbageInternal(collector::GcType gc_type, GcCause gc_cause, bool clear_soft_references) &#123; Thread* self = Thread::Current(); Runtime* runtime = Runtime::Current(); // If the heap can&apos;t run the GC, silently fail and return that no GC was run. .....GC过程 // Enqueue cleared references. reference_processor_-&gt;EnqueueClearedReferences(self); // Grow the heap so that we know when to perform the next GC. GrowForUtilization(collector, bytes_allocated_before_gc); LogGC(gc_cause, collector); FinishGC(self, gc_type); // Inform DDMS that a GC completed. Dbg::GcDidFinish(); ...... return gc_type;&#125; 在Android系统GC完成时会调用ReferenceProcessor::EnqueueClearedReferences来把回收掉的引用放入引用队列中。 ``````cppvoid ReferenceProcessor::EnqueueClearedReferences(Thread* self) &#123; Locks::mutator_lock_-&gt;AssertNotHeld(self); // When a runtime isn&apos;t started there are no reference queues to care about so ignore. if (!cleared_references_.IsEmpty()) &#123; if (LIKELY(Runtime::Current()-&gt;IsStarted())) &#123; jobject cleared_references; &#123; ReaderMutexLock mu(self, *Locks::mutator_lock_); cleared_references = self-&gt;GetJniEnv()-&gt;vm-&gt;AddGlobalRef( self, cleared_references_.GetList()); &#125; if (kAsyncReferenceQueueAdd) &#123; // TODO: This can cause RunFinalization to terminate before newly freed objects are // finalized since they may not be enqueued by the time RunFinalization starts. Runtime::Current()-&gt;GetHeap()-&gt;GetTaskProcessor()-&gt;AddTask( self, new ClearedReferenceTask(cleared_references)); &#125; else &#123; ClearedReferenceTask task(cleared_references); task.Run(self); &#125; &#125; cleared_references_.Clear(); &#125;&#125; ReferenceProcessor主要通过Thread对象获取了回收的引用对象，创建了一个ClearedReferenceTask，这个task就是真正把回收的对象放入引用队列的方法 ``````cppclass ClearedReferenceTask : public HeapTask &#123; public: explicit ClearedReferenceTask(jobject cleared_references) : HeapTask(NanoTime()), cleared_references_(cleared_references) &#123; &#125; virtual void Run(Thread* thread) &#123; ScopedObjectAccess soa(thread); jvalue args[1]; args[0].l = cleared_references_; InvokeWithJValues(soa, nullptr, WellKnownClasses::java_lang_ref_ReferenceQueue_add, args); soa.Env()-&gt;DeleteGlobalRef(cleared_references_); &#125; private: const jobject cleared_references_;&#125;; ClearedReferenceTask主要作用就是回调Java层方法的相应方法 ``````javastatic void add(Reference&lt;?&gt; list) &#123; synchronized (ReferenceQueue.class) &#123; if (unenqueued == null) &#123; unenqueued = list; &#125; else &#123; // Find the last element in unenqueued. Reference&lt;?&gt; last = unenqueued; while (last.pendingNext != unenqueued) &#123; last = last.pendingNext; &#125; // Add our list to the end. Update the pendingNext to point back to enqueued. last.pendingNext = list; last = list; while (last.pendingNext != list) &#123; last = last.pendingNext; &#125; last.pendingNext = unenqueued; &#125; ReferenceQueue.class.notifyAll(); &#125;&#125; 到此为止，被回收的对象已经回到java层的ReferenceQueue 中，但是只是作为静态变量存储了，并没有进入相应的引用队列中，这个就得说起另外一个东西了,Deamons守护线程bool Runtime::Start() &#123; ..... StartDaemonThreads(); ......&#125;Runtime::StartDaemonThreads() &#123; ScopedTrace trace(__FUNCTION__); VLOG(startup) &lt;&lt; "Runtime::StartDaemonThreads entering"; Thread* self = Thread::Current(); // Must be in the kNative state for calling native methods. CHECK_EQ(self-&gt;GetState(), kNative); JNIEnv* env = self-&gt;GetJniEnv(); env-&gt;CallStaticVoidMethod(WellKnownClasses::java_lang_Daemons, WellKnownClasses::java_lang_Daemons_start); if (env-&gt;ExceptionCheck()) &#123; env-&gt;ExceptionDescribe(); LOG(FATAL) &lt;&lt; "Error starting java.lang.Daemons"; &#125; VLOG(startup) &lt;&lt; "Runtime::StartDaemonThreads exiting";&#125; 在Android Runtime的start方法中会调用一个StartDaemonThreads方法，最终会调用到java层Daemons.start方法。public static void start() &#123; //引用队列守护线程 ReferenceQueueDaemon.INSTANCE.start(); //析构守护线程 FinalizerDaemon.INSTANCE.start(); //析构监护守护线程 FinalizerWatchdogDaemon.INSTANCE.start(); //守护堆任务线程 HeapTaskDaemon.INSTANCE.start();&#125; 在Daemons中有好几个守护线程，我们主要关注的是ReferenceQueueDaemon引用队列守护线程public void runInternal() &#123; while (isRunning()) &#123; Reference&lt;?&gt; list; try &#123; synchronized (ReferenceQueue.class) &#123; while (ReferenceQueue.unenqueued == null) &#123; ReferenceQueue.class.wait(); &#125; list = ReferenceQueue.unenqueued; ReferenceQueue.unenqueued = null; &#125; &#125; catch (InterruptedException e) &#123; continue; &#125; catch (OutOfMemoryError e) &#123; continue; &#125; ReferenceQueue.enqueuePending(list); &#125;&#125; 在ReferenceQueueDaemon.runInternal方法中会获取前面GC后存入ReferenceQueue.unenqueued然后把引用分别放入每个ReferenceQueue中，Over！ MessageQueueMessageQueue用于Handle机制中传递消息，但是在Handle机制中我们关注的是MessageQueue.next方法的前半部分,Message next() &#123; ...... for (;;) &#123; ...... synchronized (this) &#123; //get Message and return // If first time idle, then get the number of idlers to run. // Idle handles only run if the queue is empty or if the first message // in the queue (possibly a barrier) is due to be handled in the future. if (pendingIdleHandlerCount &lt; 0 &amp;&amp; (mMessages == null || now &lt; mMessages.when)) &#123; pendingIdleHandlerCount = mIdleHandlers.size(); &#125; if (pendingIdleHandlerCount &lt;= 0) &#123; // No idle handlers to run. Loop and wait some more. mBlocked = true; continue; &#125; if (mPendingIdleHandlers == null) &#123; mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)]; &#125; mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers); &#125; // Run the idle handlers. // We only ever reach this code block during the first iteration. for (int i = 0; i &lt; pendingIdleHandlerCount; i++) &#123; final IdleHandler idler = mPendingIdleHandlers[i]; mPendingIdleHandlers[i] = null; // release the reference to the handler boolean keep = false; try &#123; keep = idler.queueIdle(); &#125; catch (Throwable t) &#123; Log.wtf(TAG, "IdleHandler threw exception", t); &#125; if (!keep) &#123; synchronized (this) &#123; mIdleHandlers.remove(idler); &#125; &#125; &#125; // Reset the idle handler count to 0 so we do not run them again. pendingIdleHandlerCount = 0; // While calling an idle handler, a new message could have been delivered // so go back and look again for a pending message without waiting. nextPollTimeoutMillis = 0; &#125;&#125; 上面段代码就是在通过next没有获取到下一条Message时运行，整段代码整体就是一个观察者默认，其它对象可以注策IdleHandler到MessageQueue中，当MessageQueue中没有消息时则会调用IdleHandler的queueIdle方法。 什么时候MessageQueue为空？ 对于主线层来说，当页面渲染完成且没有新的交互时MessageQueue才会为空。 对于子线程，连续操作之后会有 目前Glide使用IdleHandler来进行弱引用缓存key的清理]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Handler解析]]></title>
    <url>%2F2018%2F08%2F16%2FHandler%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[Handler介绍Handler 是 Android 下异步线程通讯的主要机制，关于 Handler 的简单介绍如下图所示 在 Handler 机制中，主要的参与对象以及关系在上图中已经很清晰了，我这里在简单介绍一下： Handler 异步消息的发送者，也是消息的处理者，但是值得注意的是发送的处理可以在不同线程 MessageQueue 线程安全的消息队列，线程的变换主要是在 MessageQueue 中完成 Messager 异步通信内容的载体 Looper 通过循环不断的从 MessageQueue 中获取消息，然后分发给 Handler 处理，和MessageQueue 是一一对应的关系 简单的介绍到此为止，下面开始详细介绍整个消息发送过程。 Handler消息机制Handler创建针对 Handler 消息机制，我这边直接从 Handler 构造函数开始解析 public Handler(Callback callback, boolean async) &#123; //内存泄漏警告 ...... //获取Looper mLooper = Looper.myLooper(); if (mLooper == null) &#123; throw new RuntimeException( "Can't create handler inside thread that has not called Looper.prepare()"); &#125; mQueue = mLooper.mQueue; mCallback = callback; mAsynchronous = async;&#125;//Looper是通过ThreadLocal获取的线程私有的变量，但是默认为nullpublic static @Nullable Looper myLooper() &#123; return sThreadLocal.get();&#125;//创建Looper对象并设置给ThreadLocalprivate static void prepare(boolean quitAllowed) &#123; if (sThreadLocal.get() != null) &#123; throw new RuntimeException("Only one Looper may be created per thread"); &#125; sThreadLocal.set(new Looper(quitAllowed));&#125;//创建MessageQueue对象private Looper(boolean quitAllowed) &#123; mQueue = new MessageQueue(quitAllowed); mThread = Thread.currentThread();&#125; 上面这一段代码看似很多，其实就是告诉我们如果想要创建 Handler 就得先有一个 Looper , Looper 是跟线程绑定的，创建 Looper 的同时它也会把 MessageQueue 也一起创建好，我们平时在主线程中的用的时候不要 Looper ,是因为主线程以及帮我们干了。 public final class ActivityThread &#123; public static void main(String[] args) &#123; ..... Looper.prepareMainLooper(); ...... Looper.loop(); throw new RuntimeException("Main thread loop unexpectedly exited"); &#125;&#125; 到现在可以确定线程、Looper 、Handler 、MessageQueue 的关系如下 graph TB subgraph 线程 MessageQueue --&gt; Looper Looper --&gt; Handler1 Looper --&gt; Handler2 end 消息发送使用 Handler 发送消息可以有多种形式，Handler.sendMessage() 、Message.sendToTarget() 以及类似的一些方法都可以发送消息，但是不管是哪种方法最终都会调用Handler.enqueueMessage() 方法。 private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123; msg.target = this; if (mAsynchronous) &#123; //发送异步消息 msg.setAsynchronous(true); &#125; return queue.enqueueMessage(msg, uptimeMillis);&#125; 这个方法也没有做太多逻辑处理，直接调用了 MessageQueue 的 enqueueMessage 方法 boolean enqueueMessage(Message msg, long when) &#123; ...... synchronized (this) &#123; ...... msg.markInUse(); msg.when = when; Message p = mMessages; boolean needWake; if (p == null || when == 0 || when &lt; p.when) &#123; // New head, wake up the event queue if blocked. msg.next = p; mMessages = msg; needWake = mBlocked; &#125; else &#123; // Inserted within the middle of the queue. Usually we don't have to wake // up the event queue unless there is a barrier at the head of the queue // and the message is the earliest asynchronous message in the queue. needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; for (;;) &#123; prev = p; p = p.next; if (p == null || when &lt; p.when) &#123; break; &#125; if (needWake &amp;&amp; p.isAsynchronous()) &#123; needWake = false; &#125; &#125; msg.next = p; // invariant: p == prev.next prev.next = msg; &#125; // We can assume mPtr != 0 because mQuitting is false. if (needWake) &#123; nativeWake(mPtr); &#125; &#125; return true;&#125; 这一段事实上就是一个单链表插入，mMessages 为链表头，如果链表为空则直接把 msg 赋给表头，否则通过循环找到链表最后进行插入。MessageQueue 的消息在 Looper.loop() 来获取并处理的。 public static void loop() &#123; final Looper me = myLooper(); if (me == null) &#123; throw new RuntimeException("No Looper; Looper.prepare() wasn't called on this thread."); &#125; final MessageQueue queue = me.mQueue; // Make sure the identity of this thread is that of the local process, // and keep track of what that identity token actually is. Binder.clearCallingIdentity(); final long ident = Binder.clearCallingIdentity(); for (;;) &#123; Message msg = queue.next(); // might block if (msg == null) &#123; // No message indicates that the message queue is quitting. return; &#125; // This must be in a local variable, in case a UI event sets the logger final Printer logging = me.mLogging; if (logging != null) &#123; logging.println("&gt;&gt;&gt;&gt;&gt; Dispatching to " + msg.target + " " + msg.callback + ": " + msg.what); &#125; final long slowDispatchThresholdMs = me.mSlowDispatchThresholdMs; final long traceTag = me.mTraceTag; if (traceTag != 0 &amp;&amp; Trace.isTagEnabled(traceTag)) &#123; Trace.traceBegin(traceTag, msg.target.getTraceName(msg)); &#125; final long start = (slowDispatchThresholdMs == 0) ? 0 :SystemClock.uptimeMillis(); final long end; try &#123; msg.target.dispatchMessage(msg); end = (slowDispatchThresholdMs == 0) ? 0 : SystemClock.uptimeMillis(); &#125; finally &#123; if (traceTag != 0) &#123; Trace.traceEnd(traceTag); &#125; &#125; if (slowDispatchThresholdMs &gt; 0) &#123; final long time = end - start; if (time &gt; slowDispatchThresholdMs) &#123; Slog.w(TAG, "Dispatch took " + time + "ms on " + Thread.currentThread().getName() + ", h=" + msg.target + " cb=" + msg.callback + " msg=" + msg.what); &#125; &#125; if (logging != null) &#123; logging.println("&lt;&lt;&lt;&lt;&lt; Finished to " + msg.target + " " + msg.callback); &#125; // Make sure that during the course of dispatching the // identity of the thread wasn't corrupted. final long newIdent = Binder.clearCallingIdentity(); if (ident != newIdent) &#123; Log.wtf(TAG, "Thread identity changed from 0x" + Long.toHexString(ident) + " to 0x" + Long.toHexString(newIdent) + " while dispatching to " + msg.target.getClass().getName() + " " + msg.callback + " what=" + msg.what); &#125; msg.recycleUnchecked(); &#125;&#125; loop() 方法主要就是在一个无限循环中不断的通过 next 获取消息，然后使用 dispatchMessage 把消息交回给Handler处理。现在我们回头来看 next 方法是如何获取消息的。 Message next() &#123; ...... int pendingIdleHandlerCount = -1; // -1 only during first iteration int nextPollTimeoutMillis = 0; for (;;) &#123; if (nextPollTimeoutMillis != 0) &#123; Binder.flushPendingCommands(); &#125; nativePollOnce(ptr, nextPollTimeoutMillis); synchronized (this) &#123; // Try to retrieve the next message. Return if found. final long now = SystemClock.uptimeMillis(); Message prevMsg = null; Message msg = mMessages; if (msg != null &amp;&amp; msg.target == null) &#123; // Stalled by a barrier. Find the next asynchronous message in the queue. do &#123; prevMsg = msg; msg = msg.next; &#125; while (msg != null &amp;&amp; !msg.isAsynchronous()); &#125; if (msg != null) &#123; if (now &lt; msg.when) &#123; // Next message is not ready. Set a timeout to wake up when it is ready. nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE); &#125; else &#123; // Got a message. mBlocked = false; if (prevMsg != null) &#123; prevMsg.next = msg.next; &#125; else &#123; mMessages = msg.next; &#125; msg.next = null; if (DEBUG) Log.v(TAG, "Returning message: " + msg); msg.markInUse(); return msg; &#125; &#125; else &#123; // No more messages. nextPollTimeoutMillis = -1; &#125; &#125;&#125; next 方法的主要逻辑都在一个无限循环内，知道获取到消息才会返回，同时把消息从链表中移除。同时默认获取的是链表头，只有当 msg.target == null 时才会获取链表后第一个同步消息，但是要知道我们通过 Handler 发送的消息 target 都是 Handler 本身，事实上这是消息屏障机制 同步屏障事实上消息分为同步和异步两种，通过 isAsynchronous 来判断，我们平时使用的一般是异步消息 ,同步消息主要用于页面绘制等对时间敏感的地方，但是在通常情况下即使我们使用 setAsynchronous(true) 来手动设置一个同步消息它也不会生效，MessageQueue 还是会把他当作普通消息处理，只有配合 postSyncBarrier 添加一个同步屏障之后才能使用。 public int postSyncBarrier() &#123; return postSyncBarrier(SystemClock.uptimeMillis());&#125;private int postSyncBarrier(long when) &#123; // Enqueue a new sync barrier token. // We don't need to wake the queue because the purpose of a barrier is to stall it. synchronized (this) &#123; final int token = mNextBarrierToken++; final Message msg = Message.obtain(); msg.markInUse(); msg.when = when; msg.arg1 = token; Message prev = null; Message p = mMessages; if (when != 0) &#123; while (p != null &amp;&amp; p.when &lt;= when) &#123; prev = p; p = p.next; &#125; &#125; if (prev != null) &#123; // invariant: p == prev.next msg.next = p; prev.next = msg; &#125; else &#123; msg.next = p; mMessages = msg; &#125; return token; &#125;&#125; postSyncBarrier 是一个隐藏 Api，我们无法调用，但这不妨碍我们分析它，它直接向 MessageQueue 的单链表中头插入了一个 target==null 的消息，也就是上一节 next 方法中的逻辑，当这种情况下，MessageQueue 会忽略所有的异步消息，只获取同步消息，需要调用 removeSyncBarrier(int token) 才能取消这个同步屏障，目前同步屏障主要是在 ViewRootImpl 绘制时使用。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Handler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RecyclerView源码详解]]></title>
    <url>%2F2018%2F07%2F30%2FRecyclerView%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[[TOC] 免责声明： 这篇文章还没有写完，发布的原因是因为我懒的放到草稿箱了，如有错误或者以后请勿怪 RecyclerView介绍RecyclerView 是Google support-v7包中的控件，用于提供一个列表的显示，和 ListView 类似，但是比 ListView 更高级也更具扩展性，它更倾向于使用一个模块化的方式来使用多个模块共同实现一个复杂的列表控件，RecyclerView主要由如下几个组件构成 LayoutManager 用于控制List子View的测量和布局 Adapter 和 ListView 中的Adapter功能类似，但是已经预先添加了 ViewHolder ,不需要我们手动添加 ItemDecoration 用于控制和显示分割线 ItemAnimator 用于实现Item显示消失时动画效果 当然除了上面所说的这些模块之外，RecyclerView 还把很多其他的功能也都拆分了出来，这里就不一一列举，文中遇到了在做说明。 LayoutManagerLayoutManager 相当于把本身View应该完成的测量和布局过程抽离出来单独处理，而这两个步骤也是决定一个View显示效果的重要步骤，因此同一个 RecyclerView 完全可以通过不同的 LayoutManager 实现不同的显示效果，而不是使用不同的控件。 目前Google已经预先提供好了几种 LayoutManager ,分别如下所示 LinearLayoutManager 实现类似 ListView 列表样式的布局 GridLayoutManager 实现类似 GridView 网格样式的布局 StaggeredGridLayoutManager 实现了瀑布流样式的布局 我们以 LinearLayoutManager 为例来说明 LayoutManager 在 RecyclerView 中的重要作用，首先先说明一下 LinearLayoutManager 中的两个辅助类，这两个类在 LinearLayoutManager 的工作中也起着一定作用 AnchorInfo 布局的锚点，在测量和布局过程中 LinearLayoutManager 都是先确定一个锚点位置，然后根据锚点，分别向上和向下去测量和布局子 View LayoutState 是 LinearLayoutManager 在填充整体布局的帮助类，他可以通过一个给定的方向获取下一个需要填充的 View onMeasure我们都知道控件的展示主要分为测量、布局、绘制等三个阶段进行，我们首先关注 RecyclerView 的测量过程。代码片段会省略部分代码和注释 @Overrideprotected void onMeasure(int widthSpec, int heightSpec) &#123; if (mLayout == null) &#123; defaultOnMeasure(widthSpec, heightSpec); return; &#125; //isAutoMeasureEnabled方法返回false，表示必须要重写LayoutManager的onMeasure方法，完成测量 //如果设置为true，则表示由RecyclerView的AutoMeasure机制完成测量 //LinearLayoutManager已经重写了这个方法，永久返回true if (mLayout.isAutoMeasureEnabled()) &#123; final int widthMode = MeasureSpec.getMode(widthSpec); final int heightMode = MeasureSpec.getMode(heightSpec); //这里看似调用了LayoutManager的onMeasure，但是LinearLayoutManager没有重写这个方法， //因此这个最终是调用了RecyclerView自己默认的方法 mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec); //RecyclerView固定宽高或者Match_Parent的情况下measureSpecModeIsExactly为true final boolean measureSpecModeIsExactly = widthMode == MeasureSpec.EXACTLY &amp;&amp; heightMode == MeasureSpec.EXACTLY; //即如果RecyclerView的宽高不是Wrap_Content，到这里测量过程就结束了 if (measureSpecModeIsExactly || mAdapter == null) &#123; return; &#125; //mState是RecyclerView的State对象，这个对象存储了当前RecyclerView的各种状态 //在RecyclerView中各个组件的交互也是通过State对象来进行的 //mState初始mLayoutStep为STEP_START if (mState.mLayoutStep == State.STEP_START) &#123; //dispatchLayoutStep1主要对RecyclerView的动画做了处理，没有绘制流程 //后续在动画中在做说明 dispatchLayoutStep1(); &#125; // 这里widthSpec和heightSpec是RecyclerView默认测量的结果 mLayout.setMeasureSpecs(widthSpec, heightSpec); mState.mIsMeasuring = true; //实际的测量，会测量childView dispatchLayoutStep2(); // now we can get the width and height from the children. mLayout.setMeasuredDimensionFromChildren(widthSpec, heightSpec); // if RecyclerView has non-exact width and height and if there is at least one child // which also has non-exact width &amp; height, we have to re-measure. if (mLayout.shouldMeasureTwice()) &#123; mLayout.setMeasureSpecs( MeasureSpec.makeMeasureSpec(getMeasuredWidth(), MeasureSpec.EXACTLY), MeasureSpec.makeMeasureSpec(getMeasuredHeight(), MeasureSpec.EXACTLY)); mState.mIsMeasuring = true; dispatchLayoutStep2(); // now we can get the width and height from the children. mLayout.setMeasuredDimensionFromChildren(widthSpec, heightSpec); &#125; &#125; else &#123; ...... &#125;&#125; 可以看到在 onMeasure 方法中，如果我们给 RecyclerView 设置了不是 Wrap_Content 的宽高，那么 RecyclerView 的测量过程很简单，直接使用父控件给定的宽高即可，只有当我们设置为 Wrap_Content 时，才需要先去测量子 View 。 测量子 View 的过程事实上是在 dispatchLayoutStep2 方法中进行的，这个方法事实上是 Layout 时调用的方法，这个不难理解，因为只有在确定了 Layout 的方式时，才能真正确定子 View 需要多少的屏幕空间 private void dispatchLayoutStep2() &#123; startInterceptRequestLayout(); onEnterLayoutOrScroll(); mState.assertLayoutStep(State.STEP_LAYOUT | State.STEP_ANIMATIONS); mAdapterHelper.consumeUpdatesInOnePass(); mState.mItemCount = mAdapter.getItemCount(); mState.mDeletedInvisibleItemCountSincePreviousLayout = 0; // Step 2: Run layout mState.mInPreLayout = false; //上述代码基本上就是在往mState中填充RecyclerView的信息，上段代码的注释中也提到State的 //主要功能就是在RecyclerView各组件间传递信息 mLayout.onLayoutChildren(mRecycler, mState); ......&#125; dispatchLayoutStep2 主要的功能就是为 mState 的更新了一些 RecyclerView 的最新状态，然后调用了 LayoutManager 的 onLayoutChildren 方法，值得注意的是这个方法和上个方法一样是用于布局的，所以后面还会调用，这里暂时只说明测量的部分。 public void onLayoutChildren(RecyclerView.Recycler recycler, RecyclerView.State state) &#123; //计算锚点信息以及获取边缘的extraSpace，锚点初始化时一般是方向上的第一个View（反转的列表则为最后） //细节代码有兴趣可以自行研究 ...... if (mAnchorInfo.mLayoutFromEnd) &#123; // fill towards start //通过锚点更新LayoutState信息,更新后LayoutState.next会向上寻找View updateLayoutStateToFillStart(mAnchorInfo); mLayoutState.mExtra = extraForStart; fill(recycler, mLayoutState, state, false); startOffset = mLayoutState.mOffset; final int firstElement = mLayoutState.mCurrentPosition; if (mLayoutState.mAvailable &gt; 0) &#123; extraForEnd += mLayoutState.mAvailable; &#125; // fill towards end //通过锚点更新LayoutState信息,更新后LayoutState.next会向下寻找View updateLayoutStateToFillEnd(mAnchorInfo); mLayoutState.mExtra = extraForEnd; mLayoutState.mCurrentPosition += mLayoutState.mItemDirection; fill(recycler, mLayoutState, state, false); endOffset = mLayoutState.mOffset; if (mLayoutState.mAvailable &gt; 0) &#123; // end could not consume all. add more items towards start extraForStart = mLayoutState.mAvailable; updateLayoutStateToFillStart(firstElement, startOffset); mLayoutState.mExtra = extraForStart; fill(recycler, mLayoutState, state, false); startOffset = mLayoutState.mOffset; &#125; &#125; else &#123; //这段代码几乎和上段一样，只是填充的方向不同 ...... &#125; ......&#125; 上面的代码中可以看出在 onLayoutChildren 过程中，LinearLayoutManager 是首先确定一个锚点，然后从锚点位置开始向不同方向填充布局。真正的填充部分代码在 fill 方法中 int fill(RecyclerView.Recycler recycler, LayoutState layoutState, RecyclerView.State state, boolean stopOnFocusable) &#123; // bug修复代码 ...... //mAvailable是上面的方法中由锚点更新给layoutState的，为指定指定方向上需要填充的距离 //mExtra也是前面计算的边缘的extraSpace， int remainingSpace = layoutState.mAvailable + layoutState.mExtra; LayoutChunkResult layoutChunkResult = mLayoutChunkResult; //由于最开始onMeasure的时候先调用了RecyclerView默认的onMeasure方法，所以这里remainingSpace //就是能Recycler能取到的最大值 while ((layoutState.mInfinite || remainingSpace &gt; 0) &amp;&amp; layoutState.hasMore(state)) &#123; ...... //核心代码，用于计算子View需要的空间 layoutChunk(recycler, state, layoutState, layoutChunkResult); ...... //根据layoutChunkResult缩减remainingSpace大小 &#125; ...... return start - layoutState.mAvailable;&#125; 可以看到在 fill 方法中起着比较核心作用的是 layoutChunk 方法 void layoutChunk(RecyclerView.Recycler recycler, RecyclerView.State state, LayoutState layoutState, LayoutChunkResult result) &#123; View view = layoutState.next(recycler); ...... //测量ChildView measureChildWithMargins(view, 0, 0); result.mConsumed = mOrientationHelper.getDecoratedMeasurement(view); int left, top, right, bottom; ...... //布局ChildView layoutDecoratedWithMargins(view, left, top, right, bottom); ......&#125; 上面的代码其实很清楚了，layoutChunk 方法首先获取的 ChildView ，对它进行测量，然后布局。恩，你没有看错就是布局 Layout ，通过布局方法确定 ChildView 的具体位置，dispatchLayoutStep2方法的深入展开到此结束，让我们回到 onMeasure 的地方在看一下我们没有看完的代码 @Overrideprotected void onMeasure(int widthSpec, int heightSpec) &#123; ...... if (mLayout.isAutoMeasureEnabled()) &#123; ...... //上次的代码到这了 dispatchLayoutStep2(); // 通过ChildView的位置综合父控件给的widthSpec和heightSpec选择合适的宽高 mLayout.setMeasuredDimensionFromChildren(widthSpec, heightSpec); //重新进行测量，对于LinearLayoutManager来说中如果本身是WARP_CONTENT， //同时至少有一个ChildView有不确定（WRAP_CONTENT或者MATCH_PARENT）的宽和高 if (mLayout.shouldMeasureTwice()) &#123; //重新走一遍上面的测量 ...... &#125; &#125; else &#123; ...... &#125;&#125;void setMeasuredDimensionFromChildren(int widthSpec, int heightSpec) &#123; ...... //遍历ChildView，选出坐上右下四个值 for (int i = 0; i &lt; count; i++) &#123; View child = getChildAt(i); final Rect bounds = mRecyclerView.mTempRect; getDecoratedBoundsWithMargins(child, bounds); if (bounds.left &lt; minX) &#123; minX = bounds.left; &#125; if (bounds.right &gt; maxX) &#123; maxX = bounds.right; &#125; if (bounds.top &lt; minY) &#123; minY = bounds.top; &#125; if (bounds.bottom &gt; maxY) &#123; maxY = bounds.bottom; &#125; &#125; mRecyclerView.mTempRect.set(minX, minY, maxX, maxY); //根据获得的Rect范围综合父控件给的值综合获取最终的宽高 setMeasuredDimension(mRecyclerView.mTempRect, widthSpec, heightSpec);&#125; 好了到此为止，整个测量过程基本上清楚了，下面我们根据一张时序图回顾一下整个流程 participant RecyclerView as Aparticipant LinearLayoutManager as BA-&gt;A:onMeasureA-&gt;B:isAutoMeasureEnabledA-&gt;A:dispatchLayoutStep2A-&gt;B:onLayoutChildrenB-&gt;B:fillB-&gt;B:layoutChunkB-&gt;B:measureChildWithMarginsB-&gt;B:layoutDecoratedWithMarginsA-&gt;B:setMeasuredDimensionFromChildrenA-&gt;B:shouldMeasureTwiceB-&gt;B:calculate measurezise......B-&gt;A:setMeasuredDimension 可以看出 RecyclerView 在整个测量过程还是整个流程的主导，LayoutManager 更多像是一个提供具体配置参数的。这个表可以作为我们自定义 LayoutManager 时的一个参考。 onLayout继续看布局的相关方法，首先从 RecyclerView 的 onLayout 方法开始 protected void onLayout(boolean changed, int l, int t, int r, int b) &#123; TraceCompat.beginSection(TRACE_ON_LAYOUT_TAG); //直接调用了dispatchLayout dispatchLayout(); TraceCompat.endSection(); mFirstLayoutComplete = true;&#125;void dispatchLayout() &#123; if (mAdapter == null) &#123; return; &#125; if (mLayout == null) &#123; return; &#125; mState.mIsMeasuring = false; //mLayoutStep初始为STEP_START，然后会在dispatchLayoutStep1方法修改为STEP_LAYOUT //然后在dispatchLayoutStep2方法中修改为STEP_ANIMATIONS //除非若RecyclerView宽高为Wrap_Content，否则此处为STEP_START if (mState.mLayoutStep == State.STEP_START) &#123; //完成一次完整的测量布局 dispatchLayoutStep1(); mLayout.setExactMeasureSpecsFrom(this); dispatchLayoutStep2(); &#125; else if (mAdapterHelper.hasUpdates() || mLayout.getWidth() != getWidth() || mLayout.getHeight() != getHeight()) &#123; //测量布局已经但是，种种原因，大小改变了，需要重新测量布局 //这个方法把RecyclerView的测量宽高以一EXACTLY的形式给了LayoutManager mLayout.setExactMeasureSpecsFrom(this); dispatchLayoutStep2(); &#125; else &#123; // always make sure we sync them (to ensure mode is exact) mLayout.setExactMeasureSpecsFrom(this); &#125; dispatchLayoutStep3();&#125; 在 onLayout 中 RecyclerView 并没有做什么多余的操作，而是直接调用了 dispatchLayout 方法，这个方法会根据我们在 onMeasure 中的行为判断是否需要调用 dispatchLayoutStep1 和 dispatchLayoutStep2 ，但是无论哪种情况都会通过 setExactMeasureSpecsFrom 给 LayoutManager 设置一个确切的宽高，最后调用 dispatchLayoutStep3 方法。 private void dispatchLayoutStep3() &#123; //STEP_ANIMATIONS状态就可以看出来，这个方法主要是完成前面dispatchLayoutStep1中 //设置好的动画 mState.assertLayoutStep(State.STEP_ANIMATIONS); startInterceptRequestLayout(); onEnterLayoutOrScroll(); mState.mLayoutStep = State.STEP_START; if (mState.mRunSimpleAnimations) &#123; //这个整段代码全都是动画相关的 ...... &#125; // 一些状态的置位和资源的释放 ...... if (mLayout.mPrefetchMaxObservedInInitialPrefetch) &#123; // Initial prefetch has expanded cache, so reset until next prefetch. // This prevents initial prefetches from expanding the cache permanently. mLayout.mPrefetchMaxCountObserved = 0; mLayout.mPrefetchMaxObservedInInitialPrefetch = false; mRecycler.updateViewCacheSize(); &#125; //这里也是一样，部分状态的初始化 mLayout.onLayoutCompleted(mState); onExitLayoutOrScroll(); stopInterceptRequestLayout(false); mViewInfoStore.clear(); if (didChildRangeChange(mMinMaxLayoutPositions[0], mMinMaxLayoutPositions[1])) &#123; dispatchOnScrolled(0, 0); &#125; recoverFocusFromState(); resetFocusInfo();&#125; ￼ 这就结束了？，没错到此为止 LinearLayoutManager 或者说 RecyclerView 的 auto measure 就是这样的，当然 LayoutManager 还有一些其他功能这里还没有涉及到或者没有展开，后面遇到再进行说明。 Recycler按照顺序这里应该是本应该是 Adapter ，但是我发现如果没有 Recycler 存在 Adapter 根本玩不下去，看名字 Recycler 就感觉像是 RecyclerView 的核心，确实它也掌管了所有 ChildView 的生成、复用、回收，确实也是核心，首先我们介绍一下 Recycler 中的几个缓存队列 mChangedScrap item被标记为更新、有动画且动画支持变化 mAttachedScrap mCachedViews Recycler 也还是得从测量过程中的 LayoutChunk 说起，虽然这个 Recycler 对象在一开始 onLayoutChildren 就作为参数传递到了 LayoutManager ，但是一直没有正经的使用它。 void layoutChunk(RecyclerView.Recycler recycler, RecyclerView.State state, LayoutState layoutState, LayoutChunkResult result) &#123; //从LayoutState中获取下一个View View view = layoutState.next(recycler); if (view == null) &#123; //说明已经没有更多的View，到底或者到顶了 result.mFinished = true; return; &#125; LayoutParams params = (LayoutParams) view.getLayoutParams(); //mScrapList一般情况下都为null，只有在为动画做准备时才会有内存 if (layoutState.mScrapList == null) &#123; if (mShouldReverseLayout == (layoutState.mLayoutDirection == LayoutState.LAYOUT_START)) &#123; addView(view); &#125; else &#123; addView(view, 0); &#125; &#125; else &#123; //暂时可以不考虑 ...... &#125; measureChildWithMargins(view, 0, 0); ......&#125;View next(RecyclerView.Recycler recycler) &#123; //mScrapList一般情况下都为null，这里暂不考虑 if (mScrapList != null) &#123; return nextViewFromScrapList(); &#125; //调用了getViewForPosition来获取真正View final View view = recycler.getViewForPosition(mCurrentPosition); mCurrentPosition += mItemDirection; return view;&#125;public View getViewForPosition(int position) &#123; return getViewForPosition(position, false);&#125;View getViewForPosition(int position, boolean dryRun) &#123; return tryGetViewHolderForPositionByDeadline(position, dryRun, FOREVER_NS).itemView;&#125; layoutChunk 根本意义上说也还没有使用 Recycler 对象，但是这里算上获取 childView 的一个起点，所以我们从这里开始分析，后续的几个方法也都没有做太多工作。到了 tryGetViewHolderForPositionByDeadline 真正的逻辑开始了。代码之前我们先整理一下逻辑，这个方法的的主要工作如下 如果进行了 PreLayout 则会优先从 mChangedScrap 中查找 ViewHolder , PreLayout 这个行为发生在 dispatchLayoutStep1 中，虽然是 PreLayout 但是终究还是会去 onLayoutChildren ，然后最后还是会调用 tryGetViewHolderForPositionByDeadline ，所以本质上来说第一次来步骤1肯定会跳过 ViewHolder tryGetViewHolderForPositionByDeadline(int position, boolean dryRun, long deadlineNs) &#123; if (position &lt; 0 || position &gt;= mState.getItemCount()) &#123; throw new IndexOutOfBoundsException(...); &#125; boolean fromScrapOrHiddenOrCache = false; ViewHolder holder = null; // 0) If there is a changed scrap, try to find from there if (mState.isPreLayout()) &#123; holder = getChangedScrapViewForPosition(position); fromScrapOrHiddenOrCache = holder != null; &#125; // 1) Find by position from scrap/hidden list/cache if (holder == null) &#123; holder = getScrapOrHiddenOrCachedHolderForPosition(position, dryRun); if (holder != null) &#123; if (!validateViewHolderForOffsetPosition(holder)) &#123; // recycle holder (and unscrap if relevant) since it can't be used if (!dryRun) &#123; // we would like to recycle this but need to make sure it is not used by // animation logic etc. holder.addFlags(ViewHolder.FLAG_INVALID); if (holder.isScrap()) &#123; removeDetachedView(holder.itemView, false); holder.unScrap(); &#125; else if (holder.wasReturnedFromScrap()) &#123; holder.clearReturnedFromScrapFlag(); &#125; recycleViewHolderInternal(holder); &#125; holder = null; &#125; else &#123; fromScrapOrHiddenOrCache = true; &#125; &#125; &#125; if (holder == null) &#123; final int offsetPosition = mAdapterHelper.findPositionOffset(position); if (offsetPosition &lt; 0 || offsetPosition &gt;= mAdapter.getItemCount()) &#123; throw new IndexOutOfBoundsException(...); &#125; final int type = mAdapter.getItemViewType(offsetPosition); // 2) Find from scrap/cache via stable ids, if exists if (mAdapter.hasStableIds()) &#123; holder = getScrapOrCachedViewForId(mAdapter.getItemId(offsetPosition), type, dryRun); if (holder != null) &#123; // update position holder.mPosition = offsetPosition; fromScrapOrHiddenOrCache = true; &#125; &#125; if (holder == null &amp;&amp; mViewCacheExtension != null) &#123; // We are NOT sending the offsetPosition because LayoutManager does not // know it. final View view = mViewCacheExtension .getViewForPositionAndType(this, position, type); if (view != null) &#123; holder = getChildViewHolder(view); if (holder == null) &#123; throw new IllegalArgumentException(...); &#125; else if (holder.shouldIgnore()) &#123; throw new IllegalArgumentException(...); &#125; &#125; &#125; if (holder == null) &#123; // fallback to pool holder = getRecycledViewPool().getRecycledView(type); if (holder != null) &#123; holder.resetInternal(); if (FORCE_INVALIDATE_DISPLAY_LIST) &#123; invalidateDisplayListInt(holder); &#125; &#125; &#125; if (holder == null) &#123; long start = getNanoTime(); if (deadlineNs != FOREVER_NS &amp;&amp; !mRecyclerPool.willCreateInTime(type, start, deadlineNs)) &#123; // abort - we have a deadline we can't meet return null; &#125; holder = mAdapter.createViewHolder(RecyclerView.this, type); if (ALLOW_THREAD_GAP_WORK) &#123; // only bother finding nested RV if prefetching RecyclerView innerView = findNestedRecyclerView(holder.itemView); if (innerView != null) &#123; holder.mNestedRecyclerView = new WeakReference&lt;&gt;(innerView); &#125; &#125; long end = getNanoTime(); mRecyclerPool.factorInCreateTime(type, end - start); &#125; &#125; // This is very ugly but the only place we can grab this information // before the View is rebound and returned to the LayoutManager for post layout ops. // We don't need this in pre-layout since the VH is not updated by the LM. if (fromScrapOrHiddenOrCache &amp;&amp; !mState.isPreLayout() &amp;&amp; holder .hasAnyOfTheFlags(ViewHolder.FLAG_BOUNCED_FROM_HIDDEN_LIST)) &#123; holder.setFlags(0, ViewHolder.FLAG_BOUNCED_FROM_HIDDEN_LIST); if (mState.mRunSimpleAnimations) &#123; int changeFlags = ItemAnimator .buildAdapterChangeFlagsForAnimations(holder); changeFlags |= ItemAnimator.FLAG_APPEARED_IN_PRE_LAYOUT; final ItemHolderInfo info = mItemAnimator.recordPreLayoutInformation(mState, holder, changeFlags, holder.getUnmodifiedPayloads()); recordAnimationInfoIfBouncedHiddenView(holder, info); &#125; &#125; boolean bound = false; if (mState.isPreLayout() &amp;&amp; holder.isBound()) &#123; // do not update unless we absolutely have to. holder.mPreLayoutPosition = position; &#125; else if (!holder.isBound() || holder.needsUpdate() || holder.isInvalid()) &#123; if (DEBUG &amp;&amp; holder.isRemoved()) &#123; throw new IllegalStateException(...); &#125; final int offsetPosition = mAdapterHelper.findPositionOffset(position); bound = tryBindViewHolderByDeadline(holder, offsetPosition, position, deadlineNs); &#125; final ViewGroup.LayoutParams lp = holder.itemView.getLayoutParams(); final LayoutParams rvLayoutParams; if (lp == null) &#123; rvLayoutParams = (LayoutParams) generateDefaultLayoutParams(); holder.itemView.setLayoutParams(rvLayoutParams); &#125; else if (!checkLayoutParams(lp)) &#123; rvLayoutParams = (LayoutParams) generateLayoutParams(lp); holder.itemView.setLayoutParams(rvLayoutParams); &#125; else &#123; rvLayoutParams = (LayoutParams) lp; &#125; rvLayoutParams.mViewHolder = holder; rvLayoutParams.mPendingInvalidate = fromScrapOrHiddenOrCache &amp;&amp; bound; return holder;&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ThreadLocal详解]]></title>
    <url>%2F2018%2F07%2F19%2FThreadLocal%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[ThreadLocal是什么ThreadLocal是java中处理并发问题的一种方式，但是和Synchronized、volatile等进程同步关键字不同，ThreadLocal主要用于进程隔离，即每一个线程都有一个自己的ThreadLocal，访问时访问的都是线程持有的对象，无法访问其他线程的ThreadLocal,也就不存在并发的问题。 ThreadLocal使用ThreadLocal使用起来类似一个数据封装类，使用set和get方法设置和获取存储的内容 //创建ThreadLocal对象，使用泛型制定类型ThreadLocal&lt;Integer&gt; localInt = new ThreadLocal&lt;&gt;();//写入内容localInt.set(10);//获取内容assert locaInt.get()==10; ThreadLocal特殊的地方就在于不同线程间是无法获取到其它线程的相应对象的，在多线程场景中对ThreadLocal的使用实例如下 ThreadLocal&lt;Integer&gt; localInt = new ThreadLocal&lt;&gt;();Thread threadA = new Thread() &#123; @Override public void run() &#123; for(int i=100;i&lt;200;i++)&#123; try &#123; localInt.set(i); sleep(10); assert localInt.get()==i; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; super.run(); &#125;&#125;;Thread threadB = new Thread() &#123; @Override public void run() &#123; for(int i=0;i&lt;100;i++)&#123; try &#123; localInt.set(i); sleep(10); assert localInt.get()==i; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; super.run(); &#125;&#125;;threadA.start();threadB.start(); ThreadA和ThreadB中ThreadLocal是不会相互影响的，他们每次从ThreadLocal中获取的都是线程内部的相应数据。 在上面的例子中我们只是用ThreadLocal存储了一个变量，如果想要同时拥有多个线程私有的变量就只能创建多个TreadLocal对象。 ThreadLocal实现原理ThreadLocal看上去很神奇，原理其实并不难，它只是把我们的变量关联到了线程的Thread对象上，我们借助ThreadLocal的set方法来说明这点。 public void set(T value) &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value);&#125;ThreadLocalMap getMap(Thread t) &#123; return t.threadLocals;&#125; 在我们通过set方法设置ThreadLocal的内容是，它首先获取当前的Thread对象，同时获取Thread上的ThreadLocalMap，ThreadLocalMap事实上是hash表的一种实现，set事实上是把ThreadLocal对象和相应的value分别作为key和value保证在了这个map中，也就是说我们的value保存在Thread对象内。 get方法也是类似的，我们使用get方法获取值的时候，首先是获取currentThread，然后通过Thread的ThreadLocalMap用ThreadLocal作为key获取对应的value。 public T get() &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) &#123; @SuppressWarnings("unchecked") T result = (T)e.value; return result; &#125; &#125; return setInitialValue();&#125; 如果没有创建过ThreadLocalMap，setInitialValue会创建ThreadLocalMap同时返回null。 ThreadLocal内存泄漏正常来说ThreadLocal的对象和其保存的value持有在一个普通的对象内，而在保存时他们会作为key和value保存在Thread对象的map内，线程一般拥有比普通对象更长的生命周期，特别是对于线程池中的线程。 这种情况下作为key的ThreadLocal和value就有泄漏的风险，ThreadLocal的设计上自然也考虑到了这点，因此ThreadLocalMap中Key都是作为弱引用存在的 static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123; /** The value associated with this ThreadLocal. */ Object value; Entry(ThreadLocal&lt;?&gt; k, Object v) &#123; super(k); value = v; &#125;&#125; 这样当持有ThreadLocal的对象销毁后，没有强引用的ThreadLocal也会很快被回收，但是与之对应的value却没法被自动回收。 事实上ThreadLocalMap对于这样的情况也是有所处理，即ThreadLocalMap在每次set或者get时发现有key为空的元素，都会把它清理掉 private void set(ThreadLocal&lt;?&gt; key, Object value) &#123; ...... for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) &#123; ThreadLocal&lt;?&gt; k = e.get(); if (k == key) &#123; e.value = value; return; &#125; //清理掉key==null的元素 if (k == null) &#123; replaceStaleEntry(key, value, i); return; &#125; &#125; ......&#125; 但是即使这样光靠ThreadLocalMap也没有办法完全避免value的内存泄漏，最好的就是每次使用完ThreadLocal后都调用它的remove方法，清除数据。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android线程池]]></title>
    <url>%2F2018%2F07%2F16%2FAndroid%E7%BA%BF%E7%A8%8B%E6%B1%A0%2F</url>
    <content type="text"><![CDATA[为什么使用线程池线程是操作系统能进行运算调度的最小单元，在Java 中直接使用线程，给我们带来了很多便利，但是线程的使用同时也存在一些问题 线程生命周期的开销非常高，即在线程的创建和销毁过程都会消耗较大的cpu资源 资源消耗，线程的存在期间会消耗系统资源，尤其是内存（短时间内高并发任务尤其需要注意） 线程池线程池就是一种线程复用的手段，它通过缓存已有线程，来减小线程创建过程的消耗，它通过控制线程数量来控制线程存在的系统消耗，同时他把任务和任务的执行进行了解耦，把任务本身和任务的执行过程分离。这一点从Executor就可以看出 public interface Executor { void execute(Runnable command); } 任务封装成Runnable，通过execute在内部通过缓存的线程对任务进行处理，对于Runnable这个任务而言，具体的执行策略它毫不知晓，同时我们可以有极大的空间来制定执行策略。 构造线程池线程池给我们创造了极大扩展空间用于管理线程资源和定义任务的执行策略，同时为了更加方便我们使用，Java定义了一些配置成型的线程池供我们使用，这些线程池可以通过Executors这样一个工厂类获取 newFixedThreadPool。newFixedThreadPool会创建一个固定长度的线程池，每当提交一个任务时，就会创建一个线程（即使有空闲的线程），直到达到线程最大值。 newCachedThreadPool。newCachedThreadPool会创建一个可缓存的线程池，任务提交时没有空闲的线程就会创建新的线程，且这个过程没有上线，当线程执行完成后60s内没有被其他任务复用就会被销毁。 newSingleThreadExecutor。newSingleThreadExecutor是一个单线程的Executor，一般按照FIFO的顺序执行（不同于我们自己创建的单线程Thread，如果Thread不慎挂掉，会创建一个新的线程保证运行过程） newSingleThreadExecutor。创建一个固定长度线程池，会使用延迟或者定时的方式来执行任务。 上面列举了几个Java中提供好的线程策略，类似的在Executors中还有很多，这里不一一列举，本质上来说，这些方法是对现有的几个线程池实现类的一种配置方式，具体线程池的复用以及调度的方式是怎么样的呢？ 线程池调度策略调度内容线程池是对线程的一个管理，它到底管理什么东西 使用什么线程执行任务 任务执行顺序 有多少任务可以同时处理 能够有多少任务等待，如果需要执行的任务超过这个上限如何处理 任务运行时出现异常怎么处理 任务前后有哪些动作 ThreadPoolExecutor我们使用的绝大部分线程池最终的实现类都是ThreadPoolExecutor，我们可以通过这个对象来真正了解线程池，首先是ThreadPoolExecutor的构造方法 public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) 从构造方法可以看出很多内容，ThreadPoolExecutor中的线程分为普通线程和核心线程，有线程存活时间，任务等待队列，线程工厂，任务拒绝的handler。 核心线程数和最大线程数关于核心线程和最大线程可以看一下execute方法的一段代码 //线程数小于核心线程直接添加新线程执行 int c = ctl.get(); if (workerCountOf(c) &lt; corePoolSize) { if (addWorker(command, true)) return; c = ctl.get(); } //将任务放入等待队列，同时检测线程池运行状态并处理 if (isRunning(c) &amp;&amp; workQueue.offer(command)) { int recheck = ctl.get(); //线程池状态改变（不是运行状态）直接打回任务 if (! isRunning(recheck) &amp;&amp; remove(command)) reject(command); else if (workerCountOf(recheck) == 0) addWorker(null, false); //等待队列满了，试图添加新线程，如果失败打回任务 //（当线程数以达到最大线程数则会失败） }else if (!addWorker(command, false)) reject(command); ctl是一个AtomicInteger类型，它用前3位标示线程池运行状态，后面位数表示已有的线程数量，当线程池新增一个任务时，会有四种情况 当前线程数小于核心线程数，直接新建线程执行任务 大于核心线程数，等待队列未满，直接进入队列 等待队列已满，且小于最大线程数，直接新建线程执行任务 都不满足，打回任务 可以看出即使等待队列时FIFO，任务也不一定会完成按照我们添加的顺序执行，当等待队列满的时候，一部分任务会优先执行。 线程复用与回收线程池最大的特点就是线程的复用，同时还有上一节中的非核心线程的回收，本质上来说核心线程和非核心线程没有去吧，他们都存储在一个集合中 private final HashSet&lt;Worker&gt; workers = new HashSet&lt;&gt;(); 线程池中的线程都使用Worker进行封装，线程复用的过程也是借助Workder来进行的，Worker的主要代码如下 private final class Worker extends AbstractQueuedSynchronizer implements Runnable{ ...... final Thread thread; Runnable firstTask; ...... Worker(Runnable firstTask) { setState(-1); // inhibit interrupts until runWorker this.firstTask = firstTask; this.thread = getThreadFactory().newThread(this); } /** Delegates main run loop to outer runWorker. */ public void run() { runWorker(this); } ...... } 我们可以看到Worker本身就是Runnable，他在创建内部线程的同时只是把自己作为参数传递进去，最终thread.start运行时执行的就是Worker的run方法，同时这里会调用ThreadPoolExecutor的runWorker方法以完成最终的线程调度。 final void runWorker(Worker w) { Thread wt = Thread.currentThread(); Runnable task = w.firstTask; ...... try { //getTask从等待队列中获取下一个task while (task != null || (task = getTask()) != null) { ...... try { beforeExecute(wt, task); Throwable thrown = null; try { task.run(); } catch (RuntimeException x) { thrown = x; throw x; } catch (Error x) { thrown = x; throw x; } catch (Throwable x) { thrown = x; throw new Error(x); } finally { afterExecute(task, thrown); } } finally { task = null; w.completedTasks++; w.unlock(); } } completedAbruptly = false; } finally { processWorkerExit(w, completedAbruptly); } } 可以看到在runWorker方法里，Worker内的task为空，会从等待队列中获取一个新的task并执行，同时会调用beforeExecute和afterExecute这两个生命周期方法，同时当任务队列没有清空或者没有异常发生时，这是一个死循环，如果跳出循环，则说明要么任务队列被清空，要么线程异常结束，processWorkerExit会处理这些情况，如果是异常结束会起一个新的线程，否则则会移除大于核心线程数的线程，到此线程的复用过程基本清楚了 我们可以看到ThreadPoolExecutor还有一个keepAliveTime的参数用于空闲时回收非核心线程的时机，这个过程事实上是在getTask获取下一个任务时进行的 ​private Runnable getTask() { boolean timedOut = false; // Did the last poll() time out? for (;;) { int c = ctl.get(); ...... int wc = workerCountOf(c); // Are workers subject to culling? boolean timed = allowCoreThreadTimeOut || wc &gt; corePoolSize; ...... try { Runnable r = timed ? workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) : workQueue.take(); if (r != null) return r; timedOut = true; } catch (InterruptedException retry) { timedOut = false; } } } 可以看到当目前的线程数大于核心线程数时，获取任务时会执行workQueue.poll方法，这个方法在队列空时会等待给定的时间然后才会返回，如果在规定的时间仍然没有新的任务，则会在上面的processWorkerExit回收线程。 除此之外线程池还有等待队列、线程工厂、任务拒绝的handler等要点，由于时间有限，这里暂时不一一说明，以后有时间再做补充，大家也可自行探索。 需要注意的问题线程池十分好用，但是使用中也有些需要注意的点，这里我稍稍列举一些，希望大家使用中可以注意 不要使用线程池执行可能会相互依赖的任务，因为线程池不一定能保证执行顺序，很有可能会发生线程死锁 任务需要考虑可能出现的同步问题，因为任务不是在单线程环境下运行 对时间敏感的任务，不要使用线程池，因为线程池可以保证执行但是无法保证执行的时间 运行时间较长的任务尽量不要和时间较短的任务一起执行，这会严重影响短耗时任务的执行效率]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android权限管理]]></title>
    <url>%2F2018%2F07%2F11%2FAndroid%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[Android动态权限Android6.0（API23）开始，系统权限出现了很大的变化，此前在权限的检查和获取只发生在app安装时，同时获取后可以一直享有权限。在6.0以后，一些敏感的权限需要动态的获取，同时每次用户可以随时关闭权限，因此需要在每次使用前进行权限检查和获取。 权限等级6.0以后也不是所有权限的获取都需要动态的申请，权限被分成了几个等级，权限的等级主要有四种，分别是Normal、Signature、Dangerous和SignatureOrSystem。 Normal等级：任何应用都可以申请，直接在manifest声明，安装时提示用户，之后会自动获取此类权限。 Dangerous等级：任何应用都可以申请，需要在manifest中声明，同时在使用时需要动态的获取权限。 Signature等级：只有与声明权限的apk使用相同的签名私钥才能申请权限。 SignatureOrSystem:只有与声明权限的apk使用相同的签名私钥或者在/system/app目录下的应用才能申请权限。 这四种权限都是在manifest中声明权限时指定的，在普通的应用开发中我们一般需要关注的只有Normal和Dangerous两种，其中需要动态申请权限的只有Dangerous权限。 Dangerous权限Android下所有的Dangerous权限都被分成权限组，在动态申请权限时，申请的时提示给用户的信息都以组为单位的，比如如果app申请READ_CONTACTS权限,那么系统仅仅提示用户申请联系人权限，如果用户允许，在8.0以下的版本中同组的WRITE_CONTACTS也会一并被获取到，而在8.0及以上WRITE_CONTACTS权限还需要我们去动态的申请，但是系统会立即授予该权限而不会提示用户。 Dangerous权限分组 权限组 权限 CALENDAR READ_CALENDARWRITE_CALENDAR CAMERA CAMERA CONTACTS READ_CONTACTSWRITE_CONTACTSGET_ACCOUNTS LOCATION ACCESS_FINE_LOCATIONACCESS_COARSE_LOCATION MICROPHONE RECORD_AUDIO PHONE READ_PHONE_STATEREAD_PHONE_NUMBERSCALL_PHONEANSWER_PHONE_CALLSREAD_CALL_LOGWRITE_CALL_LOGADD_VOICEMAILUSE_SIPPROCESS_OUTGOING_CALLS SENSORS BODY_SENSORS SMS SEND_SMSRECEIVE_SMSREAD_SMSRECEIVE_WAP_PUSHRECEIVE_MMS STORAGE READ_EXTERNAL_STORAGEWRITE_EXTERNAL_STORAGE 动态权限申请申明权限对于Dangerous的权限，我们首先也需要在manifest中申请，这里以联系人权限为例 &lt;uses-permission android:name=&quot;android.permission.READ_CONTACTS&quot;/&gt; &lt;uses-permission android:name=&quot;android.permission.WRITE_CONTACTS&quot;/&gt; 权限检查在使用试图操作联系人前需要首先确认有没有这个权限 if(ContextCompat.checkSelfPermission(this, Manifest.permission.READ_CONTACTS) != PackageManager.PERMISSION_GRANTED){ //申请权限 }else{ //读取联系人 } ContextCompat.checkSelfPermission(Context context, String permission)方法用于检查App是否拥有参数指定的权限，方法的返回值为int，可能的取值如下 PERMISSION_GRANTED 已经获取权限 PERMISSION_DENIED 还没有获取权限 权限申请如果尚未获取权限则在使用之前需要先申请权限 ActivityCompat.requestPermissions(this, new String[]{Manifest.permission.READ_CONTACTS},CODE_REQUEST_CONTACTS); 一般情况下，ActivityCompat.requestPermissions方法会使用一个标准的对话框提示用户，但是有些机型则会跳转到一个新的页面做这件事（会导致Activity声明周期变化，甚至重启）。 申请之后则需要等待用户选择，如果如果你的Activity不是继承自AppCompatActivity，则需要实现OnRequestPermissionsResultCallback用于接收权限请求的结果回掉。 public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) { super.onRequestPermissionsResult(requestCode, permissions, grantResults); if(requestCode==CODE_REQUEST_CONTACTS){ if(grantResults[0]==PackageManager.PERMISSION_GRANTED){ //读取联系人 }else{ //权限获取失败 } } } 合理的权限申请用户首次拒绝授予权限之后，当第二次进行权限请求时，会出现“不再提示”的选项，如果用户勾选，则后续对此权限的申请将不再提示用户，直接失败。因此我们需要在合适的时机解释获取权限的原因，我们可以使用ActivityCompat.shouldShowRequestPermissionRationale方法来确定是否需要告知用户，这个方法默认情况下返回false，当用户拒绝过授予此权限后，这个返回值为true（用户勾选不再提示后返回值为false）。 if (ContextCompat.checkSelfPermission(this, Manifest.permission.READ_CONTACTS) != PackageManager.PERMISSION_GRANTED) { if (ActivityCompat.shouldShowRequestPermissionRationale(this, Manifest.permission.READ_CONTACTS)) { //提示用户后申请权限 } else { //申请权限 ActivityCompat.requestPermissions(this, new String[]{Manifest.permission.READ_CONTACTS}, CODE_REQUEST_CONTACTS); } } else { //读取联系人 } 权限被拒绝权限被拒绝后，再次申请会继续弹出，但是当用户勾选“不再提示”后，下次权限申请系统将不再提示用户，而是直接拒绝，这种情况下，我们只能引导用户到设置里自己打开权限，我们可以在onRequestPermissionsResult中通过ActivityCompat.shouldShowRequestPermissionRationale来判断用户是否选择了不再提示。 public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) { if (requestCode == CODE_REQUEST_CONTACTS) { if (grantResults[0] == PackageManager.PERMISSION_GRANTED) { //读取联系人 } else { if(!ActivityCompat.shouldShowRequestPermissionRationale(this, Manifest.permission.READ_CONTACTS)){ //引导用户到设置页面开启权限 } } } } //跳转到设置页面相关代码 Intent intent = new Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS); Uri uri = Uri.fromParts(&quot;package&quot;,getApplicationContext().getPackageName(), null); intent.setData(uri); startActivity(intent); 参考文章 Android 权限的一些细节 Android中的权限管理 Android 6.0 运行时权限处理完全解析 Android6.0动态权限申请步骤以及需要注意的一些坑]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>permission</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AndrodUI测试入门]]></title>
    <url>%2F2018%2F03%2F05%2FAndrodUI%E6%B5%8B%E8%AF%95%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[UI测试UI 测试是为了确保对于用户的UI动作，app能返回正确的UI输出。根据实际实现方案大体可以分为两种： End-To-End（E2E）UI测试，直接通过客户端和后台服务器的交互测试整个系统，普通操作UI，通过网络获取数据，验证UI数据。实现简单，但是存在测试速度缓慢，可能因为网络导致测试用例不通过的问题。 封闭UI测试，测试方法使得测试不需要外部依赖和网络请求，使用Mock Server或者其他方式替代真实的网络请求，只验证UI输出的正确性。 UI测试框架Android之前比较流行的UI测试框架有robotium、Appium、uiautomator、Calabash、Espresso,但是其中Espresso作为Google官方开源的UI测试框架，以其官方的身份、完整的使用文档以及简单的使用方法，快速成为UI测试框架中的主流，本文就是以Espresso框架为主要测试框架。 Espresso介绍及集成Espresso 测试框架提供了一组 API 来构建 UI 测试，用于测试应用中的用户流。利用这些 API，您可以编写简洁、运行可靠的自动化 UI 测试。Espresso 非常适合编写白盒自动化测试，其中测试代码将利用所测试应用的实现代码详情。目前Espresso最新的版本已经出道3.0.1，使用AS创建的工程，默认已经集成了2.2.2版本的Espresso，但是如果要集成最新版本的Espresso库，需要在仓库配置中添加对应仓库地址： allprojects { repositories { jcenter() maven { url &quot;https://maven.google.com&quot; //Espresso3.0.1所在仓库地址 } } } 默认集成的Espresso包espresso-core及其相关依赖包，足以完成一般性的UI测试，除此之外Espresso还有一些扩展包，用于完成一些特殊的测试场景: espresso-web 提供了对WebView测试的相关支持 espresso-contrib 提供了对DatePicker, RecyclerView 和 Drawer等控件的特有动作、无障碍以及CountingIdlingResource的支持 espresso-intents 用于校验多app测试中intent的正确性 espresso-idling-resource（已经包含在core的依赖中）用于处理异步线程同步问题 如果测试过程中不需要上述的扩展功能，则只需要添加core的依赖 dependencies { androidTestCompile(&apos;com.android.support.test.espresso:espresso-core:3.0.1&apos;, { exclude group: &apos;com.android.support&apos;, module: &apos;support-annotations&apos; //不导入依赖中的support-annotations，避免出现依赖冲突，会使用用户自己导入的包 }) } 其余诸如runner，rules包都被core依赖，会自动导入，没有必要手动导入，以免导入版本不正确引起其他问题，除了上面描述的相关库，Espresso还依赖了JUnit和Hamcrest等其他测试辅助框架。 EspressoUI测试的重要对象 Espresso Espresso框架的入口类，提供了一些静态方法，便于开始整个测试代码，它提供了类似onView和onData这种方法获取一个可交互的对象ViewInteraction，或者直接进行一个例如页面返回的顶层操作。 ViewMatchers 定义了一系列静态方法用于根据不同条件返回Matcher&lt;? super View&gt;对象，作为参数传递给onView()。 ViewActions view的操作行为例如click()，最为ViewInteraction.perform()的参数用于对指定View的进行对应操作。 ViewAssertions 作为ViewInteraction.check()的参数，判断view的输出是否正确 ActivityTestRule 提供了测试单个Activity的功能，当它的launchActivity设置为true时，它会在每个使用@Test注释的方法前和所有注释者@Before的方法前启动。同时可以通过ActivityTestRule对象获取对应Activity的对象。 一个简单的代码示例如下： @RunWith(AndroidJUnit4.class) public class LoginTest { @Rule public ActivityTestRule&lt;LoginActivity&gt; mActivityRule = new ActivityTestRule(LoginActivity.class); @Test public void login() throws Exception { onView(withId(R.id.et_login_number)).perform(click(),replaceText(&quot;17720380994&quot;),closeSoftKeyboard()); onView(withId(R.id.btn_login_next)).perform(click()); onView(withId(R.id.et_password)).perform(click(),replaceText(&quot;aa123456&quot;),closeSoftKeyboard()); onView(withId(R.id.btn_login)).perform(click()); onView(withId(R.id.toolbar)).check(matches(isDisplayed())); onView(allOf(instanceOf(ImageButton.class),withParent(withId(R.id.toolbar)),isDisplayed())).perform(click()); onView(withId(R.id.tv_phone_number)).check(matches(withText(&quot;17720380994&quot;))); onView(IsInstanceOf.&lt;View&gt;instanceOf(ScrollView.class)).perform(swipeUp()); onView(withId(R.id.tv_exit)).perform(click()); onView(withText(R.string.exit_login_confirm)).check(matches(isDisplayed())); onView(withId(R.id.tv_ok)).perform(click()); onView(withId(R.id.et_login_number)).check(matches(isDisplayed())); } } 总体来说UI测试的过程就是：找到某个元素，做一些操作，检查结果。 寻找ViewEspresso中定位View主要有两种，通过页面显示的View特征（onView）和通过数据内容（onData），其中onView用于普通场景，onData用于adapterView这种可能没有渲染的view，但是两者都是基于hamcrest的matcher来进行，本质是相同的不同的是匹配规则 ViewMathcerViewMathcer实质上提供了很多Matcher对象，主要用于配合OnView匹配控件，这些Matcher同时可以配合hamcrest中的matcher一起使用，效果更好。常用的Matcher如下 withId() onView(withId(R.id.tv_ok))直接通过id定位指定的的View，简单粗暴，但是非常实用。 isAssignableFrom() onView(isAssignableFrom(ScrollView.class))通过对象类型判断 isDisplayed() onView(allOf(isDisplayed(),isAssignableFrom(ScrollView.class))) 通过是否显示判断，通常和其他matcher配合(allOf是hamcrest库重的方法，用于匹配多个matcher，类似的还有anyOf) isEnabled() isFocusable()…… ViewMathcer中几乎把所有的View属性都定义了对应的matcher，需要的可以自行查阅源码或文档。 DataInteractionDataInteraction 是onData方法的返回值，因为onData方法匹配出的不直接就是View，它匹配的是一个数据集合，只有我们想要进行具体的View操作时，Espresso才会把它转化为View。​ onData(instanceOf(Account.class))Espresso没有为onData定义Matcher，基本都是使用hamcrest中定义的matcher或者自定义matcher 自定义Matcher一般自定义Matcher都继承TypeSafeMatcher，需要实现的方法如下 public class CallInfoMatcher extends TypeSafeMatcher&lt;CallInfo&gt; { @Override public void describeTo(Description description) { //匹配失败时的描述，用于描述具体的匹配失败信息 } @Override protected boolean matchesSafely(CallInfo item) { //具体的匹配过程 return false; } } 对View的操作View的操作都是在ViewInteraction上进行的。ViewInteraction也就是onView的返回值对象，用于对于具体的View进行操作（DataInteraction的操作也是转换为ViewInteraction后进行的），ViewInteraction提供了如下方法来对相应的元素做操作： public ViewInteraction perform(final ViewAction... viewActions) {} 具体的操作通过ViewAction定义，连续操作可以链式调用或者作为参数顺序排列。 ViewActionViewAction是espresso中定义的针对View操作的接口类型。ViewAction中实现主要在ViewActions类中通过静态方法提供。常见的action如下 click() closeSoftKeyboard() replaceText()…… 除去ViewActions提供的较为通用的操作方法，Espresso还提供了很多ViewAction的子类用于完成不同View的特定操作。 ViewAction是在View匹配成功的基础上进行的匹配失败或者匹配不唯一都会导致测试不通过，同时Action与View类型不匹配也会失败 校验结果测试最重要的一步就是校验结果的正确性，ViewInteraction提供了check()方法用于校验正确性 public ViewInteraction check(final ViewAssertion viewAssert) { ...... } 和perform()方法类似，check()也是可以链式调用多次校验。 ViewAssertionViewAssertion是espresso中定义的用于校验View状态的接口类型，同样ViewAssertion也主要由ViewAssertions中的静态方法提供。其中主要使用的就是matches()方法 public static ViewAssertion matches(final Matcher&lt;? super View&gt; viewMatcher) { return new MatchesViewAssertion(checkNotNull(viewMatcher)); } 其中参数viewMatcher就是前面用于匹配View的ViewMatcher。 异步问题Espresso提供了大量的同步机制，这些机制主要针对于主线层的MQ，但是Espresso对于其他的异步操作是无感知的，如果View的显示依赖于网络数据，很有可能就会导致测试用例不通过，因此需要使用前面使用的espresso-idling-resource来保证Espresso在异步线程的可靠性。 espresso-idling-resource依赖添加如下 compile(&quot;com.android.support.test.espresso:espresso-idling-resource:3.0.1&quot;) { exclude module: &apos;support-annotations&apos; } androidTestCompile(&quot;com.android.support.test.espresso:espresso-idling-resource:3.0.1&quot;) { exclude module: &apos;support-annotations&apos; } //由于Espresso对与异步线程无感知，我们需要在代码中主动使用IdlingResource，因此需要使用compile依赖。 IdlingResourceEspresso主要通过IdlingResource这个接口类型完成对异步资源的感知，主要方法如下 public interface IdlingResource { //用于标识对于的异步资源 public String getName(); //返回目前资源是否可用(闲置)， public boolean isIdleNow(); //Espresso会注册此回掉，需要判断资源可用时主动调用 public void registerIdleTransitionCallback(ResourceCallback callback); public interface ResourceCallback { public void onTransitionToIdle(); } } Espresso提供了几个IdlingResource的实现类，可以直接使用： CountingIdlingResource 为资源提供了一个简单的使用计数，当count为0时资源为闲置状态。 UriIdlingResource 类似CountingIdlingResource,但是count为0时资源不会立即为闲置状态。 IdlingThreadPoolExecutor 一个有IdlingResource功能的ThreadPoolExecutor。 IdlingScheduledThreadPoolExecutor em.. 同上 我们借CountingIdlingResource来了解下IdlingResource的主要用法，CountingIdlingResource主要提供的两个共有方法供我们使用 increment()计数加一 decrement()计数减一，为0时调用onTransitionToIdle() 例如使用网络请求的场景，发起请求时increment()表示资源被占用，请求结束时decrement()，表示资源被释放。同时还需要在测试代码中注册对应资源 IdlingRegistry.getInstance().register(idlingResource); IdlingResource解决了异步代码的问题，但是依旧存在问题，我们在业务逻辑代码中创建IdlingResource对象，同时在需要的地方去改变它的状态，然后在测试代码中使用。这无疑是为了测试而给正常的业务代码增加了不必要的逻辑。 未完待续～]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Test</tag>
      </tags>
  </entry>
</search>
