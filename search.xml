<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Android权限管理]]></title>
    <url>%2F2018%2F07%2F11%2FAndroid%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[Android动态权限Android6.0（API23）开始，系统权限出现了很大的变化，此前在权限的检查和获取只发生在app安装时，同时获取后可以一直享有权限。在6.0以后，一些敏感的权限需要动态的获取，同时每次用户可以随时关闭权限，因此需要在每次使用前进行权限检查和获取。 权限等级6.0以后也不是所有权限的获取都需要动态的申请，权限被分成了几个等级，权限的等级主要有四种，分别是Normal、Signature、Dangerous和SignatureOrSystem。 Normal等级：任何应用都可以申请，直接在manifest声明，安装时提示用户，之后会自动获取此类权限。 Dangerous等级：任何应用都可以申请，需要在manifest中声明，同时在使用时需要动态的获取权限。 Signature等级：只有与声明权限的apk使用相同的签名私钥才能申请权限。 SignatureOrSystem:只有与声明权限的apk使用相同的签名私钥或者在/system/app目录下的应用才能申请权限。 这四种权限都是在manifest中声明权限时指定的，在普通的应用开发中我们一般需要关注的只有Normal和Dangerous两种，其中需要动态申请权限的只有Dangerous权限。 Dangerous权限Android下所有的Dangerous权限都被分成权限组，在动态申请权限时，申请的时提示给用户的信息都以组为单位的，比如如果app申请READ_CONTACTS权限,那么系统仅仅提示用户申请联系人权限，如果用户允许，在8.0以下的版本中同组的WRITE_CONTACTS也会一并被获取到，而在8.0及以上WRITE_CONTACTS权限还需要我们去动态的申请，但是系统会立即授予该权限而不会提示用户。 Dangerous权限分组 权限组 权限 CALENDAR READ_CALENDARWRITE_CALENDAR CAMERA CAMERA CONTACTS READ_CONTACTSWRITE_CONTACTSGET_ACCOUNTS LOCATION ACCESS_FINE_LOCATIONACCESS_COARSE_LOCATION MICROPHONE RECORD_AUDIO PHONE READ_PHONE_STATEREAD_PHONE_NUMBERSCALL_PHONEANSWER_PHONE_CALLSREAD_CALL_LOGWRITE_CALL_LOGADD_VOICEMAILUSE_SIPPROCESS_OUTGOING_CALLS SENSORS BODY_SENSORS SMS SEND_SMSRECEIVE_SMSREAD_SMSRECEIVE_WAP_PUSHRECEIVE_MMS STORAGE READ_EXTERNAL_STORAGEWRITE_EXTERNAL_STORAGE 动态权限申请申明权限对于Dangerous的权限，我们首先也需要在manifest中申请，这里以联系人权限为例 &lt;uses-permission android:name=&quot;android.permission.READ_CONTACTS&quot;/&gt; &lt;uses-permission android:name=&quot;android.permission.WRITE_CONTACTS&quot;/&gt; 权限检查在使用试图操作联系人前需要首先确认有没有这个权限 if(ContextCompat.checkSelfPermission(this, Manifest.permission.READ_CONTACTS) != PackageManager.PERMISSION_GRANTED){ //申请权限 }else{ //读取联系人 } ContextCompat.checkSelfPermission(Context context, String permission)方法用于检查App是否拥有参数指定的权限，方法的返回值为int，可能的取值如下 PERMISSION_GRANTED 已经获取权限 PERMISSION_DENIED 还没有获取权限 权限申请如果尚未获取权限则在使用之前需要先申请权限 ActivityCompat.requestPermissions(this, new String[]{Manifest.permission.READ_CONTACTS},CODE_REQUEST_CONTACTS); 一般情况下，ActivityCompat.requestPermissions方法会使用一个标准的对话框提示用户，但是有些机型则会跳转到一个新的页面做这件事（会导致Activity声明周期变化，甚至重启）。 申请之后则需要等待用户选择，如果如果你的Activity不是继承自AppCompatActivity，则需要实现OnRequestPermissionsResultCallback用于接收权限请求的结果回掉。 public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) { super.onRequestPermissionsResult(requestCode, permissions, grantResults); if(requestCode==CODE_REQUEST_CONTACTS){ if(grantResults[0]==PackageManager.PERMISSION_GRANTED){ //读取联系人 }else{ //权限获取失败 } } } 合理的权限申请用户首次拒绝授予权限之后，当第二次进行权限请求时，会出现“不再提示”的选项，如果用户勾选，则后续对此权限的申请将不再提示用户，直接失败。因此我们需要在合适的时机解释获取权限的原因，我们可以使用ActivityCompat.shouldShowRequestPermissionRationale方法来确定是否需要告知用户，这个方法默认情况下返回false，当用户拒绝过授予此权限后，这个返回值为true（用户勾选不再提示后返回值为false）。 if (ContextCompat.checkSelfPermission(this, Manifest.permission.READ_CONTACTS) != PackageManager.PERMISSION_GRANTED) { if (ActivityCompat.shouldShowRequestPermissionRationale(this, Manifest.permission.READ_CONTACTS)) { //提示用户后申请权限 } else { //申请权限 ActivityCompat.requestPermissions(this, new String[]{Manifest.permission.READ_CONTACTS}, CODE_REQUEST_CONTACTS); } } else { //读取联系人 } 权限被拒绝权限被拒绝后，再次申请会继续弹出，但是当用户勾选“不再提示”后，下次权限申请系统将不再提示用户，而是直接拒绝，这种情况下，我们只能引导用户到设置里自己打开权限，我们可以在onRequestPermissionsResult中通过ActivityCompat.shouldShowRequestPermissionRationale来判断用户是否选择了不再提示。 public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) { if (requestCode == CODE_REQUEST_CONTACTS) { if (grantResults[0] == PackageManager.PERMISSION_GRANTED) { //读取联系人 } else { if(!ActivityCompat.shouldShowRequestPermissionRationale(this, Manifest.permission.READ_CONTACTS)){ //引导用户到设置页面开启权限 } } } } //跳转到设置页面相关代码 Intent intent = new Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS); Uri uri = Uri.fromParts(&quot;package&quot;,getApplicationContext().getPackageName(), null); intent.setData(uri); startActivity(intent); 参考文章 Android 权限的一些细节 Android中的权限管理 Android 6.0 运行时权限处理完全解析 Android6.0动态权限申请步骤以及需要注意的一些坑]]></content>
      <tags>
        <tag>Android</tag>
        <tag>permission</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AndrodUI测试入门]]></title>
    <url>%2F2018%2F03%2F05%2FAndrodUI%E6%B5%8B%E8%AF%95%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[UI测试UI 测试是为了确保对于用户的UI动作，app能返回正确的UI输出。根据实际实现方案大体可以分为两种： End-To-End（E2E）UI测试，直接通过客户端和后台服务器的交互测试整个系统，普通操作UI，通过网络获取数据，验证UI数据。实现简单，但是存在测试速度缓慢，可能因为网络导致测试用例不通过的问题。 封闭UI测试，测试方法使得测试不需要外部依赖和网络请求，使用Mock Server或者其他方式替代真实的网络请求，只验证UI输出的正确性。 UI测试框架Android之前比较流行的UI测试框架有robotium、Appium、uiautomator、Calabash、Espresso,但是其中Espresso作为Google官方开源的UI测试框架，以其官方的身份、完整的使用文档以及简单的使用方法，快速成为UI测试框架中的主流，本文就是以Espresso框架为主要测试框架。 Espresso介绍及集成Espresso 测试框架提供了一组 API 来构建 UI 测试，用于测试应用中的用户流。利用这些 API，您可以编写简洁、运行可靠的自动化 UI 测试。Espresso 非常适合编写白盒自动化测试，其中测试代码将利用所测试应用的实现代码详情。目前Espresso最新的版本已经出道3.0.1，使用AS创建的工程，默认已经集成了2.2.2版本的Espresso，但是如果要集成最新版本的Espresso库，需要在仓库配置中添加对应仓库地址： allprojects { repositories { jcenter() maven { url &quot;https://maven.google.com&quot; //Espresso3.0.1所在仓库地址 } } } 默认集成的Espresso包espresso-core及其相关依赖包，足以完成一般性的UI测试，除此之外Espresso还有一些扩展包，用于完成一些特殊的测试场景: espresso-web 提供了对WebView测试的相关支持 espresso-contrib 提供了对DatePicker, RecyclerView 和 Drawer等控件的特有动作、无障碍以及CountingIdlingResource的支持 espresso-intents 用于校验多app测试中intent的正确性 espresso-idling-resource（已经包含在core的依赖中）用于处理异步线程同步问题 如果测试过程中不需要上述的扩展功能，则只需要添加core的依赖 dependencies { androidTestCompile(&apos;com.android.support.test.espresso:espresso-core:3.0.1&apos;, { exclude group: &apos;com.android.support&apos;, module: &apos;support-annotations&apos; //不导入依赖中的support-annotations，避免出现依赖冲突，会使用用户自己导入的包 }) } 其余诸如runner，rules包都被core依赖，会自动导入，没有必要手动导入，以免导入版本不正确引起其他问题，除了上面描述的相关库，Espresso还依赖了JUnit和Hamcrest等其他测试辅助框架。 EspressoUI测试的重要对象 Espresso Espresso框架的入口类，提供了一些静态方法，便于开始整个测试代码，它提供了类似onView和onData这种方法获取一个可交互的对象ViewInteraction，或者直接进行一个例如页面返回的顶层操作。 ViewMatchers 定义了一系列静态方法用于根据不同条件返回Matcher&lt;? super View&gt;对象，作为参数传递给onView()。 ViewActions view的操作行为例如click()，最为ViewInteraction.perform()的参数用于对指定View的进行对应操作。 ViewAssertions 作为ViewInteraction.check()的参数，判断view的输出是否正确 ActivityTestRule 提供了测试单个Activity的功能，当它的launchActivity设置为true时，它会在每个使用@Test注释的方法前和所有注释者@Before的方法前启动。同时可以通过ActivityTestRule对象获取对应Activity的对象。 一个简单的代码示例如下： @RunWith(AndroidJUnit4.class) public class LoginTest { @Rule public ActivityTestRule&lt;LoginActivity&gt; mActivityRule = new ActivityTestRule(LoginActivity.class); @Test public void login() throws Exception { onView(withId(R.id.et_login_number)).perform(click(),replaceText(&quot;17720380994&quot;),closeSoftKeyboard()); onView(withId(R.id.btn_login_next)).perform(click()); onView(withId(R.id.et_password)).perform(click(),replaceText(&quot;aa123456&quot;),closeSoftKeyboard()); onView(withId(R.id.btn_login)).perform(click()); onView(withId(R.id.toolbar)).check(matches(isDisplayed())); onView(allOf(instanceOf(ImageButton.class),withParent(withId(R.id.toolbar)),isDisplayed())).perform(click()); onView(withId(R.id.tv_phone_number)).check(matches(withText(&quot;17720380994&quot;))); onView(IsInstanceOf.&lt;View&gt;instanceOf(ScrollView.class)).perform(swipeUp()); onView(withId(R.id.tv_exit)).perform(click()); onView(withText(R.string.exit_login_confirm)).check(matches(isDisplayed())); onView(withId(R.id.tv_ok)).perform(click()); onView(withId(R.id.et_login_number)).check(matches(isDisplayed())); } } 总体来说UI测试的过程就是：找到某个元素，做一些操作，检查结果。 寻找ViewEspresso中定位View主要有两种，通过页面显示的View特征（onView）和通过数据内容（onData），其中onView用于普通场景，onData用于adapterView这种可能没有渲染的view，但是两者都是基于hamcrest的matcher来进行，本质是相同的不同的是匹配规则 ViewMathcerViewMathcer实质上提供了很多Matcher对象，主要用于配合OnView匹配控件，这些Matcher同时可以配合hamcrest中的matcher一起使用，效果更好。常用的Matcher如下 withId() onView(withId(R.id.tv_ok))直接通过id定位指定的的View，简单粗暴，但是非常实用。 isAssignableFrom() onView(isAssignableFrom(ScrollView.class))通过对象类型判断 isDisplayed() onView(allOf(isDisplayed(),isAssignableFrom(ScrollView.class))) 通过是否显示判断，通常和其他matcher配合(allOf是hamcrest库重的方法，用于匹配多个matcher，类似的还有anyOf) isEnabled() isFocusable()…… ViewMathcer中几乎把所有的View属性都定义了对应的matcher，需要的可以自行查阅源码或文档。 DataInteractionDataInteraction 是onData方法的返回值，因为onData方法匹配出的不直接就是View，它匹配的是一个数据集合，只有我们想要进行具体的View操作时，Espresso才会把它转化为View。​ onData(instanceOf(Account.class))Espresso没有为onData定义Matcher，基本都是使用hamcrest中定义的matcher或者自定义matcher 自定义Matcher一般自定义Matcher都继承TypeSafeMatcher，需要实现的方法如下 public class CallInfoMatcher extends TypeSafeMatcher&lt;CallInfo&gt; { @Override public void describeTo(Description description) { //匹配失败时的描述，用于描述具体的匹配失败信息 } @Override protected boolean matchesSafely(CallInfo item) { //具体的匹配过程 return false; } } 对View的操作View的操作都是在ViewInteraction上进行的。ViewInteraction也就是onView的返回值对象，用于对于具体的View进行操作（DataInteraction的操作也是转换为ViewInteraction后进行的），ViewInteraction提供了如下方法来对相应的元素做操作： public ViewInteraction perform(final ViewAction... viewActions) {} 具体的操作通过ViewAction定义，连续操作可以链式调用或者作为参数顺序排列。 ViewActionViewAction是espresso中定义的针对View操作的接口类型。ViewAction中实现主要在ViewActions类中通过静态方法提供。常见的action如下 click() closeSoftKeyboard() replaceText()…… 除去ViewActions提供的较为通用的操作方法，Espresso还提供了很多ViewAction的子类用于完成不同View的特定操作。 ViewAction是在View匹配成功的基础上进行的匹配失败或者匹配不唯一都会导致测试不通过，同时Action与View类型不匹配也会失败 校验结果测试最重要的一步就是校验结果的正确性，ViewInteraction提供了check()方法用于校验正确性 public ViewInteraction check(final ViewAssertion viewAssert) { ...... } 和perform()方法类似，check()也是可以链式调用多次校验。 ViewAssertionViewAssertion是espresso中定义的用于校验View状态的接口类型，同样ViewAssertion也主要由ViewAssertions中的静态方法提供。其中主要使用的就是matches()方法 public static ViewAssertion matches(final Matcher&lt;? super View&gt; viewMatcher) { return new MatchesViewAssertion(checkNotNull(viewMatcher)); } 其中参数viewMatcher就是前面用于匹配View的ViewMatcher。 异步问题Espresso提供了大量的同步机制，这些机制主要针对于主线层的MQ，但是Espresso对于其他的异步操作是无感知的，如果View的显示依赖于网络数据，很有可能就会导致测试用例不通过，因此需要使用前面使用的espresso-idling-resource来保证Espresso在异步线程的可靠性。 espresso-idling-resource依赖添加如下 compile(&quot;com.android.support.test.espresso:espresso-idling-resource:3.0.1&quot;) { exclude module: &apos;support-annotations&apos; } androidTestCompile(&quot;com.android.support.test.espresso:espresso-idling-resource:3.0.1&quot;) { exclude module: &apos;support-annotations&apos; } //由于Espresso对与异步线程无感知，我们需要在代码中主动使用IdlingResource，因此需要使用compile依赖。 IdlingResourceEspresso主要通过IdlingResource这个接口类型完成对异步资源的感知，主要方法如下 public interface IdlingResource { //用于标识对于的异步资源 public String getName(); //返回目前资源是否可用(闲置)， public boolean isIdleNow(); //Espresso会注册此回掉，需要判断资源可用时主动调用 public void registerIdleTransitionCallback(ResourceCallback callback); public interface ResourceCallback { public void onTransitionToIdle(); } } Espresso提供了几个IdlingResource的实现类，可以直接使用： CountingIdlingResource 为资源提供了一个简单的使用计数，当count为0时资源为闲置状态。 UriIdlingResource 类似CountingIdlingResource,但是count为0时资源不会立即为闲置状态。 IdlingThreadPoolExecutor 一个有IdlingResource功能的ThreadPoolExecutor。 IdlingScheduledThreadPoolExecutor em.. 同上 我们借CountingIdlingResource来了解下IdlingResource的主要用法，CountingIdlingResource主要提供的两个共有方法供我们使用 increment()计数加一 decrement()计数减一，为0时调用onTransitionToIdle() 例如使用网络请求的场景，发起请求时increment()表示资源被占用，请求结束时decrement()，表示资源被释放。同时还需要在测试代码中注册对应资源 IdlingRegistry.getInstance().register(idlingResource); IdlingResource解决了异步代码的问题，但是依旧存在问题，我们在业务逻辑代码中创建IdlingResource对象，同时在需要的地方去改变它的状态，然后在测试代码中使用。这无疑是为了测试而给正常的业务代码增加了不必要的逻辑。 未完待续～]]></content>
      <tags>
        <tag>Android，Test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gradle脚本从入门到...(1)]]></title>
    <url>%2F2018%2F01%2F19%2FGradle%E8%84%9A%E6%9C%AC%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0-1%2F</url>
    <content type="text"><![CDATA[前言之前也写过一篇关于Gradle的文章，但是想要All In Once，最后写了一篇长文，但是结果很不理想，感觉什么都要讲，但是很多东西又都没有讲清楚。刚好最近突发奇想，想要搭个自己blog，以此为契机把之前的文章再整理一下。言归正传，正文开始。 Gradle介绍Gradle是一个项目自动构建工具，属于代码之外，和ant、maven这类老牌的构建工具相比，最大的不同就是不同就是使用groovy脚本语言替代了xml作为项目构建的配置方式。相比于繁琐的xml，groovy无疑在代码简洁和已于理解上有着很大的优势。除此之外Gradle与maven在依赖控制上有着极大的共同之处，甚至Gradle的依赖管理就是在maven的基础上发展而来。 虽然Gradle的使用者大部分都是从AS而来，但是想要了解Gradle最好还是先抛开IDE，拥抱命令行。因为大部分情况下IDE都会对原始的Gradle做一层封装，一来不方便深入学习，二来不利于暴露问题。 Gradle的安装Gradle除了最初的从无到有的情况外，基本上不需要手动安装，然而我们最开始还真是一无所有。有两种方式安装Gradle： 直接到官网 下载需要的对应平台的版本。 使用包管理器直接下载，目前支持5种包管理，后续可能会增加，详情请见 安装完成之后，就是配置好对应的环境变量，需要配置的目录为../gradle../bin 配置方法请按各自平台进行。配置完成后，使用如下命令 $ gradle -v 正常输出Gradle版本，表示安装完成。 Gradle Wrapper前面说Gradle基本不需要手动安装，就是由于Gradle Wrapper的存在。Wrapper是一个使用了特定gradle版本的脚本，能够直接通过此脚本运行Gradle命令，即使此前没有下载过gradle，当然如果没有下载过gradle，wrapper脚本会去下载对应版本的Gradle。 使用AS打开github上的新项目时极有可能就会开在Gradle版本下载上，根本上网络问题，可以取消去手动下载。 生成Wrapper非常简单，直接运行对应命令行指令 gradle wrapper:wrapperBUILD SUCCESSFUL in 0s1 actionable task: 1 executed 即可生成path内对应版本的wrapper，生成的wraper主要包括如下文件 drwxr-xr-x 4 houyi staff 128 1 29 13:55 .gradledrwxr-xr-x 3 houyi staff 96 1 29 13:55 gradle-rwxr-xr-x 1 houyi staff 5296 1 29 13:55 gradlew-rw-r--r-- 1 houyi staff 2260 1 29 13:55 gradlew.bat 在gradle目录下]]></content>
      <tags>
        <tag>Gradle</tag>
        <tag>Android</tag>
        <tag>构建</tag>
      </tags>
  </entry>
</search>
