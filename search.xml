<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ThreadLocal详解]]></title>
    <url>%2F2018%2F07%2F19%2FThreadLocal%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[ThreadLocal是什么ThreadLocal是java中处理并发问题的一种方式，但是和Synchronized、volatile等进程同步关键字不同，ThreadLocal主要用于进程隔离，即每一个线程都有一个自己的ThreadLocal，访问时访问的都是线程持有的对象，无法访问其他线程的ThreadLocal,也就不存在并发的问题。 ThreadLocal使用ThreadLocal使用起来类似一个数据封装类，使用set和get方法设置和获取存储的内容 //创建ThreadLocal对象，使用泛型制定类型ThreadLocal&lt;Integer&gt; localInt = new ThreadLocal&lt;&gt;();//写入内容localInt.set(10);//获取内容assert locaInt.get()==10; ThreadLocal特殊的地方就在于不同线程间是无法获取到其它线程的相应对象的，在多线程场景中对ThreadLocal的使用实例如下 ThreadLocal&lt;Integer&gt; localInt = new ThreadLocal&lt;&gt;();Thread threadA = new Thread() &#123; @Override public void run() &#123; for(int i=100;i&lt;200;i++)&#123; try &#123; localInt.set(i); sleep(10); assert localInt.get()==i; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; super.run(); &#125;&#125;;Thread threadB = new Thread() &#123; @Override public void run() &#123; for(int i=0;i&lt;100;i++)&#123; try &#123; localInt.set(i); sleep(10); assert localInt.get()==i; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; super.run(); &#125;&#125;;threadA.start();threadB.start(); ThreadA和ThreadB中ThreadLocal是不会相互影响的，他们每次从ThreadLocal中获取的都是线程内部的相应数据。 在上面的例子中我们只是用ThreadLocal存储了一个变量，如果想要同时拥有多个线程私有的变量就只能创建多个TreadLocal对象。 ThreadLocal实现原理ThreadLocal看上去很神奇，原理其实并不难，它只是把我们的变量关联到了线程的Thread对象上，我们借助ThreadLocal的set方法来说明这点。 public void set(T value) &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value);&#125;ThreadLocalMap getMap(Thread t) &#123; return t.threadLocals;&#125; 在我们通过set方法设置ThreadLocal的内容是，它首先获取当前的Thread对象，同时获取Thread上的ThreadLocalMap，ThreadLocalMap事实上是hash表的一种实现，set事实上是把ThreadLocal对象和相应的value分别作为key和value保证在了这个map中，也就是说我们的value保存在Thread对象内。 get方法也是类似的，我们使用get方法获取值的时候，首先是获取currentThread，然后通过Thread的ThreadLocalMap用ThreadLocal作为key获取对应的value。 public T get() &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) &#123; @SuppressWarnings("unchecked") T result = (T)e.value; return result; &#125; &#125; return setInitialValue();&#125; 如果没有创建过ThreadLocalMap，setInitialValue会创建ThreadLocalMap同时返回null。 ThreadLocal内存泄漏正常来说ThreadLocal的对象和其保存的value持有在一个普通的对象内，而在保存时他们会作为key和value保存在Thread对象的map内，线程一般拥有比普通对象更长的生命周期，特别是对于线程池中的线程。 这种情况下作为key的ThreadLocal和value就有泄漏的风险，ThreadLocal的设计上自然也考虑到了这点，因此ThreadLocalMap中Key都是作为弱引用存在的 static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123; /** The value associated with this ThreadLocal. */ Object value; Entry(ThreadLocal&lt;?&gt; k, Object v) &#123; super(k); value = v; &#125;&#125; 这样当持有ThreadLocal的对象销毁后，没有强引用的ThreadLocal也会很快被回收，但是与之对应的value却没法被自动回收。 事实上ThreadLocalMap对于这样的情况也是有所处理，即ThreadLocalMap在每次set或者get时发现有key为空的元素，都会把它清理掉 private void set(ThreadLocal&lt;?&gt; key, Object value) &#123; ...... for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) &#123; ThreadLocal&lt;?&gt; k = e.get(); if (k == key) &#123; e.value = value; return; &#125; //清理掉key==null的元素 if (k == null) &#123; replaceStaleEntry(key, value, i); return; &#125; &#125; ......&#125; 但是即使这样光靠ThreadLocalMap也没有办法完全避免value的内存泄漏，最好的就是每次使用完ThreadLocal后都调用它的remove方法，清除数据。]]></content>
      <tags>
        <tag>Android</tag>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android线程池]]></title>
    <url>%2F2018%2F07%2F16%2FAndroid%E7%BA%BF%E7%A8%8B%E6%B1%A0%2F</url>
    <content type="text"><![CDATA[为什么使用线程池线程是操作系统能进行运算调度的最小单元，在Java 中直接使用线程，给我们带来了很多便利，但是线程的使用同时也存在一些问题 线程生命周期的开销非常高，即在线程的创建和销毁过程都会消耗较大的cpu资源 资源消耗，线程的存在期间会消耗系统资源，尤其是内存（短时间内高并发任务尤其需要注意） 线程池线程池就是一种线程复用的手段，它通过缓存已有线程，来减小线程创建过程的消耗，它通过控制线程数量来控制线程存在的系统消耗，同时他把任务和任务的执行进行了解耦，把任务本身和任务的执行过程分离。这一点从Executor就可以看出 public interface Executor { void execute(Runnable command); } 任务封装成Runnable，通过execute在内部通过缓存的线程对任务进行处理，对于Runnable这个任务而言，具体的执行策略它毫不知晓，同时我们可以有极大的空间来制定执行策略。 构造线程池线程池给我们创造了极大扩展空间用于管理线程资源和定义任务的执行策略，同时为了更加方便我们使用，Java定义了一些配置成型的线程池供我们使用，这些线程池可以通过Executors这样一个工厂类获取 newFixedThreadPool。newFixedThreadPool会创建一个固定长度的线程池，每当提交一个任务时，就会创建一个线程（即使有空闲的线程），直到达到线程最大值。 newCachedThreadPool。newCachedThreadPool会创建一个可缓存的线程池，任务提交时没有空闲的线程就会创建新的线程，且这个过程没有上线，当线程执行完成后60s内没有被其他任务复用就会被销毁。 newSingleThreadExecutor。newSingleThreadExecutor是一个单线程的Executor，一般按照FIFO的顺序执行（不同于我们自己创建的单线程Thread，如果Thread不慎挂掉，会创建一个新的线程保证运行过程） newSingleThreadExecutor。创建一个固定长度线程池，会使用延迟或者定时的方式来执行任务。 上面列举了几个Java中提供好的线程策略，类似的在Executors中还有很多，这里不一一列举，本质上来说，这些方法是对现有的几个线程池实现类的一种配置方式，具体线程池的复用以及调度的方式是怎么样的呢？ 线程池调度策略调度内容线程池是对线程的一个管理，它到底管理什么东西 使用什么线程执行任务 任务执行顺序 有多少任务可以同时处理 能够有多少任务等待，如果需要执行的任务超过这个上限如何处理 任务运行时出现异常怎么处理 任务前后有哪些动作 ThreadPoolExecutor我们使用的绝大部分线程池最终的实现类都是ThreadPoolExecutor，我们可以通过这个对象来真正了解线程池，首先是ThreadPoolExecutor的构造方法 public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) 从构造方法可以看出很多内容，ThreadPoolExecutor中的线程分为普通线程和核心线程，有线程存活时间，任务等待队列，线程工厂，任务拒绝的handler。 核心线程数和最大线程数关于核心线程和最大线程可以看一下execute方法的一段代码 //线程数小于核心线程直接添加新线程执行 int c = ctl.get(); if (workerCountOf(c) &lt; corePoolSize) { if (addWorker(command, true)) return; c = ctl.get(); } //将任务放入等待队列，同时检测线程池运行状态并处理 if (isRunning(c) &amp;&amp; workQueue.offer(command)) { int recheck = ctl.get(); //线程池状态改变（不是运行状态）直接打回任务 if (! isRunning(recheck) &amp;&amp; remove(command)) reject(command); else if (workerCountOf(recheck) == 0) addWorker(null, false); //等待队列满了，试图添加新线程，如果失败打回任务 //（当线程数以达到最大线程数则会失败） }else if (!addWorker(command, false)) reject(command); ctl是一个AtomicInteger类型，它用前3位标示线程池运行状态，后面位数表示已有的线程数量，当线程池新增一个任务时，会有四种情况 当前线程数小于核心线程数，直接新建线程执行任务 大于核心线程数，等待队列未满，直接进入队列 等待队列已满，且小于最大线程数，直接新建线程执行任务 都不满足，打回任务 可以看出即使等待队列时FIFO，任务也不一定会完成按照我们添加的顺序执行，当等待队列满的时候，一部分任务会优先执行。 线程复用与回收线程池最大的特点就是线程的复用，同时还有上一节中的非核心线程的回收，本质上来说核心线程和非核心线程没有去吧，他们都存储在一个集合中 private final HashSet&lt;Worker&gt; workers = new HashSet&lt;&gt;(); 线程池中的线程都使用Worker进行封装，线程复用的过程也是借助Workder来进行的，Worker的主要代码如下 private final class Worker extends AbstractQueuedSynchronizer implements Runnable{ ...... final Thread thread; Runnable firstTask; ...... Worker(Runnable firstTask) { setState(-1); // inhibit interrupts until runWorker this.firstTask = firstTask; this.thread = getThreadFactory().newThread(this); } /** Delegates main run loop to outer runWorker. */ public void run() { runWorker(this); } ...... } 我们可以看到Worker本身就是Runnable，他在创建内部线程的同时只是把自己作为参数传递进去，最终thread.start运行时执行的就是Worker的run方法，同时这里会调用ThreadPoolExecutor的runWorker方法以完成最终的线程调度。 final void runWorker(Worker w) { Thread wt = Thread.currentThread(); Runnable task = w.firstTask; ...... try { //getTask从等待队列中获取下一个task while (task != null || (task = getTask()) != null) { ...... try { beforeExecute(wt, task); Throwable thrown = null; try { task.run(); } catch (RuntimeException x) { thrown = x; throw x; } catch (Error x) { thrown = x; throw x; } catch (Throwable x) { thrown = x; throw new Error(x); } finally { afterExecute(task, thrown); } } finally { task = null; w.completedTasks++; w.unlock(); } } completedAbruptly = false; } finally { processWorkerExit(w, completedAbruptly); } } 可以看到在runWorker方法里，Worker内的task为空，会从等待队列中获取一个新的task并执行，同时会调用beforeExecute和afterExecute这两个生命周期方法，同时当任务队列没有清空或者没有异常发生时，这是一个死循环，如果跳出循环，则说明要么任务队列被清空，要么线程异常结束，processWorkerExit会处理这些情况，如果是异常结束会起一个新的线程，否则则会移除大于核心线程数的线程，到此线程的复用过程基本清楚了 我们可以看到ThreadPoolExecutor还有一个keepAliveTime的参数用于空闲时回收非核心线程的时机，这个过程事实上是在getTask获取下一个任务时进行的 ​private Runnable getTask() { boolean timedOut = false; // Did the last poll() time out? for (;;) { int c = ctl.get(); ...... int wc = workerCountOf(c); // Are workers subject to culling? boolean timed = allowCoreThreadTimeOut || wc &gt; corePoolSize; ...... try { Runnable r = timed ? workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) : workQueue.take(); if (r != null) return r; timedOut = true; } catch (InterruptedException retry) { timedOut = false; } } } 可以看到当目前的线程数大于核心线程数时，获取任务时会执行workQueue.poll方法，这个方法在队列空时会等待给定的时间然后才会返回，如果在规定的时间仍然没有新的任务，则会在上面的processWorkerExit回收线程。 除此之外线程池还有等待队列、线程工厂、任务拒绝的handler等要点，由于时间有限，这里暂时不一一说明，以后有时间再做补充，大家也可自行探索。 需要注意的问题线程池十分好用，但是使用中也有些需要注意的点，这里我稍稍列举一些，希望大家使用中可以注意 不要使用线程池执行可能会相互依赖的任务，因为线程池不一定能保证执行顺序，很有可能会发生线程死锁 任务需要考虑可能出现的同步问题，因为任务不是在单线程环境下运行 对时间敏感的任务，不要使用线程池，因为线程池可以保证执行但是无法保证执行的时间 运行时间较长的任务尽量不要和时间较短的任务一起执行，这会严重影响短耗时任务的执行效率]]></content>
      <tags>
        <tag>Android</tag>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android权限管理]]></title>
    <url>%2F2018%2F07%2F11%2FAndroid%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[Android动态权限Android6.0（API23）开始，系统权限出现了很大的变化，此前在权限的检查和获取只发生在app安装时，同时获取后可以一直享有权限。在6.0以后，一些敏感的权限需要动态的获取，同时每次用户可以随时关闭权限，因此需要在每次使用前进行权限检查和获取。 权限等级6.0以后也不是所有权限的获取都需要动态的申请，权限被分成了几个等级，权限的等级主要有四种，分别是Normal、Signature、Dangerous和SignatureOrSystem。 Normal等级：任何应用都可以申请，直接在manifest声明，安装时提示用户，之后会自动获取此类权限。 Dangerous等级：任何应用都可以申请，需要在manifest中声明，同时在使用时需要动态的获取权限。 Signature等级：只有与声明权限的apk使用相同的签名私钥才能申请权限。 SignatureOrSystem:只有与声明权限的apk使用相同的签名私钥或者在/system/app目录下的应用才能申请权限。 这四种权限都是在manifest中声明权限时指定的，在普通的应用开发中我们一般需要关注的只有Normal和Dangerous两种，其中需要动态申请权限的只有Dangerous权限。 Dangerous权限Android下所有的Dangerous权限都被分成权限组，在动态申请权限时，申请的时提示给用户的信息都以组为单位的，比如如果app申请READ_CONTACTS权限,那么系统仅仅提示用户申请联系人权限，如果用户允许，在8.0以下的版本中同组的WRITE_CONTACTS也会一并被获取到，而在8.0及以上WRITE_CONTACTS权限还需要我们去动态的申请，但是系统会立即授予该权限而不会提示用户。 Dangerous权限分组 权限组 权限 CALENDAR READ_CALENDARWRITE_CALENDAR CAMERA CAMERA CONTACTS READ_CONTACTSWRITE_CONTACTSGET_ACCOUNTS LOCATION ACCESS_FINE_LOCATIONACCESS_COARSE_LOCATION MICROPHONE RECORD_AUDIO PHONE READ_PHONE_STATEREAD_PHONE_NUMBERSCALL_PHONEANSWER_PHONE_CALLSREAD_CALL_LOGWRITE_CALL_LOGADD_VOICEMAILUSE_SIPPROCESS_OUTGOING_CALLS SENSORS BODY_SENSORS SMS SEND_SMSRECEIVE_SMSREAD_SMSRECEIVE_WAP_PUSHRECEIVE_MMS STORAGE READ_EXTERNAL_STORAGEWRITE_EXTERNAL_STORAGE 动态权限申请申明权限对于Dangerous的权限，我们首先也需要在manifest中申请，这里以联系人权限为例 &lt;uses-permission android:name=&quot;android.permission.READ_CONTACTS&quot;/&gt; &lt;uses-permission android:name=&quot;android.permission.WRITE_CONTACTS&quot;/&gt; 权限检查在使用试图操作联系人前需要首先确认有没有这个权限 if(ContextCompat.checkSelfPermission(this, Manifest.permission.READ_CONTACTS) != PackageManager.PERMISSION_GRANTED){ //申请权限 }else{ //读取联系人 } ContextCompat.checkSelfPermission(Context context, String permission)方法用于检查App是否拥有参数指定的权限，方法的返回值为int，可能的取值如下 PERMISSION_GRANTED 已经获取权限 PERMISSION_DENIED 还没有获取权限 权限申请如果尚未获取权限则在使用之前需要先申请权限 ActivityCompat.requestPermissions(this, new String[]{Manifest.permission.READ_CONTACTS},CODE_REQUEST_CONTACTS); 一般情况下，ActivityCompat.requestPermissions方法会使用一个标准的对话框提示用户，但是有些机型则会跳转到一个新的页面做这件事（会导致Activity声明周期变化，甚至重启）。 申请之后则需要等待用户选择，如果如果你的Activity不是继承自AppCompatActivity，则需要实现OnRequestPermissionsResultCallback用于接收权限请求的结果回掉。 public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) { super.onRequestPermissionsResult(requestCode, permissions, grantResults); if(requestCode==CODE_REQUEST_CONTACTS){ if(grantResults[0]==PackageManager.PERMISSION_GRANTED){ //读取联系人 }else{ //权限获取失败 } } } 合理的权限申请用户首次拒绝授予权限之后，当第二次进行权限请求时，会出现“不再提示”的选项，如果用户勾选，则后续对此权限的申请将不再提示用户，直接失败。因此我们需要在合适的时机解释获取权限的原因，我们可以使用ActivityCompat.shouldShowRequestPermissionRationale方法来确定是否需要告知用户，这个方法默认情况下返回false，当用户拒绝过授予此权限后，这个返回值为true（用户勾选不再提示后返回值为false）。 if (ContextCompat.checkSelfPermission(this, Manifest.permission.READ_CONTACTS) != PackageManager.PERMISSION_GRANTED) { if (ActivityCompat.shouldShowRequestPermissionRationale(this, Manifest.permission.READ_CONTACTS)) { //提示用户后申请权限 } else { //申请权限 ActivityCompat.requestPermissions(this, new String[]{Manifest.permission.READ_CONTACTS}, CODE_REQUEST_CONTACTS); } } else { //读取联系人 } 权限被拒绝权限被拒绝后，再次申请会继续弹出，但是当用户勾选“不再提示”后，下次权限申请系统将不再提示用户，而是直接拒绝，这种情况下，我们只能引导用户到设置里自己打开权限，我们可以在onRequestPermissionsResult中通过ActivityCompat.shouldShowRequestPermissionRationale来判断用户是否选择了不再提示。 public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) { if (requestCode == CODE_REQUEST_CONTACTS) { if (grantResults[0] == PackageManager.PERMISSION_GRANTED) { //读取联系人 } else { if(!ActivityCompat.shouldShowRequestPermissionRationale(this, Manifest.permission.READ_CONTACTS)){ //引导用户到设置页面开启权限 } } } } //跳转到设置页面相关代码 Intent intent = new Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS); Uri uri = Uri.fromParts(&quot;package&quot;,getApplicationContext().getPackageName(), null); intent.setData(uri); startActivity(intent); 参考文章 Android 权限的一些细节 Android中的权限管理 Android 6.0 运行时权限处理完全解析 Android6.0动态权限申请步骤以及需要注意的一些坑]]></content>
      <tags>
        <tag>Android</tag>
        <tag>permission</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AndrodUI测试入门]]></title>
    <url>%2F2018%2F03%2F05%2FAndrodUI%E6%B5%8B%E8%AF%95%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[UI测试UI 测试是为了确保对于用户的UI动作，app能返回正确的UI输出。根据实际实现方案大体可以分为两种： End-To-End（E2E）UI测试，直接通过客户端和后台服务器的交互测试整个系统，普通操作UI，通过网络获取数据，验证UI数据。实现简单，但是存在测试速度缓慢，可能因为网络导致测试用例不通过的问题。 封闭UI测试，测试方法使得测试不需要外部依赖和网络请求，使用Mock Server或者其他方式替代真实的网络请求，只验证UI输出的正确性。 UI测试框架Android之前比较流行的UI测试框架有robotium、Appium、uiautomator、Calabash、Espresso,但是其中Espresso作为Google官方开源的UI测试框架，以其官方的身份、完整的使用文档以及简单的使用方法，快速成为UI测试框架中的主流，本文就是以Espresso框架为主要测试框架。 Espresso介绍及集成Espresso 测试框架提供了一组 API 来构建 UI 测试，用于测试应用中的用户流。利用这些 API，您可以编写简洁、运行可靠的自动化 UI 测试。Espresso 非常适合编写白盒自动化测试，其中测试代码将利用所测试应用的实现代码详情。目前Espresso最新的版本已经出道3.0.1，使用AS创建的工程，默认已经集成了2.2.2版本的Espresso，但是如果要集成最新版本的Espresso库，需要在仓库配置中添加对应仓库地址： allprojects { repositories { jcenter() maven { url &quot;https://maven.google.com&quot; //Espresso3.0.1所在仓库地址 } } } 默认集成的Espresso包espresso-core及其相关依赖包，足以完成一般性的UI测试，除此之外Espresso还有一些扩展包，用于完成一些特殊的测试场景: espresso-web 提供了对WebView测试的相关支持 espresso-contrib 提供了对DatePicker, RecyclerView 和 Drawer等控件的特有动作、无障碍以及CountingIdlingResource的支持 espresso-intents 用于校验多app测试中intent的正确性 espresso-idling-resource（已经包含在core的依赖中）用于处理异步线程同步问题 如果测试过程中不需要上述的扩展功能，则只需要添加core的依赖 dependencies { androidTestCompile(&apos;com.android.support.test.espresso:espresso-core:3.0.1&apos;, { exclude group: &apos;com.android.support&apos;, module: &apos;support-annotations&apos; //不导入依赖中的support-annotations，避免出现依赖冲突，会使用用户自己导入的包 }) } 其余诸如runner，rules包都被core依赖，会自动导入，没有必要手动导入，以免导入版本不正确引起其他问题，除了上面描述的相关库，Espresso还依赖了JUnit和Hamcrest等其他测试辅助框架。 EspressoUI测试的重要对象 Espresso Espresso框架的入口类，提供了一些静态方法，便于开始整个测试代码，它提供了类似onView和onData这种方法获取一个可交互的对象ViewInteraction，或者直接进行一个例如页面返回的顶层操作。 ViewMatchers 定义了一系列静态方法用于根据不同条件返回Matcher&lt;? super View&gt;对象，作为参数传递给onView()。 ViewActions view的操作行为例如click()，最为ViewInteraction.perform()的参数用于对指定View的进行对应操作。 ViewAssertions 作为ViewInteraction.check()的参数，判断view的输出是否正确 ActivityTestRule 提供了测试单个Activity的功能，当它的launchActivity设置为true时，它会在每个使用@Test注释的方法前和所有注释者@Before的方法前启动。同时可以通过ActivityTestRule对象获取对应Activity的对象。 一个简单的代码示例如下： @RunWith(AndroidJUnit4.class) public class LoginTest { @Rule public ActivityTestRule&lt;LoginActivity&gt; mActivityRule = new ActivityTestRule(LoginActivity.class); @Test public void login() throws Exception { onView(withId(R.id.et_login_number)).perform(click(),replaceText(&quot;17720380994&quot;),closeSoftKeyboard()); onView(withId(R.id.btn_login_next)).perform(click()); onView(withId(R.id.et_password)).perform(click(),replaceText(&quot;aa123456&quot;),closeSoftKeyboard()); onView(withId(R.id.btn_login)).perform(click()); onView(withId(R.id.toolbar)).check(matches(isDisplayed())); onView(allOf(instanceOf(ImageButton.class),withParent(withId(R.id.toolbar)),isDisplayed())).perform(click()); onView(withId(R.id.tv_phone_number)).check(matches(withText(&quot;17720380994&quot;))); onView(IsInstanceOf.&lt;View&gt;instanceOf(ScrollView.class)).perform(swipeUp()); onView(withId(R.id.tv_exit)).perform(click()); onView(withText(R.string.exit_login_confirm)).check(matches(isDisplayed())); onView(withId(R.id.tv_ok)).perform(click()); onView(withId(R.id.et_login_number)).check(matches(isDisplayed())); } } 总体来说UI测试的过程就是：找到某个元素，做一些操作，检查结果。 寻找ViewEspresso中定位View主要有两种，通过页面显示的View特征（onView）和通过数据内容（onData），其中onView用于普通场景，onData用于adapterView这种可能没有渲染的view，但是两者都是基于hamcrest的matcher来进行，本质是相同的不同的是匹配规则 ViewMathcerViewMathcer实质上提供了很多Matcher对象，主要用于配合OnView匹配控件，这些Matcher同时可以配合hamcrest中的matcher一起使用，效果更好。常用的Matcher如下 withId() onView(withId(R.id.tv_ok))直接通过id定位指定的的View，简单粗暴，但是非常实用。 isAssignableFrom() onView(isAssignableFrom(ScrollView.class))通过对象类型判断 isDisplayed() onView(allOf(isDisplayed(),isAssignableFrom(ScrollView.class))) 通过是否显示判断，通常和其他matcher配合(allOf是hamcrest库重的方法，用于匹配多个matcher，类似的还有anyOf) isEnabled() isFocusable()…… ViewMathcer中几乎把所有的View属性都定义了对应的matcher，需要的可以自行查阅源码或文档。 DataInteractionDataInteraction 是onData方法的返回值，因为onData方法匹配出的不直接就是View，它匹配的是一个数据集合，只有我们想要进行具体的View操作时，Espresso才会把它转化为View。​ onData(instanceOf(Account.class))Espresso没有为onData定义Matcher，基本都是使用hamcrest中定义的matcher或者自定义matcher 自定义Matcher一般自定义Matcher都继承TypeSafeMatcher，需要实现的方法如下 public class CallInfoMatcher extends TypeSafeMatcher&lt;CallInfo&gt; { @Override public void describeTo(Description description) { //匹配失败时的描述，用于描述具体的匹配失败信息 } @Override protected boolean matchesSafely(CallInfo item) { //具体的匹配过程 return false; } } 对View的操作View的操作都是在ViewInteraction上进行的。ViewInteraction也就是onView的返回值对象，用于对于具体的View进行操作（DataInteraction的操作也是转换为ViewInteraction后进行的），ViewInteraction提供了如下方法来对相应的元素做操作： public ViewInteraction perform(final ViewAction... viewActions) {} 具体的操作通过ViewAction定义，连续操作可以链式调用或者作为参数顺序排列。 ViewActionViewAction是espresso中定义的针对View操作的接口类型。ViewAction中实现主要在ViewActions类中通过静态方法提供。常见的action如下 click() closeSoftKeyboard() replaceText()…… 除去ViewActions提供的较为通用的操作方法，Espresso还提供了很多ViewAction的子类用于完成不同View的特定操作。 ViewAction是在View匹配成功的基础上进行的匹配失败或者匹配不唯一都会导致测试不通过，同时Action与View类型不匹配也会失败 校验结果测试最重要的一步就是校验结果的正确性，ViewInteraction提供了check()方法用于校验正确性 public ViewInteraction check(final ViewAssertion viewAssert) { ...... } 和perform()方法类似，check()也是可以链式调用多次校验。 ViewAssertionViewAssertion是espresso中定义的用于校验View状态的接口类型，同样ViewAssertion也主要由ViewAssertions中的静态方法提供。其中主要使用的就是matches()方法 public static ViewAssertion matches(final Matcher&lt;? super View&gt; viewMatcher) { return new MatchesViewAssertion(checkNotNull(viewMatcher)); } 其中参数viewMatcher就是前面用于匹配View的ViewMatcher。 异步问题Espresso提供了大量的同步机制，这些机制主要针对于主线层的MQ，但是Espresso对于其他的异步操作是无感知的，如果View的显示依赖于网络数据，很有可能就会导致测试用例不通过，因此需要使用前面使用的espresso-idling-resource来保证Espresso在异步线程的可靠性。 espresso-idling-resource依赖添加如下 compile(&quot;com.android.support.test.espresso:espresso-idling-resource:3.0.1&quot;) { exclude module: &apos;support-annotations&apos; } androidTestCompile(&quot;com.android.support.test.espresso:espresso-idling-resource:3.0.1&quot;) { exclude module: &apos;support-annotations&apos; } //由于Espresso对与异步线程无感知，我们需要在代码中主动使用IdlingResource，因此需要使用compile依赖。 IdlingResourceEspresso主要通过IdlingResource这个接口类型完成对异步资源的感知，主要方法如下 public interface IdlingResource { //用于标识对于的异步资源 public String getName(); //返回目前资源是否可用(闲置)， public boolean isIdleNow(); //Espresso会注册此回掉，需要判断资源可用时主动调用 public void registerIdleTransitionCallback(ResourceCallback callback); public interface ResourceCallback { public void onTransitionToIdle(); } } Espresso提供了几个IdlingResource的实现类，可以直接使用： CountingIdlingResource 为资源提供了一个简单的使用计数，当count为0时资源为闲置状态。 UriIdlingResource 类似CountingIdlingResource,但是count为0时资源不会立即为闲置状态。 IdlingThreadPoolExecutor 一个有IdlingResource功能的ThreadPoolExecutor。 IdlingScheduledThreadPoolExecutor em.. 同上 我们借CountingIdlingResource来了解下IdlingResource的主要用法，CountingIdlingResource主要提供的两个共有方法供我们使用 increment()计数加一 decrement()计数减一，为0时调用onTransitionToIdle() 例如使用网络请求的场景，发起请求时increment()表示资源被占用，请求结束时decrement()，表示资源被释放。同时还需要在测试代码中注册对应资源 IdlingRegistry.getInstance().register(idlingResource); IdlingResource解决了异步代码的问题，但是依旧存在问题，我们在业务逻辑代码中创建IdlingResource对象，同时在需要的地方去改变它的状态，然后在测试代码中使用。这无疑是为了测试而给正常的业务代码增加了不必要的逻辑。 未完待续～]]></content>
      <tags>
        <tag>Android</tag>
        <tag>Test</tag>
      </tags>
  </entry>
</search>
