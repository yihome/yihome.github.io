<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2018%2F02%2F06%2FJUnit%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[单元测试测试的重要性我就不多做解释，这里只介绍一下Android下测试分类，Android下的测试分为三种： 单元测试； 交互UI测试； End-to-End测试。 这三种测试中End-to-End测试(E2E test)是通过客户端和后台服务器的交互测试整个系统，通常又测试人员进行，交互UI测试由于需要了解代码流程，通常也有开发人员进行，最后单元测试就不用多说必然由开发人员进行。 Android下的单元测试又可以分为两种： 纯java的JUnit单元测试 基于Android设备的AndroidJUnit单元测试 两者的相比较，而AndroidJUnit测试覆盖面大，但是需要依赖Android设备，JUnit胜在在于运行速度快，可以脱离具体设备，但是设计难度偏大，作用范围有限，在没有分层之前基本上只能作用在util类上，但是使用类似MVP的分层结构之后，JUnit配合Mock基本能覆盖主要逻辑的测试。 JUnit单元测试JUnit作为一款强大的单元测试工具，AndroidStudio在创建工程时就会自动使用如下配置为我们集成JUnittestCompile &apos;junit:junit:4.12&apos; 同时还会生成一个样例代码。我们想要生成一个类的单元测试类也是非常容易，直接在文件右键，选择goto即可看到选项。 JUnit提供给我们使用的主要就是两块内容：注解和断言，注解用于声测试方法和控制测试执行流程，断言用于判断测试结果是否符合预期。 JUnit注解JUnit使用注解方式控制测试运行流程，常用的流程控制注解如下所示 注解 描述 @Test public void method() 测试注释指示该公共无效方法它所附着可以作为一个测试用例。 @Before public void method() Before注释表示，该方法必须在类中的每个测试之前执行，以便执行测试某些必要的先决条件。 @BeforeClass public static void method() BeforeClass注释指出这是附着在静态方法必须执行一次并在类的所有测试之前。发生这种情况时一般是测试计算共享配置方法(如连接到数据库)。 @After public void method() After 注释指示，该方法在执行每项测试后执行(如执行每一个测试后重置某些变量，删除临时变量等) @AfterClass public static void method() 当需要执行所有的测试在JUnit测试用例类后执行，AfterClass注解可以使用以清理建立方法，(从数据库如断开连接)。注意：附有此批注(类似于BeforeClass)的方法必须定义为静态。 @Ignore 修饰测试类或者方法 执行过程中会忽略指定的测试类或者方法 JUnit断言JUnit提供了下列断言，用于在测试方法内判断代码运行的正确性 断言 描述 assertNull(Object object) 检查对象是否为空 assertNotNull(Object object) 检查对象是否不为空 assertEquals(long expected, long actual) 检查long类型的值是否相等 assertEquals(double expected, double actual, double delta) 检查指定精度的double值是否相等 assertFalse(boolean condition) 检查条件是否为假 assertTrue(boolean condition) 检查条件是否为真 assertSame(Object expected, Object actual) 检查两个对象引用是否引用同一对象（即对象是否相等） assertNotSame(Object unexpected, Object actual) 检查两个对象引用是否不引用统一对象(即对象不等) JUnit简单介绍到此为止，接下来就正式开始介绍，如何在Android环境下进行单元测试。 PS: 为什么没有code？coding还为时尚早，简单的JUnit还是很难满足Android下单元测试的要求。 Mockito在最开始中说到，使用分层可以把纯java的逻辑分离出来，以方便进行JUnit单元测试，但是即使使用分层抽离的设备无关代码，经过方法调用后最终也还是会调用了设备相关代码。这时候就需要使用mock对象了。 Mock 对象原理Mockito使用Mockito正是一个基于Mock对象的框架，它可以使用Class对象，来]]></content>
  </entry>
  <entry>
    <title><![CDATA[Gradle脚本从入门到...(1)]]></title>
    <url>%2F2018%2F01%2F19%2FGradle%E8%84%9A%E6%9C%AC%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0-1%2F</url>
    <content type="text"><![CDATA[前言之前也写过一篇关于Gradle的文章，但是想要All In Once，最后写了一篇长文，但是结果很不理想，感觉什么都要讲，但是很多东西又都没有讲清楚。刚好最近突发奇想，想要搭个自己blog，以此为契机把之前的文章再整理一下。言归正传，正文开始。 Gradle介绍Gradle是一个项目自动构建工具，属于代码之外，和ant、maven这类老牌的构建工具相比，最大的不同就是不同就是使用groovy脚本语言替代了xml作为项目构建的配置方式。相比于繁琐的xml，groovy无疑在代码简洁和已于理解上有着很大的优势。除此之外Gradle与maven在依赖控制上有着极大的共同之处，甚至Gradle的依赖管理就是在maven的基础上发展而来。 虽然Gradle的使用者大部分都是从AS而来，但是想要了解Gradle最好还是先抛开IDE，拥抱命令行。因为大部分情况下IDE都会对原始的Gradle做一层封装，一来不方便深入学习，二来不利于暴露问题。 Gradle的安装Gradle除了最初的从无到有的情况外，基本上不需要手动安装，然而我们最开始还真是一无所有。有两种方式安装Gradle： 直接到官网 下载需要的对应平台的版本。 使用包管理器直接下载，目前支持5种包管理，后续可能会增加，详情请见 安装完成之后，就是配置好对应的环境变量，需要配置的目录为../gradle../bin 配置方法请按各自平台进行。配置完成后，使用如下命令 $ gradle -v 正常输出Gradle版本，表示安装完成。 Gradle Wrapper前面说Gradle基本不需要手动安装，就是由于Gradle Wrapper的存在。Wrapper是一个使用了特定gradle版本的脚本，能够直接通过此脚本运行Gradle命令，即使此前没有下载过gradle，当然如果没有下载过gradle，wrapper脚本会去下载对应版本的Gradle。 使用AS打开github上的新项目时极有可能就会开在Gradle版本下载上，根本上网络问题，可以取消去手动下载。 生成Wrapper非常简单，直接运行对应命令行指令 gradle wrapper:wrapperBUILD SUCCESSFUL in 0s1 actionable task: 1 executed 即可生成path内对应版本的wrapper，生成的wraper主要包括如下文件 drwxr-xr-x 4 houyi staff 128 1 29 13:55 .gradledrwxr-xr-x 3 houyi staff 96 1 29 13:55 gradle-rwxr-xr-x 1 houyi staff 5296 1 29 13:55 gradlew-rw-r--r-- 1 houyi staff 2260 1 29 13:55 gradlew.bat 在gradle目录下]]></content>
      <tags>
        <tag>Gradle</tag>
        <tag>Android</tag>
        <tag>构建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F12%2F28%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new "My New Post" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
